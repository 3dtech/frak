(function() {
    "use strict";
    var shim = {};
    if (typeof exports === "undefined") {
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
            shim.exports = {};
            define(function() {
                return shim.exports;
            });
        } else {
            shim.exports = window;
        }
    } else {
        shim.exports = exports;
    }
    (function(exports) {
        var vec2 = {};
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        vec2.create = function() {
            return new Float32Array(2);
        };
        vec2.clone = function(a) {
            var out = new Float32Array(2);
            out[0] = a[0];
            out[1] = a[1];
            return out;
        };
        vec2.fromValues = function(x, y) {
            var out = new Float32Array(2);
            out[0] = x;
            out[1] = y;
            return out;
        };
        vec2.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            return out;
        };
        vec2.set = function(out, x, y) {
            out[0] = x;
            out[1] = y;
            return out;
        };
        vec2.add = function(out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            return out;
        };
        vec2.sub = vec2.subtract = function(out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            return out;
        };
        vec2.mul = vec2.multiply = function(out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            return out;
        };
        vec2.div = vec2.divide = function(out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            return out;
        };
        vec2.min = function(out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            return out;
        };
        vec2.max = function(out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            return out;
        };
        vec2.scale = function(out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            return out;
        };
        vec2.dist = vec2.distance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1];
            return Math.sqrt(x * x + y * y);
        };
        vec2.sqrDist = vec2.squaredDistance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1];
            return x * x + y * y;
        };
        vec2.len = vec2.length = function(a) {
            var x = a[0], y = a[1];
            return Math.sqrt(x * x + y * y);
        };
        vec2.sqrLen = vec2.squaredLength = function(a) {
            var x = a[0], y = a[1];
            return x * x + y * y;
        };
        vec2.negate = function(out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            return out;
        };
        vec2.normalize = function(out, a) {
            var x = a[0], y = a[1];
            var len = x * x + y * y;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
            }
            return out;
        };
        vec2.dot = function(a, b) {
            return a[0] * b[0] + a[1] * b[1];
        };
        vec2.cross = function(out, a, b) {
            var z = a[0] * b[1] - a[1] * b[0];
            out[0] = out[1] = 0;
            out[2] = z;
            return out;
        };
        vec2.lerp = function(out, a, b, t) {
            var ax = a[0], ay = a[1];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            return out;
        };
        vec2.transformMat2 = function(out, a, m) {
            var x = a[0], y = a[1];
            out[0] = x * m[0] + y * m[1];
            out[1] = x * m[2] + y * m[3];
            return out;
        };
        vec2.forEach = function() {
            var vec = new Float32Array(2);
            return function(a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 2;
                }
                if (!offset) {
                    offset = 0;
                }
                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }
                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];
                    vec[1] = a[i + 1];
                    fn(vec, vec, arg);
                    a[i] = vec[0];
                    a[i + 1] = vec[1];
                }
                return a;
            };
        }();
        vec2.str = function(a) {
            return "vec2(" + a[0] + ", " + a[1] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.vec2 = vec2;
        }
        var vec3 = {};
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        vec3.create = function() {
            return new Float32Array(3);
        };
        vec3.clone = function(a) {
            var out = new Float32Array(3);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        };
        vec3.fromValues = function(x, y, z) {
            var out = new Float32Array(3);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        };
        vec3.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            return out;
        };
        vec3.set = function(out, x, y, z) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            return out;
        };
        vec3.add = function(out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            return out;
        };
        vec3.sub = vec3.subtract = function(out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            return out;
        };
        vec3.mul = vec3.multiply = function(out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            return out;
        };
        vec3.div = vec3.divide = function(out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            return out;
        };
        vec3.min = function(out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            return out;
        };
        vec3.max = function(out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            return out;
        };
        vec3.scale = function(out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            return out;
        };
        vec3.dist = vec3.distance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
            return Math.sqrt(x * x + y * y + z * z);
        };
        vec3.sqrDist = vec3.squaredDistance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2];
            return x * x + y * y + z * z;
        };
        vec3.len = vec3.length = function(a) {
            var x = a[0], y = a[1], z = a[2];
            return Math.sqrt(x * x + y * y + z * z);
        };
        vec3.sqrLen = vec3.squaredLength = function(a) {
            var x = a[0], y = a[1], z = a[2];
            return x * x + y * y + z * z;
        };
        vec3.negate = function(out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            return out;
        };
        vec3.normalize = function(out, a) {
            var x = a[0], y = a[1], z = a[2];
            var len = x * x + y * y + z * z;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
            }
            return out;
        };
        vec3.dot = function(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
        };
        vec3.cross = function(out, a, b) {
            var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2];
            out[0] = ay * bz - az * by;
            out[1] = az * bx - ax * bz;
            out[2] = ax * by - ay * bx;
            return out;
        };
        vec3.lerp = function(out, a, b, t) {
            var ax = a[0], ay = a[1], az = a[2];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            return out;
        };
        vec3.transformMat4 = function(out, a, m) {
            var x = a[0], y = a[1], z = a[2];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
            return out;
        };
        vec3.transformQuat = function(out, a, q) {
            var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        };
        vec3.forEach = function() {
            var vec = new Float32Array(3);
            return function(a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 3;
                }
                if (!offset) {
                    offset = 0;
                }
                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }
                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];
                    vec[1] = a[i + 1];
                    vec[2] = a[i + 2];
                    fn(vec, vec, arg);
                    a[i] = vec[0];
                    a[i + 1] = vec[1];
                    a[i + 2] = vec[2];
                }
                return a;
            };
        }();
        vec3.str = function(a) {
            return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.vec3 = vec3;
        }
        var vec4 = {};
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        vec4.create = function() {
            return new Float32Array(4);
        };
        vec4.clone = function(a) {
            var out = new Float32Array(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };
        vec4.fromValues = function(x, y, z, w) {
            var out = new Float32Array(4);
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        };
        vec4.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };
        vec4.set = function(out, x, y, z, w) {
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = w;
            return out;
        };
        vec4.add = function(out, a, b) {
            out[0] = a[0] + b[0];
            out[1] = a[1] + b[1];
            out[2] = a[2] + b[2];
            out[3] = a[3] + b[3];
            return out;
        };
        vec4.sub = vec4.subtract = function(out, a, b) {
            out[0] = a[0] - b[0];
            out[1] = a[1] - b[1];
            out[2] = a[2] - b[2];
            out[3] = a[3] - b[3];
            return out;
        };
        vec4.mul = vec4.multiply = function(out, a, b) {
            out[0] = a[0] * b[0];
            out[1] = a[1] * b[1];
            out[2] = a[2] * b[2];
            out[3] = a[3] * b[3];
            return out;
        };
        vec4.div = vec4.divide = function(out, a, b) {
            out[0] = a[0] / b[0];
            out[1] = a[1] / b[1];
            out[2] = a[2] / b[2];
            out[3] = a[3] / b[3];
            return out;
        };
        vec4.min = function(out, a, b) {
            out[0] = Math.min(a[0], b[0]);
            out[1] = Math.min(a[1], b[1]);
            out[2] = Math.min(a[2], b[2]);
            out[3] = Math.min(a[3], b[3]);
            return out;
        };
        vec4.max = function(out, a, b) {
            out[0] = Math.max(a[0], b[0]);
            out[1] = Math.max(a[1], b[1]);
            out[2] = Math.max(a[2], b[2]);
            out[3] = Math.max(a[3], b[3]);
            return out;
        };
        vec4.scale = function(out, a, b) {
            out[0] = a[0] * b;
            out[1] = a[1] * b;
            out[2] = a[2] * b;
            out[3] = a[3] * b;
            return out;
        };
        vec4.dist = vec4.distance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        };
        vec4.sqrDist = vec4.squaredDistance = function(a, b) {
            var x = b[0] - a[0], y = b[1] - a[1], z = b[2] - a[2], w = b[3] - a[3];
            return x * x + y * y + z * z + w * w;
        };
        vec4.len = vec4.length = function(a) {
            var x = a[0], y = a[1], z = a[2], w = a[3];
            return Math.sqrt(x * x + y * y + z * z + w * w);
        };
        vec4.sqrLen = vec4.squaredLength = function(a) {
            var x = a[0], y = a[1], z = a[2], w = a[3];
            return x * x + y * y + z * z + w * w;
        };
        vec4.negate = function(out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = -a[3];
            return out;
        };
        vec4.normalize = function(out, a) {
            var x = a[0], y = a[1], z = a[2], w = a[3];
            var len = x * x + y * y + z * z + w * w;
            if (len > 0) {
                len = 1 / Math.sqrt(len);
                out[0] = a[0] * len;
                out[1] = a[1] * len;
                out[2] = a[2] * len;
                out[3] = a[3] * len;
            }
            return out;
        };
        vec4.dot = function(a, b) {
            return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
        };
        vec4.lerp = function(out, a, b, t) {
            var ax = a[0], ay = a[1], az = a[2], aw = a[3];
            out[0] = ax + t * (b[0] - ax);
            out[1] = ay + t * (b[1] - ay);
            out[2] = az + t * (b[2] - az);
            out[3] = aw + t * (b[3] - aw);
            return out;
        };
        vec4.transformMat4 = function(out, a, m) {
            var x = a[0], y = a[1], z = a[2], w = a[3];
            out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
            out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
            out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
            out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
            return out;
        };
        vec4.transformQuat = function(out, a, q) {
            var x = a[0], y = a[1], z = a[2], qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = qw * x + qy * z - qz * y, iy = qw * y + qz * x - qx * z, iz = qw * z + qx * y - qy * x, iw = -qx * x - qy * y - qz * z;
            out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return out;
        };
        vec4.forEach = function() {
            var vec = new Float32Array(4);
            return function(a, stride, offset, count, fn, arg) {
                var i, l;
                if (!stride) {
                    stride = 4;
                }
                if (!offset) {
                    offset = 0;
                }
                if (count) {
                    l = Math.min(count * stride + offset, a.length);
                } else {
                    l = a.length;
                }
                for (i = offset; i < l; i += stride) {
                    vec[0] = a[i];
                    vec[1] = a[i + 1];
                    vec[2] = a[i + 2];
                    vec[3] = a[i + 3];
                    fn(vec, vec, arg);
                    a[i] = vec[0];
                    a[i + 1] = vec[1];
                    a[i + 2] = vec[2];
                    a[i + 3] = vec[3];
                }
                return a;
            };
        }();
        vec4.str = function(a) {
            return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.vec4 = vec4;
        }
        var mat2 = {};
        var mat2Identity = new Float32Array([ 1, 0, 0, 1 ]);
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        mat2.create = function() {
            return new Float32Array(mat2Identity);
        };
        mat2.clone = function(a) {
            var out = new Float32Array(4);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };
        mat2.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            return out;
        };
        mat2.identity = function(out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };
        mat2.transpose = function(out, a) {
            if (out === a) {
                var a1 = a[1];
                out[1] = a[2];
                out[2] = a1;
            } else {
                out[0] = a[0];
                out[1] = a[2];
                out[2] = a[1];
                out[3] = a[3];
            }
            return out;
        };
        mat2.invert = function(out, a) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], det = a0 * a3 - a2 * a1;
            if (!det) {
                return null;
            }
            det = 1 / det;
            out[0] = a3 * det;
            out[1] = -a1 * det;
            out[2] = -a2 * det;
            out[3] = a0 * det;
            return out;
        };
        mat2.adjoint = function(out, a) {
            var a0 = a[0];
            out[0] = a[3];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = a0;
            return out;
        };
        mat2.determinant = function(a) {
            return a[0] * a[3] - a[2] * a[1];
        };
        mat2.mul = mat2.multiply = function(out, a, b) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
            var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = a0 * b0 + a1 * b2;
            out[1] = a0 * b1 + a1 * b3;
            out[2] = a2 * b0 + a3 * b2;
            out[3] = a2 * b1 + a3 * b3;
            return out;
        };
        mat2.rotate = function(out, a, rad) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], s = Math.sin(rad), c = Math.cos(rad);
            out[0] = a0 * c + a1 * s;
            out[1] = a0 * -s + a1 * c;
            out[2] = a2 * c + a3 * s;
            out[3] = a2 * -s + a3 * c;
            return out;
        };
        mat2.scale = function(out, a, v) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], v0 = v[0], v1 = v[1];
            out[0] = a0 * v0;
            out[1] = a1 * v1;
            out[2] = a2 * v0;
            out[3] = a3 * v1;
            return out;
        };
        mat2.str = function(a) {
            return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.mat2 = mat2;
        }
        var mat3 = {};
        var mat3Identity = new Float32Array([ 1, 0, 0, 0, 1, 0, 0, 0, 1 ]);
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        mat3.create = function() {
            return new Float32Array(mat3Identity);
        };
        mat3.clone = function(a) {
            var out = new Float32Array(9);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        };
        mat3.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            return out;
        };
        mat3.identity = function(out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 1;
            out[5] = 0;
            out[6] = 0;
            out[7] = 0;
            out[8] = 1;
            return out;
        };
        mat3.transpose = function(out, a) {
            if (out === a) {
                var a01 = a[1], a02 = a[2], a12 = a[5];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a01;
                out[5] = a[7];
                out[6] = a02;
                out[7] = a12;
            } else {
                out[0] = a[0];
                out[1] = a[3];
                out[2] = a[6];
                out[3] = a[1];
                out[4] = a[4];
                out[5] = a[7];
                out[6] = a[2];
                out[7] = a[5];
                out[8] = a[8];
            }
            return out;
        };
        mat3.invert = function(out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b01 = a22 * a11 - a12 * a21, b11 = -a22 * a10 + a12 * a20, b21 = a21 * a10 - a11 * a20, det = a00 * b01 + a01 * b11 + a02 * b21;
            if (!det) {
                return null;
            }
            det = 1 / det;
            out[0] = b01 * det;
            out[1] = (-a22 * a01 + a02 * a21) * det;
            out[2] = (a12 * a01 - a02 * a11) * det;
            out[3] = b11 * det;
            out[4] = (a22 * a00 - a02 * a20) * det;
            out[5] = (-a12 * a00 + a02 * a10) * det;
            out[6] = b21 * det;
            out[7] = (-a21 * a00 + a01 * a20) * det;
            out[8] = (a11 * a00 - a01 * a10) * det;
            return out;
        };
        mat3.adjoint = function(out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
            out[0] = a11 * a22 - a12 * a21;
            out[1] = a02 * a21 - a01 * a22;
            out[2] = a01 * a12 - a02 * a11;
            out[3] = a12 * a20 - a10 * a22;
            out[4] = a00 * a22 - a02 * a20;
            out[5] = a02 * a10 - a00 * a12;
            out[6] = a10 * a21 - a11 * a20;
            out[7] = a01 * a20 - a00 * a21;
            out[8] = a00 * a11 - a01 * a10;
            return out;
        };
        mat3.determinant = function(a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8];
            return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
        };
        mat3.mul = mat3.multiply = function(out, a, b) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], b00 = b[0], b01 = b[1], b02 = b[2], b10 = b[3], b11 = b[4], b12 = b[5], b20 = b[6], b21 = b[7], b22 = b[8];
            out[0] = b00 * a00 + b01 * a10 + b02 * a20;
            out[1] = b00 * a01 + b01 * a11 + b02 * a21;
            out[2] = b00 * a02 + b01 * a12 + b02 * a22;
            out[3] = b10 * a00 + b11 * a10 + b12 * a20;
            out[4] = b10 * a01 + b11 * a11 + b12 * a21;
            out[5] = b10 * a02 + b11 * a12 + b12 * a22;
            out[6] = b20 * a00 + b21 * a10 + b22 * a20;
            out[7] = b20 * a01 + b21 * a11 + b22 * a21;
            out[8] = b20 * a02 + b21 * a12 + b22 * a22;
            return out;
        };
        mat3.str = function(a) {
            return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.mat3 = mat3;
        }
        var mat4 = {};
        var mat4Identity = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        mat4.create = function() {
            return new Float32Array(mat4Identity);
        };
        mat4.clone = function(a) {
            var out = new Float32Array(16);
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };
        mat4.copy = function(out, a) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4];
            out[5] = a[5];
            out[6] = a[6];
            out[7] = a[7];
            out[8] = a[8];
            out[9] = a[9];
            out[10] = a[10];
            out[11] = a[11];
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };
        mat4.identity = function(out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = 1;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 1;
            out[11] = 0;
            out[12] = 0;
            out[13] = 0;
            out[14] = 0;
            out[15] = 1;
            return out;
        };
        mat4.transpose = function(out, a) {
            if (out === a) {
                var a01 = a[1], a02 = a[2], a03 = a[3], a12 = a[6], a13 = a[7], a23 = a[11];
                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a01;
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a02;
                out[9] = a12;
                out[11] = a[14];
                out[12] = a03;
                out[13] = a13;
                out[14] = a23;
            } else {
                out[0] = a[0];
                out[1] = a[4];
                out[2] = a[8];
                out[3] = a[12];
                out[4] = a[1];
                out[5] = a[5];
                out[6] = a[9];
                out[7] = a[13];
                out[8] = a[2];
                out[9] = a[6];
                out[10] = a[10];
                out[11] = a[14];
                out[12] = a[3];
                out[13] = a[7];
                out[14] = a[11];
                out[15] = a[15];
            }
            return out;
        };
        mat4.invert = function(out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32, det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            if (!det) {
                return null;
            }
            det = 1 / det;
            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
            return out;
        };
        mat4.adjoint = function(out, a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
            out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
            out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
            out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
            out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
            out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
            out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
            out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
            out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
            out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
            out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
            out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
            out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
            out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
            out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
            out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
            return out;
        };
        mat4.determinant = function(a) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15], b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12, b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
            return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
        };
        mat4.mul = mat4.multiply = function(out, a, b) {
            var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[4];
            b1 = b[5];
            b2 = b[6];
            b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[8];
            b1 = b[9];
            b2 = b[10];
            b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[12];
            b1 = b[13];
            b2 = b[14];
            b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        };
        mat4.translate = function(out, a, v) {
            var x = v[0], y = v[1], z = v[2], a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
            if (a === out) {
                out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
                out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
                out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
                out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
            } else {
                a00 = a[0];
                a01 = a[1];
                a02 = a[2];
                a03 = a[3];
                a10 = a[4];
                a11 = a[5];
                a12 = a[6];
                a13 = a[7];
                a20 = a[8];
                a21 = a[9];
                a22 = a[10];
                a23 = a[11];
                out[0] = a00;
                out[1] = a01;
                out[2] = a02;
                out[3] = a03;
                out[4] = a10;
                out[5] = a11;
                out[6] = a12;
                out[7] = a13;
                out[8] = a20;
                out[9] = a21;
                out[10] = a22;
                out[11] = a23;
                out[12] = a00 * x + a10 * y + a20 * z + a[12];
                out[13] = a01 * x + a11 * y + a21 * z + a[13];
                out[14] = a02 * x + a12 * y + a22 * z + a[14];
                out[15] = a03 * x + a13 * y + a23 * z + a[15];
            }
            return out;
        };
        mat4.scale = function(out, a, v) {
            var x = v[0], y = v[1], z = v[2];
            out[0] = a[0] * x;
            out[1] = a[1] * x;
            out[2] = a[2] * x;
            out[3] = a[3] * x;
            out[4] = a[4] * y;
            out[5] = a[5] * y;
            out[6] = a[6] * y;
            out[7] = a[7] * y;
            out[8] = a[8] * z;
            out[9] = a[9] * z;
            out[10] = a[10] * z;
            out[11] = a[11] * z;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
            return out;
        };
        mat4.rotate = function(out, a, rad, axis) {
            var x = axis[0], y = axis[1], z = axis[2], len = Math.sqrt(x * x + y * y + z * z), s, c, t, a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23, b00, b01, b02, b10, b11, b12, b20, b21, b22;
            if (Math.abs(len) < GLMAT_EPSILON) {
                return null;
            }
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
            s = Math.sin(rad);
            c = Math.cos(rad);
            t = 1 - c;
            a00 = a[0];
            a01 = a[1];
            a02 = a[2];
            a03 = a[3];
            a10 = a[4];
            a11 = a[5];
            a12 = a[6];
            a13 = a[7];
            a20 = a[8];
            a21 = a[9];
            a22 = a[10];
            a23 = a[11];
            b00 = x * x * t + c;
            b01 = y * x * t + z * s;
            b02 = z * x * t - y * s;
            b10 = x * y * t - z * s;
            b11 = y * y * t + c;
            b12 = z * y * t + x * s;
            b20 = x * z * t + y * s;
            b21 = y * z * t - x * s;
            b22 = z * z * t + c;
            out[0] = a00 * b00 + a10 * b01 + a20 * b02;
            out[1] = a01 * b00 + a11 * b01 + a21 * b02;
            out[2] = a02 * b00 + a12 * b01 + a22 * b02;
            out[3] = a03 * b00 + a13 * b01 + a23 * b02;
            out[4] = a00 * b10 + a10 * b11 + a20 * b12;
            out[5] = a01 * b10 + a11 * b11 + a21 * b12;
            out[6] = a02 * b10 + a12 * b11 + a22 * b12;
            out[7] = a03 * b10 + a13 * b11 + a23 * b12;
            out[8] = a00 * b20 + a10 * b21 + a20 * b22;
            out[9] = a01 * b20 + a11 * b21 + a21 * b22;
            out[10] = a02 * b20 + a12 * b21 + a22 * b22;
            out[11] = a03 * b20 + a13 * b21 + a23 * b22;
            if (a !== out) {
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            return out;
        };
        mat4.rotateX = function(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            if (a !== out) {
                out[0] = a[0];
                out[1] = a[1];
                out[2] = a[2];
                out[3] = a[3];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
            return out;
        };
        mat4.rotateY = function(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            if (a !== out) {
                out[4] = a[4];
                out[5] = a[5];
                out[6] = a[6];
                out[7] = a[7];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            return out;
        };
        mat4.rotateZ = function(out, a, rad) {
            var s = Math.sin(rad), c = Math.cos(rad), a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            if (a !== out) {
                out[8] = a[8];
                out[9] = a[9];
                out[10] = a[10];
                out[11] = a[11];
                out[12] = a[12];
                out[13] = a[13];
                out[14] = a[14];
                out[15] = a[15];
            }
            out[0] = a00 * c + a10 * s;
            out[1] = a01 * c + a11 * s;
            out[2] = a02 * c + a12 * s;
            out[3] = a03 * c + a13 * s;
            out[4] = a10 * c - a00 * s;
            out[5] = a11 * c - a01 * s;
            out[6] = a12 * c - a02 * s;
            out[7] = a13 * c - a03 * s;
            return out;
        };
        mat4.fromRotationTranslation = function(out, q, v) {
            var x = q[0], y = q[1], z = q[2], w = q[3], x2 = x + x, y2 = y + y, z2 = z + z, xx = x * x2, xy = x * y2, xz = x * z2, yy = y * y2, yz = y * z2, zz = z * z2, wx = w * x2, wy = w * y2, wz = w * z2;
            out[0] = 1 - (yy + zz);
            out[1] = xy + wz;
            out[2] = xz - wy;
            out[3] = 0;
            out[4] = xy - wz;
            out[5] = 1 - (xx + zz);
            out[6] = yz + wx;
            out[7] = 0;
            out[8] = xz + wy;
            out[9] = yz - wx;
            out[10] = 1 - (xx + yy);
            out[11] = 0;
            out[12] = v[0];
            out[13] = v[1];
            out[14] = v[2];
            out[15] = 1;
            return out;
        };
        mat4.frustum = function(out, left, right, bottom, top, near, far) {
            var rl = 1 / (right - left), tb = 1 / (top - bottom), nf = 1 / (near - far);
            out[0] = near * 2 * rl;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = near * 2 * tb;
            out[6] = 0;
            out[7] = 0;
            out[8] = (right + left) * rl;
            out[9] = (top + bottom) * tb;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = far * near * 2 * nf;
            out[15] = 0;
            return out;
        };
        mat4.perspective = function(out, fovy, aspect, near, far) {
            var f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = 2 * far * near * nf;
            out[15] = 0;
            return out;
        };
        mat4.ortho = function(out, left, right, bottom, top, near, far) {
            var lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
            out[0] = -2 * lr;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = -2 * bt;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = 2 * nf;
            out[11] = 0;
            out[12] = (left + right) * lr;
            out[13] = (top + bottom) * bt;
            out[14] = (far + near) * nf;
            out[15] = 1;
            return out;
        };
        mat4.lookAt = function(out, eye, center, up) {
            var x0, x1, x2, y0, y1, y2, z0, z1, z2, len, eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center[0], centery = center[1], centerz = center[2];
            if (Math.abs(eyex - centerx) < GLMAT_EPSILON && Math.abs(eyey - centery) < GLMAT_EPSILON && Math.abs(eyez - centerz) < GLMAT_EPSILON) {
                return mat4.identity(out);
            }
            z0 = eyex - centerx;
            z1 = eyey - centery;
            z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;
            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }
            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }
            out[0] = x0;
            out[1] = y0;
            out[2] = z0;
            out[3] = 0;
            out[4] = x1;
            out[5] = y1;
            out[6] = z1;
            out[7] = 0;
            out[8] = x2;
            out[9] = y2;
            out[10] = z2;
            out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
            return out;
        };
        mat4.str = function(a) {
            return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.mat4 = mat4;
        }
        var quat = {};
        var quatIdentity = new Float32Array([ 0, 0, 0, 1 ]);
        if (!GLMAT_EPSILON) {
            var GLMAT_EPSILON = 1e-6;
        }
        quat.create = function() {
            return new Float32Array(quatIdentity);
        };
        quat.clone = vec4.clone;
        quat.fromValues = vec4.fromValues;
        quat.copy = vec4.copy;
        quat.set = vec4.set;
        quat.identity = function(out) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        };
        quat.setAxisAngle = function(out, axis, rad) {
            rad = rad * .5;
            var s = Math.sin(rad);
            out[0] = s * axis[0];
            out[1] = s * axis[1];
            out[2] = s * axis[2];
            out[3] = Math.cos(rad);
            return out;
        };
        quat.add = vec4.add;
        quat.mul = quat.multiply = function(out, a, b) {
            var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = b[3];
            out[0] = ax * bw + aw * bx + ay * bz - az * by;
            out[1] = ay * bw + aw * by + az * bx - ax * bz;
            out[2] = az * bw + aw * bz + ax * by - ay * bx;
            out[3] = aw * bw - ax * bx - ay * by - az * bz;
            return out;
        };
        quat.scale = vec4.scale;
        quat.rotateX = function(out, a, rad) {
            rad *= .5;
            var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = Math.sin(rad), bw = Math.cos(rad);
            out[0] = ax * bw + aw * bx;
            out[1] = ay * bw + az * bx;
            out[2] = az * bw - ay * bx;
            out[3] = aw * bw - ax * bx;
            return out;
        };
        quat.rotateY = function(out, a, rad) {
            rad *= .5;
            var ax = a[0], ay = a[1], az = a[2], aw = a[3], by = Math.sin(rad), bw = Math.cos(rad);
            out[0] = ax * bw - az * by;
            out[1] = ay * bw + aw * by;
            out[2] = az * bw + ax * by;
            out[3] = aw * bw - ay * by;
            return out;
        };
        quat.rotateZ = function(out, a, rad) {
            rad *= .5;
            var ax = a[0], ay = a[1], az = a[2], aw = a[3], bz = Math.sin(rad), bw = Math.cos(rad);
            out[0] = ax * bw + ay * bz;
            out[1] = ay * bw - ax * bz;
            out[2] = az * bw + aw * bz;
            out[3] = aw * bw - az * bz;
            return out;
        };
        quat.calculateW = function(out, a) {
            var x = a[0], y = a[1], z = a[2];
            out[0] = x;
            out[1] = y;
            out[2] = z;
            out[3] = -Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
            return out;
        };
        quat.dot = vec4.dot;
        quat.lerp = vec4.lerp;
        quat.slerp = function(out, a, b, t) {
            var ax = a[0], ay = a[1], az = a[2], aw = a[3], bx = b[0], by = b[1], bz = b[2], bw = a[3];
            var cosHalfTheta = ax * bx + ay * by + az * bz + aw * bw, halfTheta, sinHalfTheta, ratioA, ratioB;
            if (Math.abs(cosHalfTheta) >= 1) {
                if (out !== a) {
                    out[0] = ax;
                    out[1] = ay;
                    out[2] = az;
                    out[3] = aw;
                }
                return out;
            }
            halfTheta = Math.acos(cosHalfTheta);
            sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            if (Math.abs(sinHalfTheta) < .001) {
                out[0] = ax * .5 + bx * .5;
                out[1] = ay * .5 + by * .5;
                out[2] = az * .5 + bz * .5;
                out[3] = aw * .5 + bw * .5;
                return out;
            }
            ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            out[0] = ax * ratioA + bx * ratioB;
            out[1] = ay * ratioA + by * ratioB;
            out[2] = az * ratioA + bz * ratioB;
            out[3] = aw * ratioA + bw * ratioB;
            return out;
        };
        quat.invert = function(out, a) {
            var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3, invDot = dot ? 1 / dot : 0;
            out[0] = -a0 * invDot;
            out[1] = -a1 * invDot;
            out[2] = -a2 * invDot;
            out[3] = a3 * invDot;
            return out;
        };
        quat.conjugate = function(out, a) {
            out[0] = -a[0];
            out[1] = -a[1];
            out[2] = -a[2];
            out[3] = a[3];
            return out;
        };
        quat.len = quat.length = vec4.length;
        quat.sqrLen = quat.squaredLength = vec4.squaredLength;
        quat.normalize = vec4.normalize;
        quat.str = function(a) {
            return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
        };
        if (typeof exports !== "undefined") {
            exports.quat = quat;
        }
    })(shim.exports);
})();

var EPSILON = 1e-6;

mat3.normalize = function(out, m) {
    var v;
    v = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    out[0] = m[0] / v;
    out[1] = m[1] / v;
    out[2] = m[2] / v;
    v = Math.sqrt(m[3] * m[3] + m[4] * m[4] + m[5] * m[5]);
    out[3] = m[3] / v;
    out[4] = m[4] / v;
    out[5] = m[5] / v;
    v = Math.sqrt(m[6] * m[6] + m[7] * m[7] + m[8] * m[8]);
    out[6] = m[6] / v;
    out[7] = m[7] / v;
    out[8] = m[8] / v;
    return out;
};

mat4.submat3 = function(out, m, pos) {
    out[0] = m[0 + pos[0] + pos[1] * 4];
    out[1] = m[1 + pos[0] + pos[1] * 4];
    out[2] = m[2 + pos[0] + pos[1] * 4];
    out[3] = m[4 + pos[0] + pos[1] * 4];
    out[4] = m[5 + pos[0] + pos[1] * 4];
    out[5] = m[6 + pos[0] + pos[1] * 4];
    out[6] = m[8 + pos[0] + pos[1] * 4];
    out[7] = m[9 + pos[0] + pos[1] * 4];
    out[8] = m[10 + pos[0] + pos[1] * 4];
    return out;
};

mat4.setsubmat3 = function(out, m, pos) {
    out[0 + pos[0] + pos[1] * 4] = m[0];
    out[1 + pos[0] + pos[1] * 4] = m[1];
    out[2 + pos[0] + pos[1] * 4] = m[2];
    out[4 + pos[0] + pos[1] * 4] = m[3];
    out[5 + pos[0] + pos[1] * 4] = m[4];
    out[6 + pos[0] + pos[1] * 4] = m[5];
    out[8 + pos[0] + pos[1] * 4] = m[6];
    out[9 + pos[0] + pos[1] * 4] = m[7];
    out[10 + pos[0] + pos[1] * 4] = m[8];
    return out;
};

mat4.rotation = function(out, m) {
    out[0] = m[0];
    out[1] = m[1];
    out[2] = m[2];
    out[3] = 0;
    out[4] = m[4];
    out[5] = m[5];
    out[6] = m[6];
    out[7] = 0;
    out[8] = m[8];
    out[9] = m[9];
    out[10] = m[10];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

mat4.translation = function(out, m) {
    out[0] = m[12];
    out[1] = m[13];
    out[2] = m[14];
    return out;
};

mat4.getScale = function(out, m) {
    out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2] + m[3] * m[3]);
    out[1] = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6] + m[7] * m[7]);
    out[2] = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10] + m[11] * m[11]);
    return out;
};

mat4.normalize = function(out, m) {
    var v;
    v = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2] + m[3] * m[3]);
    out[0] = m[0] / v;
    out[1] = m[1] / v;
    out[2] = m[2] / v;
    out[3] = m[3] / v;
    v = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6] + m[7] * m[7]);
    out[4] = m[4] / v;
    out[5] = m[5] / v;
    out[6] = m[6] / v;
    out[7] = m[7] / v;
    v = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10] + m[11] * m[11]);
    out[8] = m[8] / v;
    out[9] = m[9] / v;
    out[10] = m[10] / v;
    out[11] = m[11] / v;
    v = Math.sqrt(m[12] * m[12] + m[13] * m[13] + m[14] * m[14] + m[15] * m[15]);
    out[12] = m[12] / v;
    out[13] = m[13] / v;
    out[14] = m[14] / v;
    out[15] = m[15] / v;
    return out;
};

mat4.fromRotationTranslationScale = function(out, r, t, s) {
    mat4.fromRotationTranslation(out, r, t);
    mat4.scale(out, out, s);
    return out;
};

mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
};

mat4.decompose = function(outTranslation, outRotation, outScale, m) {
    mat4.translation(outTranslation, m);
    quat.fromMat4(outRotation, m);
    mat4.getScale(outScale, m);
};

mat4.isIdentity = function(m) {
    if (Math.abs(m[0] - 1) > EPSILON) return false;
    if (Math.abs(m[5] - 1) > EPSILON) return false;
    if (Math.abs(m[10] - 1) > EPSILON) return false;
    if (Math.abs(m[15] - 1) > EPSILON) return false;
    if (Math.abs(m[1]) > EPSILON) return false;
    if (Math.abs(m[2]) > EPSILON) return false;
    if (Math.abs(m[3]) > EPSILON) return false;
    if (Math.abs(m[4]) > EPSILON) return false;
    if (Math.abs(m[6]) > EPSILON) return false;
    if (Math.abs(m[7]) > EPSILON) return false;
    if (Math.abs(m[8]) > EPSILON) return false;
    if (Math.abs(m[9]) > EPSILON) return false;
    if (Math.abs(m[11]) > EPSILON) return false;
    if (Math.abs(m[12]) > EPSILON) return false;
    if (Math.abs(m[13]) > EPSILON) return false;
    if (Math.abs(m[14]) > EPSILON) return false;
    return true;
};

quat.euler = function(out, pitch, yaw, roll) {
    var Deg2Rad = Math.PI * 2 / 360;
    var q = quat.create();
    var dir = vec3.fromValues(0, 0, 1);
    quat.setAxisAngle(out, dir, Deg2Rad * roll);
    vec3.set(dir, 0, 1, 0);
    quat.setAxisAngle(q, dir, Deg2Rad * yaw);
    quat.mul(out, out, q);
    vec3.set(dir, 1, 0, 0);
    quat.setAxisAngle(q, dir, Deg2Rad * pitch);
    quat.mul(out, out, q);
    return out;
};

quat.getEuler = function(out, q) {
    var Rad2Deg = 360 / (Math.PI * 2);
    var m = mat4.fromRotationTranslation(mat4.create(), q, [ 0, 0, 0 ]);
    var cmp = function(a, b) {
        return Math.abs(a - b) <= EPSILON;
    };
    var crossPositive = function(q1, eulerAngles) {
        var q2 = quat.euler(quat.create(), eulerAngles[0], eulerAngles[1], eulerAngles[2]);
        quat.normalize(q2, q2);
        var diff = quat.rotationDifference(quat.create(), q1, q2);
        return Math.abs(1 - diff[3]) < EPSILON;
    };
    if (!cmp(Math.abs(m[2]), 1)) {
        var solution = function(theta) {
            var cosTheta = Math.cos(theta);
            out[0] = Math.atan2(m[6] / cosTheta, m[10] / cosTheta) * Rad2Deg;
            out[1] = theta * Rad2Deg;
            out[2] = Math.atan2(m[1] / cosTheta, m[0] / cosTheta) * Rad2Deg;
        };
        var theta = -Math.asin(m[2]);
        solution(theta);
        if (!crossPositive(q, out)) {
            theta = Math.PI - theta;
            solution(theta);
        }
    } else {
        if (cmp(m[2], -1)) {
            out[0] = 0;
            out[1] = 90;
            out[2] = -Rad2Deg * Math.atan2(m[4], m[8]);
        } else {
            out[0] = 0;
            out[1] = -90;
            out[2] = Rad2Deg * Math.atan2(-m[4], -m[8]);
        }
    }
    return out;
};

quat.fromMat3 = function(out, m) {
    var tr = m[0] + m[4] + m[8];
    if (tr > EPSILON) {
        var s = Math.sqrt(1 + tr) * 2;
        out[3] = .25 * s;
        out[0] = (m[5] - m[7]) / s;
        out[1] = (m[6] - m[2]) / s;
        out[2] = (m[1] - m[3]) / s;
    } else if (m[0] > m[4] && m[0] > m[8]) {
        var s = Math.sqrt(1 + m[0] - m[4] - m[8]) * 2;
        out[3] = (m[5] - m[7]) / s;
        out[0] = .25 * s;
        out[1] = (m[1] + m[3]) / s;
        out[2] = (m[6] + m[2]) / s;
    } else if (m[4] > m[8]) {
        var s = Math.sqrt(1 + m[4] - m[0] - m[8]) * 2;
        out[3] = (m[6] - m[2]) / s;
        out[0] = (m[1] + m[3]) / s;
        out[1] = .25 * s;
        out[2] = (m[5] + m[7]) / s;
    } else {
        var s = Math.sqrt(1 + m[8] - m[0] - m[4]) * 2;
        out[3] = (m[1] - m[3]) / s;
        out[0] = (m[6] + m[2]) / s;
        out[1] = (m[5] + m[7]) / s;
        out[2] = .25 * s;
    }
    return out;
};

quat.fromMat4 = function(out, m) {
    var rot = mat4.submat3(mat3.create(), m, [ 0, 0 ]);
    mat3.normalize(rot, rot);
    quat.fromMat3(out, rot);
    quat.normalize(out, out);
    return out;
};

quat.rotationDifference = function(out, q1, q2) {
    quat.multiply(out, q2, quat.conjugate(quat.create(), q1));
    return out;
};

quat.angle = function(q1, q2) {
    var cosTheta = q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2] + q1[3] * q2[3];
    if (Math.abs(1 - cosTheta) < EPSILON) cosTheta = 1;
    if (Math.abs(1 + cosTheta) < EPSILON) cosTheta = -1;
    return Math.acos(cosTheta) * 2;
};

quat.slerp = function(out, q1, q2, t) {
    var cos = q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2] + q1[3] * q2[3];
    if (Math.abs(1 - cos) < EPSILON) cos = 1;
    if (Math.abs(1 + cos) < EPSILON) cos = -1;
    var scale1, scale2;
    if (1 - Math.abs(cos) > EPSILON) {
        var halfAngle = Math.acos(Math.abs(cos));
        var sin = Math.sin(halfAngle);
        scale1 = Math.sin((1 - t) * halfAngle / sin);
        scale2 = Math.sin(t * halfAngle / sin);
    } else {
        scale1 = 1 - t;
        scale2 = t;
    }
    if (cos < 0) scale2 = -scale2;
    var q1scaled = quat.scale(quat.create(), q1, scale1);
    var q2scaled = quat.scale(quat.create(), q2, scale2);
    quat.add(out, q1scaled, q2scaled);
    return out;
};

quat.getTwist = function(q, axis) {
    var orthoNormal = vec3.create();
    var w = vec3.transformQuat(vec3.create(), axis, quat.euler(quat.create(), 90, 0, 0));
    var dot = vec3.dot(axis, w);
    if (Math.abs(dot) > .6) w = vec3.transformQuat(axis, quat.euler(quat.create(), 0, 90, 0));
    vec3.normalize(w, w);
    vec3.cross(orthoNormal, axis, w);
    vec3.normalize(orthoNormal, orthoNormal);
    var t = vec3.transformQuat(vec3.create(), orthoNormal, q);
    var projected = vec3.sub(vec3.create(), t, vec3.scale(vec3.create(), axis, vec3.dot(t, axis)));
    vec3.normalize(projected, projected);
    return Math.acos(vec3.dot(orthoNormal, projected));
};

vec3.transformVertexArrayMat4 = function(inoutArray, m, offset) {
    var x = 0, y = 0, z = 0;
    for (var i = offset; i < inoutArray.length; i += 3) {
        x = inoutArray[i];
        y = inoutArray[i + 1];
        z = inoutArray[i + 2];
        inoutArray[i] = m[0] * x + m[4] * y + m[8] * z + m[12];
        inoutArray[i + 1] = m[1] * x + m[5] * y + m[9] * z + m[13];
        inoutArray[i + 2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    }
    return inoutArray;
};

vec3.transformVertexArrayQuat = function(inoutArray, q, offset) {
    var x = 0, y = 0, z = 0, qx = q[0], qy = q[1], qz = q[2], qw = q[3], ix = 0, iy = 0, iz = 0, iw = 0;
    for (var i = offset; i < inoutArray.length; i += 3) {
        x = inoutArray[i];
        y = inoutArray[i + 1];
        z = inoutArray[i + 2];
        ix = qw * x + qy * z - qz * y;
        iy = qw * y + qz * x - qx * z;
        iz = qw * z + qx * y - qy * x;
        iw = -qx * x - qy * y - qz * z;
        inoutArray[i] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        inoutArray[i + 1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        inoutArray[i + 2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    }
    return inoutArray;
};

function lerp(v0, v1, t) {
    return v0 + (v1 - v0) * t;
}

function clampAngle(angle, min, max) {
    if (angle < -2 * Math.PI) angle += 2 * Math.PI;
    if (angle > 2 * Math.PI) angle -= 2 * Math.PI;
    angle = Math.max(min, angle);
    angle = Math.min(max, angle);
    return angle;
}

(function(global) {
    var compatibility = {
        ArrayBuffer: typeof ArrayBuffer !== "undefined",
        DataView: typeof DataView !== "undefined" && ("getFloat64" in DataView.prototype || "getFloat64" in new DataView(new ArrayBuffer(1))),
        NodeBuffer: typeof Buffer !== "undefined" && "readInt16LE" in Buffer.prototype
    };
    var dataTypes = {
        Int8: 1,
        Int16: 2,
        Int32: 4,
        Uint8: 1,
        Uint16: 2,
        Uint32: 4,
        Float32: 4,
        Float64: 8
    };
    var nodeNaming = {
        Int8: "Int8",
        Int16: "Int16",
        Int32: "Int32",
        Uint8: "UInt8",
        Uint16: "UInt16",
        Uint32: "UInt32",
        Float32: "Float",
        Float64: "Double"
    };
    var jDataView = function(buffer, byteOffset, byteLength, littleEndian) {
        if (!(this instanceof jDataView)) {
            throw new Error("jDataView constructor may not be called as a function");
        }
        this.buffer = buffer;
        if (!(compatibility.NodeBuffer && buffer instanceof Buffer) && !(compatibility.ArrayBuffer && buffer instanceof ArrayBuffer) && typeof buffer !== "string") {
            throw new TypeError("jDataView buffer has an incompatible type");
        }
        this._isArrayBuffer = compatibility.ArrayBuffer && buffer instanceof ArrayBuffer;
        this._isDataView = compatibility.DataView && this._isArrayBuffer;
        this._isNodeBuffer = compatibility.NodeBuffer && buffer instanceof Buffer;
        this._littleEndian = littleEndian === undefined ? false : littleEndian;
        var bufferLength = this._isArrayBuffer ? buffer.byteLength : buffer.length;
        if (byteOffset === undefined) {
            byteOffset = 0;
        }
        this.byteOffset = byteOffset;
        if (byteLength === undefined) {
            byteLength = bufferLength - byteOffset;
        }
        this.byteLength = byteLength;
        if (!this._isDataView) {
            if (typeof byteOffset !== "number") {
                throw new TypeError("jDataView byteOffset is not a number");
            }
            if (typeof byteLength !== "number") {
                throw new TypeError("jDataView byteLength is not a number");
            }
            if (byteOffset < 0) {
                throw new Error("jDataView byteOffset is negative");
            }
            if (byteLength < 0) {
                throw new Error("jDataView byteLength is negative");
            }
        }
        if (this._isDataView) {
            this._view = new DataView(buffer, byteOffset, byteLength);
            this._start = 0;
        }
        this._start = byteOffset;
        if (byteOffset + byteLength > bufferLength) {
            throw new Error("jDataView (byteOffset + byteLength) value is out of bounds");
        }
        this._offset = 0;
        if (this._isDataView) {
            for (var type in dataTypes) {
                if (!dataTypes.hasOwnProperty(type)) {
                    continue;
                }
                (function(type, view) {
                    var size = dataTypes[type];
                    view["get" + type] = function(byteOffset, littleEndian) {
                        if (littleEndian === undefined) {
                            littleEndian = view._littleEndian;
                        }
                        if (byteOffset === undefined) {
                            byteOffset = view._offset;
                        }
                        view._offset = byteOffset + size;
                        return view._view["get" + type](byteOffset, littleEndian);
                    };
                })(type, this);
            }
        } else if (this._isNodeBuffer && compatibility.NodeBuffer) {
            for (var type in dataTypes) {
                if (!dataTypes.hasOwnProperty(type)) {
                    continue;
                }
                var name;
                if (type === "Int8" || type === "Uint8") {
                    name = "read" + nodeNaming[type];
                } else if (littleEndian) {
                    name = "read" + nodeNaming[type] + "LE";
                } else {
                    name = "read" + nodeNaming[type] + "BE";
                }
                (function(type, view, name) {
                    var size = dataTypes[type];
                    view["get" + type] = function(byteOffset, littleEndian) {
                        if (littleEndian === undefined) {
                            littleEndian = view._littleEndian;
                        }
                        if (byteOffset === undefined) {
                            byteOffset = view._offset;
                        }
                        view._offset = byteOffset + size;
                        return view.buffer[name](view._start + byteOffset);
                    };
                })(type, this, name);
            }
        } else {
            for (var type in dataTypes) {
                if (!dataTypes.hasOwnProperty(type)) {
                    continue;
                }
                (function(type, view) {
                    var size = dataTypes[type];
                    view["get" + type] = function(byteOffset, littleEndian) {
                        if (littleEndian === undefined) {
                            littleEndian = view._littleEndian;
                        }
                        if (byteOffset === undefined) {
                            byteOffset = view._offset;
                        }
                        view._offset = byteOffset + size;
                        if (view._isArrayBuffer && (view._start + byteOffset) % size === 0 && (size === 1 || littleEndian)) {
                            return new global[type + "Array"](view.buffer, view._start + byteOffset, 1)[0];
                        } else {
                            if (typeof byteOffset !== "number") {
                                throw new TypeError("jDataView byteOffset is not a number");
                            }
                            if (byteOffset + size > view.byteLength) {
                                throw new Error("jDataView (byteOffset + size) value is out of bounds");
                            }
                            return view["_get" + type](view._start + byteOffset, littleEndian);
                        }
                    };
                })(type, this);
            }
        }
    };
    if (compatibility.NodeBuffer) {
        jDataView.createBuffer = function() {
            var buffer = new Buffer(arguments.length);
            for (var i = 0; i < arguments.length; ++i) {
                buffer[i] = arguments[i];
            }
            return buffer;
        };
    } else if (compatibility.ArrayBuffer) {
        jDataView.createBuffer = function() {
            var buffer = new ArrayBuffer(arguments.length);
            var view = new Int8Array(buffer);
            for (var i = 0; i < arguments.length; ++i) {
                view[i] = arguments[i];
            }
            return buffer;
        };
    } else {
        jDataView.createBuffer = function() {
            return String.fromCharCode.apply(null, arguments);
        };
    }
    jDataView.prototype = {
        compatibility: compatibility,
        getString: function(length, byteOffset) {
            var value;
            if (byteOffset === undefined) {
                byteOffset = this._offset;
            }
            if (typeof byteOffset !== "number") {
                throw new TypeError("jDataView byteOffset is not a number");
            }
            if (length < 0 || byteOffset + length > this.byteLength) {
                throw new Error("jDataView length or (byteOffset+length) value is out of bounds");
            }
            if (this._isNodeBuffer) {
                value = this.buffer.toString("ascii", this._start + byteOffset, this._start + byteOffset + length);
            } else {
                value = "";
                for (var i = 0; i < length; ++i) {
                    var char = this.getUint8(byteOffset + i);
                    value += String.fromCharCode(char > 127 ? 65533 : char);
                }
            }
            this._offset = byteOffset + length;
            return value;
        },
        getChar: function(byteOffset) {
            return this.getString(1, byteOffset);
        },
        tell: function() {
            return this._offset;
        },
        seek: function(byteOffset) {
            if (typeof byteOffset !== "number") {
                throw new TypeError("jDataView byteOffset is not a number");
            }
            if (byteOffset < 0 || byteOffset > this.byteLength) {
                throw new Error("jDataView byteOffset value is out of bounds");
            }
            return this._offset = byteOffset;
        },
        _endianness: function(byteOffset, pos, max, littleEndian) {
            return byteOffset + (littleEndian ? max - pos - 1 : pos);
        },
        _getFloat64: function(byteOffset, littleEndian) {
            var b0 = this._getUint8(this._endianness(byteOffset, 0, 8, littleEndian)), b1 = this._getUint8(this._endianness(byteOffset, 1, 8, littleEndian)), b2 = this._getUint8(this._endianness(byteOffset, 2, 8, littleEndian)), b3 = this._getUint8(this._endianness(byteOffset, 3, 8, littleEndian)), b4 = this._getUint8(this._endianness(byteOffset, 4, 8, littleEndian)), b5 = this._getUint8(this._endianness(byteOffset, 5, 8, littleEndian)), b6 = this._getUint8(this._endianness(byteOffset, 6, 8, littleEndian)), b7 = this._getUint8(this._endianness(byteOffset, 7, 8, littleEndian)), sign = 1 - 2 * (b0 >> 7), exponent = ((b0 << 1 & 255) << 3 | b1 >> 4) - (Math.pow(2, 10) - 1), mantissa = (b1 & 15) * Math.pow(2, 48) + b2 * Math.pow(2, 40) + b3 * Math.pow(2, 32) + b4 * Math.pow(2, 24) + b5 * Math.pow(2, 16) + b6 * Math.pow(2, 8) + b7;
            if (exponent === 1024) {
                if (mantissa !== 0) {
                    return NaN;
                } else {
                    return sign * Infinity;
                }
            }
            if (exponent === -1023) {
                return sign * mantissa * Math.pow(2, -1022 - 52);
            }
            return sign * (1 + mantissa * Math.pow(2, -52)) * Math.pow(2, exponent);
        },
        _getFloat32: function(byteOffset, littleEndian) {
            var b0 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)), b1 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)), b2 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)), b3 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian)), sign = 1 - 2 * (b0 >> 7), exponent = (b0 << 1 & 255 | b1 >> 7) - 127, mantissa = (b1 & 127) << 16 | b2 << 8 | b3;
            if (exponent === 128) {
                if (mantissa !== 0) {
                    return NaN;
                } else {
                    return sign * Infinity;
                }
            }
            if (exponent === -127) {
                return sign * mantissa * Math.pow(2, -126 - 23);
            }
            return sign * (1 + mantissa * Math.pow(2, -23)) * Math.pow(2, exponent);
        },
        _getInt32: function(byteOffset, littleEndian) {
            var b = this._getUint32(byteOffset, littleEndian);
            return b > Math.pow(2, 31) - 1 ? b - Math.pow(2, 32) : b;
        },
        _getUint32: function(byteOffset, littleEndian) {
            var b3 = this._getUint8(this._endianness(byteOffset, 0, 4, littleEndian)), b2 = this._getUint8(this._endianness(byteOffset, 1, 4, littleEndian)), b1 = this._getUint8(this._endianness(byteOffset, 2, 4, littleEndian)), b0 = this._getUint8(this._endianness(byteOffset, 3, 4, littleEndian));
            return b3 * Math.pow(2, 24) + (b2 << 16) + (b1 << 8) + b0;
        },
        _getInt16: function(byteOffset, littleEndian) {
            var b = this._getUint16(byteOffset, littleEndian);
            return b > Math.pow(2, 15) - 1 ? b - Math.pow(2, 16) : b;
        },
        _getUint16: function(byteOffset, littleEndian) {
            var b1 = this._getUint8(this._endianness(byteOffset, 0, 2, littleEndian)), b0 = this._getUint8(this._endianness(byteOffset, 1, 2, littleEndian));
            return (b1 << 8) + b0;
        },
        _getInt8: function(byteOffset) {
            var b = this._getUint8(byteOffset);
            return b > Math.pow(2, 7) - 1 ? b - Math.pow(2, 8) : b;
        },
        _getUint8: function(byteOffset) {
            if (this._isArrayBuffer) {
                return new Uint8Array(this.buffer, byteOffset, 1)[0];
            } else if (this._isNodeBuffer) {
                return this.buffer[byteOffset];
            } else {
                return this.buffer.charCodeAt(byteOffset) & 255;
            }
        }
    };
    if (typeof jQuery !== "undefined" && jQuery.fn.jquery >= "1.6.2") {
        var convertResponseBodyToText = function(byteArray) {
            var scrambledStr;
            try {
                scrambledStr = IEBinaryToArray_ByteStr(byteArray);
            } catch (e) {
                var IEBinaryToArray_ByteStr_Script = "Function IEBinaryToArray_ByteStr(Binary)\r\n" + "	IEBinaryToArray_ByteStr = CStr(Binary)\r\n" + "End Function\r\n" + "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n" + "	Dim lastIndex\r\n" + "	lastIndex = LenB(Binary)\r\n" + "	if lastIndex mod 2 Then\r\n" + "		IEBinaryToArray_ByteStr_Last = AscB( MidB( Binary, lastIndex, 1 ) )\r\n" + "	Else\r\n" + "		IEBinaryToArray_ByteStr_Last = -1\r\n" + "	End If\r\n" + "End Function\r\n";
                window.execScript(IEBinaryToArray_ByteStr_Script, "vbscript");
                scrambledStr = IEBinaryToArray_ByteStr(byteArray);
            }
            var lastChr = IEBinaryToArray_ByteStr_Last(byteArray), result = "", i = 0, l = scrambledStr.length % 8, thischar;
            while (i < l) {
                thischar = scrambledStr.charCodeAt(i++);
                result += String.fromCharCode(thischar & 255, thischar >> 8);
            }
            l = scrambledStr.length;
            while (i < l) {
                result += String.fromCharCode((thischar = scrambledStr.charCodeAt(i++), thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), 
                thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), 
                thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), 
                thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), thischar & 255), thischar >> 8, (thischar = scrambledStr.charCodeAt(i++), 
                thischar & 255), thischar >> 8);
            }
            if (lastChr > -1) {
                result += String.fromCharCode(lastChr);
            }
            return result;
        };
        jQuery.ajaxSetup({
            converters: {
                "* dataview": function(data) {
                    return new jDataView(data);
                }
            },
            accepts: {
                dataview: "text/plain; charset=x-user-defined"
            },
            responseHandler: {
                dataview: function(responses, options, xhr) {
                    if ("mozResponseArrayBuffer" in xhr) {
                        responses.text = xhr.mozResponseArrayBuffer;
                    } else if ("responseType" in xhr && xhr.responseType === "arraybuffer" && xhr.response) {
                        responses.text = xhr.response;
                    } else if ("responseBody" in xhr) {
                        responses.text = convertResponseBodyToText(xhr.responseBody);
                    } else {
                        responses.text = xhr.responseText;
                    }
                }
            }
        });
        jQuery.ajaxPrefilter("dataview", function(options, originalOptions, jqXHR) {
            if (jQuery.support.ajaxResponseType) {
                if (!options.hasOwnProperty("xhrFields")) {
                    options.xhrFields = {};
                }
                options.xhrFields.responseType = "arraybuffer";
            }
            options.mimeType = "text/plain; charset=x-user-defined";
        });
    }
    global.jDataView = (global.module || {}).exports = jDataView;
    if (typeof module !== "undefined") {
        module.exports = jDataView;
    }
})(this);

(function() {
    var initializing = false, fnTest = /xyz/.test(function() {
        xyz;
    }) ? /\b_super\b/ : /.*/;
    this.Class = function() {};
    Class.extend = function(prop) {
        var _super = this.prototype;
        initializing = true;
        var prototype = new this();
        initializing = false;
        for (var name in prop) {
            prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? function(name, fn) {
                return function() {
                    var tmp = this._super;
                    this._super = _super[name];
                    var ret = fn.apply(this, arguments);
                    this._super = tmp;
                    return ret;
                };
            }(name, prop[name]) : prop[name];
        }
        function Class() {
            if (!initializing && this.init) this.init.apply(this, arguments);
        }
        Class.prototype = prototype;
        Class.prototype.constructor = Class;
        Class.extend = arguments.callee;
        return Class;
    };
})();

function ClassCallback(classScope, fnCallback) {
    return function() {
        return fnCallback.apply(classScope, arguments);
    };
}

var Logistics = function() {
    var storageSupport = false;
    if (typeof window !== "undefined") {
        storageSupport = "localStorage" in window && window["localStorage"] !== null;
    }
    var queue = [];
    var multiQueue = [];
    var loadedCount = 0;
    var loading = false;
    var afterLoadCallback = null;
    var progressCallback = null;
    var options = {
        loadFromLocalStorage: true,
        storeToLocalStorage: true,
        loadFromFile: false,
        enableCORS: true,
        useCookies: true
    };
    var me = this;
    var typefunctions = {
        text: {
            load: function(dt) {
                makeHTTPRequest(dt);
            },
            parse: function(dt, http) {
                dt.data = http.responseText;
            },
            store: function(dt) {
                return dt.data;
            },
            restore: function(dt, data) {
                return data;
            }
        },
        json: {
            load: function(dt) {
                makeHTTPRequest(dt);
            },
            parse: function(dt, http) {
                try {
                    dt.data = JSON.parse(http.responseText);
                } catch (e) {
                    if (typeof console !== "undefined" && console.log) {
                        console.log("JSON parsing failed for " + dt.url, e);
                    }
                }
            },
            store: function(dt) {
                return JSON.stringify(dt.data);
            },
            restore: function(dt, data) {
                if (data) {
                    return JSON.parse(data);
                } else {
                    return {};
                }
            }
        },
        xml: {
            load: function(dt) {
                makeHTTPRequest(dt);
            },
            parse: function(dt, http) {
                if (http.responseXML) {
                    dt.data = http.responseXML;
                } else {
                    dt.data = parseXML(http.responseText);
                }
            },
            store: function(dt) {
                if (XMLSerializer) {
                    return new XMLSerializer().serializeToString(dt.data);
                } else {
                    return "";
                }
            },
            restore: function(dt, data) {
                return parseXML(data);
            }
        },
        image: {
            load: function(dt) {
                if (dt) {
                    dt.data = new Image();
                    if (dt.useCORS) {
                        dt.data.crossOrigin = "Anonymous";
                    }
                    dt.data.onload = function() {
                        dt.ready();
                    };
                    dt.data.onerror = function() {
                        dt.failed();
                    };
                    dt.data.src = dt.url;
                }
            },
            parse: function(dt) {},
            store: function(dt) {
                var canvas = document.createElement("canvas");
                canvas.width = dt.data.width;
                canvas.height = dt.data.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(dt.data, 0, 0);
                var dataURL = canvas.toDataURL("image/png");
                canvas = null;
                return dataURL;
            },
            restore: function(dt, data) {
                var img = new Image();
                img.src = data;
                return img;
            }
        },
        binary: {
            load: function(dt) {
                makeHTTPRequest(dt);
            },
            parse: function(dt, http) {
                dt.data = http.response;
            },
            store: function(dt) {
                var str = "";
                var bytes = new Uint8Array(dt.data);
                var len = bytes.byteLength;
                for (var i = 0; i < len; i++) {
                    str += String.fromCharCode(bytes[i]);
                }
                return window.btoa(str);
            },
            restore: function(dt, data) {
                var buf = new ArrayBuffer(data.length * 2);
                var bufView = new Uint16Array(buf);
                for (var i = 0, strLen = data.length; i < strLen; i++) {
                    bufView[i] = data.charCodeAt(i);
                }
                return buf;
            }
        }
    };
    var DataTransporter = function(_url, _params, _success, _type, _requestType) {
        this.url = _url;
        this.params = _params;
        this.success = _success;
        this.dataType = _type;
        this.loaded = false;
        this.data = false;
        this.requestType = _requestType;
        this.useCORS = false;
        this.successCallback = _success;
        this.errorCallback = false;
        this.alwaysCallback = false;
        this.progressCallback = false;
        this.ready = function() {
            this.loaded = true;
            loadedCount++;
            callSuccess(this);
            callProgress();
        };
        this.failed = function() {
            loadedCount++;
            callProgress();
            callError(this);
        };
        this.done = function(callback) {
            this.successCallback = callback;
        };
        this.fail = function(callback) {
            this.errorCallback = callback;
        };
        this.error = function(callback) {
            this.errorCallback = callback;
        };
        this.always = function(callback) {
            this.alwaysCallback = callback;
        };
        this.progress = function(callback) {
            this.progressCallback = callback;
        };
        this.toString = function() {
            return this.data;
        };
    };
    var MultiTransporter = function(urlList, _success) {
        this.urls = urlList;
        this.results = {};
        this.loadedCount = 0;
        this.count = 0;
        this.successCallback = _success;
        this.load = function() {
            var dt = null;
            var url = null;
            for (var key in this.urls) {
                if (this.urls.hasOwnProperty(key)) {
                    this.count++;
                }
            }
            for (var i in this.urls) {
                url = this.urls[i];
                if (url && url.url && url.type) {
                    if (typeof url.params === "undefined") {
                        url.params = {};
                    }
                    url.params["logistics.multi.key"] = i;
                    dt = get(url.url, url.params, callback(this, this.ready, i), url.type);
                }
            }
        };
        this.ready = function(data, status, dt) {
            var key = dt.params["logistics.multi.key"];
            this.results[key] = data;
            this.loadedCount++;
            this.checkIfAllReady();
        };
        this.getKeyForURL = function(url) {};
        this.checkIfAllReady = function() {
            if (this.loadedCount >= this.count) {
                if (typeof this.successCallback === "function") {
                    this.successCallback(this.results);
                }
            }
        };
    };
    var get = function(_url, _params, _success, _type) {
        var _requestType = "GET";
        if (typeof _params === "function") {
            _success = _params;
            _params = undefined;
        } else if (_params && typeof _params === "object") {
            _requestType = "POST";
        }
        var dt = new DataTransporter(_url, _params, _success, _type, _requestType);
        if (options.enableCORS) {
            dt.useCORS = ifCORSNeeded(_url);
        }
        if (dt) {
            queue.push(dt);
            startLoad(dt);
        }
        return dt;
    };
    var getMultiple = function(urlList, success) {
        var mt = new MultiTransporter(urlList, success);
        multiQueue.push(mt);
        mt.load();
    };
    var ifCORSNeeded = function(_url) {
        if (typeof document === "undefined") return false;
        var url = _url.match(/(https?:)?\/\/([^\/]+)\/(.*)/);
        if (!url) return false;
        if (url[1] === document.location.origin) return false;
        return true;
    };
    var startLoad = function(dt) {
        load(dt);
        return true;
    };
    var load = function(dt) {
        if (inLocalStorage(dt)) {
            restore(dt);
        } else {
            getTypeFunction(dt.dataType, "load")(dt);
        }
    };
    var inLocalStorage = function(dt) {
        if (storageSupport && localStorage.getItem(dt.url) !== null) {
            return true;
        }
        return false;
    };
    var restore = function(dt) {
        dt.data = getTypeFunction(dt.dataType, "restore")(dt, loadFromLocalStorage(dt));
        dt.ready();
    };
    var getTypeFunction = function(type, method) {
        if (typefunctions && typefunctions[type] && typefunctions[type][method]) {
            return typefunctions[type][method];
        } else if (typefunctions && typefunctions[type]) {
            return typefunctions[type];
        }
        return function() {
            if (typeof console !== "undefined" && console.log) {
                console.log("Method " + method + " for " + type + " not found");
            }
        };
    };
    var setTypeFunction = function(type, method) {
        if (type && method) {
            typefunctions[type] = method;
        }
    };
    var makeHTTPRequest = function(dt) {
        var xhr = getHTTPObject(dt);
        if (xhr && dt) {
            var url = dt.url;
            xhr.open(dt.requestType, url, true);
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml");
            }
            if (dt.dataType == "binary") {
                xhr.responseType = "arraybuffer";
                if (dt.useCORS) {
                    xhr.setRequestHeader("Content-Type", "application/x-3dtechdata");
                }
            }
            if (dt.useCORS && options.useCookies) {
                xhr.withCredentials = true;
            }
            xhr.onreadystatechange = function() {
                if (xhr.readyState == 4) {
                    if (xhr.status == 200) {
                        dt.loaded = true;
                        loadedCount++;
                        getTypeFunction(dt.dataType, "parse")(dt, xhr);
                        callSuccess(dt);
                    } else {
                        loadedCount++;
                        callError(dt);
                    }
                } else {
                    if (typeof dt.progressCallback === "function") {
                        dt.progressCallback(xhr);
                    }
                }
            };
            xhr.ontimeout = function() {
                loadedCount++;
                callError(dt);
            };
            callProgress();
            xhr.send(null);
        } else {
            throw "http failed";
        }
    };
    var parseXML = function(data) {
        var xml = null;
        if (!data || typeof data !== "string") {
            return xml;
        }
        if (window.DOMParser) {
            var parser = new DOMParser();
            xml = parser.parseFromString(data, "text/xml");
        } else {
            xml = new ActiveXObject("Microsoft.XMLDOM");
            xml.async = false;
            xml.loadXML(data);
        }
        if (!xml || xml.getElementsByTagName("parsererror").length) {
            throw "XML parsing failed";
        }
        return xml;
    };
    var getHTTPObject = function(dt) {
        var http = false;
        if (dt.useCORS && window.XDomainRequest) {
            try {
                http = new XDomainRequest();
            } catch (E) {
                http = false;
            }
        } else if (XMLHttpRequest) {
            try {
                http = new XMLHttpRequest();
            } catch (e) {
                http = false;
            }
        } else if (typeof ActiveXObject !== "undefined") {
            try {
                http = new ActiveXObject("Msxml2.XMLHTTP");
                alert(2);
            } catch (e) {
                try {
                    http = new ActiveXObject("Microsoft.XMLHTTP");
                    alert(3);
                } catch (E) {
                    http = false;
                }
            }
        }
        return http;
    };
    var clear = function() {
        queue = [];
        multiQueue = [];
        loadedCount = 0;
        loading = false;
    };
    var store = function() {
        if (storageSupport) {
            storeToLocalStorage();
        } else {
            console.log("localStorage isn't supported");
        }
    };
    var clearStorage = function() {
        for (var i in queue) {
            localStorage.removeItem(queue[i].url);
        }
    };
    var storeToLocalStorage = function() {
        if (storageSupport) {
            for (var i in queue) {
                try {
                    localStorage[queue[i].url] = getTypeFunction(queue[i].dataType, "store")(queue[i]);
                } catch (err) {
                    console.log("localStorage limit exceeded");
                }
            }
            clear();
        } else {
            console.log("localStorage isn't supported");
        }
    };
    var loadFromLocalStorage = function(dt) {
        return localStorage[dt.url];
    };
    var callSuccess = function(dt) {
        if (dt && typeof dt.successCallback === "function") {
            dt.successCallback(dt.data, "success", dt);
            callIfFinished();
        }
    };
    var callError = function(dt) {
        if (dt && typeof dt.errorCallback === "function") {
            dt.errorCallback(dt, "error", "");
        }
        callIfFinished();
    };
    var callProgress = function() {
        if (progressCallback && typeof progressCallback === "function" && queue.length && loadedCount) {
            progressCallback(loadedCount / queue.length);
        }
    };
    var callIfFinished = function() {
        if (queue.length == loadedCount && afterLoadCallback && typeof afterLoadCallback === "function") {
            afterLoadCallback();
        }
    };
    var callback = function(classScope, fnCallback) {
        return function() {
            return fnCallback.apply(classScope, arguments);
        };
    };
    return {
        count: function() {
            return queue.length;
        },
        loadedCount: function() {
            return loadedCount;
        },
        clear: function() {
            clear();
        },
        get: function(url, params, success, type, reload) {
            return get(url, params, success, toLowerCase(type));
        },
        getJSON: function(url, params, success, reload) {
            return get(url, params, success, "json", reload);
        },
        getImage: function(url, params, success, reload) {
            return get(url, params, success, "image", reload);
        },
        getBinary: function(url, params, success, reload) {
            return get(url, params, success, "binary", reload);
        },
        getXML: function(url, params, success, reload) {
            return get(url, params, success, "xml", reload);
        },
        getText: function(url, params, success, reload) {
            return get(url, params, success, "text", reload);
        },
        getMultiple: function(urlList, success, reload) {
            getMultiple(urlList, success, reload);
        },
        store: function() {
            store();
        },
        clearStorage: function() {
            clearStorage();
        },
        types: function() {
            return typefunctions;
        },
        onFinishedLoading: function(callback) {
            afterLoadCallback = callback;
        },
        onProgress: function(callback) {
            progressCallback = callback;
        },
        getQueue: function() {
            return queue;
        },
        getTypeFunction: function(type, method) {
            return getTypeFunction(type, method);
        },
        setTypeFunction: function(type, method) {
            return setTypeFunction(type, method);
        }
    };
}();

frakVersion = "1.0.15";

var FRAK = Class.extend({
    init: function(callback, includes, useCache, prefix, progressCallback, eachItemCallback) {
        if (!prefix) prefix = "js/";
        this.prefix = prefix;
        if (!includes) includes = [];
        if (!useCache) useCache = false;
        this.useCache = useCache;
        this.stack = [];
        this.callback = callback;
        this.onEachItem = eachItemCallback;
        this.onProgress = progressCallback;
        this.total = 0;
        this.loaded = 0;
        $.ajaxSetup({
            cache: useCache
        });
        for (var inc in includes) {
            this.include(includes[inc]);
        }
        this.load();
    },
    include: function(script) {
        this.stack.push(script);
        this.total++;
    },
    getVersion: function() {
        return frakVersion;
    },
    load: function() {
        if (this.stack.length == 0) {
            this.callback();
            return;
        }
        var script = this.prefix + this.stack.shift();
        var me = this;
        $.getScript(script, function(data) {
            me.loaded++;
            if ($.isFunction(me.onEachItem)) {
                me.onEachItem(script, data);
            }
            if ($.isFunction(me.onProgress)) me.onProgress(me.loaded * 100 / me.total);
            me.load();
        }).fail(function(jqxhr, settings, exception) {
            console.log("Failed to load '" + script + "' at " + exception.lineNumber + ": " + exception);
            console.trace();
        });
    }
});

var Cloneable = Class.extend({
    type: function() {
        return false;
    },
    clone: function() {
        return typeof window[this.type()] === "function" ? new (window[this.type()])() : {};
    }
});

var nextSerializableID = 1;

var Serializable = Cloneable.extend({
    init: function() {
        this.serializable = true;
        this.id = nextSerializableID++;
    },
    included: function() {
        return true;
    },
    excluded: function() {
        return [];
    },
    getSerializableFields: function(extraExcluded) {
        var included = this.included();
        excluded = this.excluded();
        if (included === true && excluded === true) throw "Quantum classes not allowed. A subclass of Serializable tries to both include and exclude all fields.";
        if (included === false && excluded === false) throw "Quantum classes not allowed. A subclass of Serializable tries both not to include and not to exclude all fields.";
        if (included === false || excluded === true) return {};
        var fields = {};
        if (included === true) {
            for (var t in this) {
                var getType = {};
                if (this[t] && getType.toString.call(this[t]) == "[object Function]" || t == "serializable" || t == "_super") continue;
                fields[t] = this[t];
            }
            if (excluded instanceof Array) {
                excluded = excluded.concat(extraExcluded);
                for (var e in excluded) {
                    if (fields[excluded[e]]) delete fields[excluded[e]];
                }
            }
        }
        if (excluded === true) {
            fields = [];
            for (var i in included) {
                var t = included[i];
                var getType = {};
                if (this[t] && getType.toString.call(this[t]) == "[object Function]" || t == "serializable" || t == "_super") continue;
                fields[t] = this[t];
            }
        }
        return fields;
    },
    serialize: function(excluded) {
        try {
            var serializer = new Serializer();
            return serializer.serialize(this, excluded, 32);
        } catch (e) {
            console.log("Caught serialization exception: ", e);
            throw e;
        }
    },
    unserialize: function(text) {
        var data = $.parseJSON(text);
        return false;
    },
    serializeCyclic: function(excluded) {
        try {
            var serializer = new CyclicSerializer();
            return serializer.serialize(this, excluded, 32);
        } catch (e) {
            console.log("Caught serialization exception: ", e);
            throw e;
        }
    },
    unserializeCyclic: function(text) {
        try {
            var serializer = new CyclicSerializer();
            return serializer.unserialize(text);
        } catch (e) {
            console.log("Caught serialization exception: ", e);
            throw e;
        }
    },
    onBeforeSerialize: function() {},
    onAfterSerialize: function() {},
    onBeforeUnserialize: function() {},
    onAfterUnserialize: function() {}
});

var Serializer = Class.extend({
    init: function() {
        this.serializables = {};
    },
    serializableCopy: function(stack, value, excluded, depth, maximumDepth) {
        var result = {};
        var fields = value.getSerializableFields(excluded);
        if (depth >= maximumDepth) {
            var trace = [];
            for (var s in stack) {
                trace.push(stack[s].type());
            }
            throw "Reached maximum depth for serialization: " + depth + " at " + value.type();
        }
        stack = stack.slice(0);
        stack.splice(0, 0, value);
        for (var f in fields) {
            var field = fields[f];
            if (field instanceof Serializable) result[f] = this.serializableCopy(stack, field, excluded, depth + 1, maximumDepth); else if (field instanceof Array || field instanceof Float32Array) {
                var arrayResult = [];
                for (var i in field) {
                    if (field[i] instanceof Serializable) {
                        arrayResult.push(this.serializableCopy(stack, field[i], excluded, depth + 1, maximumDepth));
                    } else arrayResult.push(field[i]);
                }
                result[f] = arrayResult;
            } else result[f] = fields[f];
        }
        return {
            _type_: value.type(),
            _properties_: result
        };
    },
    serialize: function(object, excluded, maximumDepth) {
        this.serializables = {};
        var r = this.serializableCopy([], object, excluded, 0, maximumDepth);
        return JSON.stringify({
            _root_: r,
            _serializables_: this.serializables
        }, undefined, 2);
    },
    unserializeSerializables: function(data) {
        for (var id in data) {
            this.serializables[id] = this.unserializeCopy(data[id]);
        }
    },
    unserializeCopy: function(v) {
        if (v instanceof Array) {
            for (var p in v) {
                v[p] = this.unserializeCopy(v[p]);
            }
            return v;
        } else if (v instanceof Object) {
            if (v._reference_) {
                return v;
            } else if (v._type_) {
                var t = new window[v._type_]();
                t.onBeforeUnserialize();
                for (var p in v._properties_) {
                    t[p] = this.unserializeCopy(v._properties_[p]);
                }
                t.onAfterUnserialize();
                return t;
            }
            return v;
        } else {
            return t;
        }
    },
    resolveReferences: function(object, key) {
        if (object[key] instanceof Array) {
            for (var p in object[key]) {
                object[key][p] = this.resolveReferences(object[key], p);
            }
        } else if (object[key] instanceof Object) {
            if (object[key]._reference_) {
                object[key] = this.serializables[object[key]._id_];
            } else {
                for (var p in object[key]) {
                    object[key][p] = this.resolveReferences(object[key], p);
                }
            }
        }
    },
    unserialize: function(text) {
        var data = $.parseJSON(text);
        this.serializables = {};
        this.unserializeSerializables(data["_serializables_"]);
        var unserialized = this.unserializeCopy(data["_root_"]);
        for (var i in this.serializables) {
            this.resolveReferences(this.serializables, i);
        }
        this.resolveReferences(data, "_serializables_");
        return unserialized;
    }
});

var CyclicSerializer = Class.extend({
    init: function() {
        this.serializables = {};
        this.visited = [];
    },
    serializableCopy: function(stack, value, excluded, depth, maximumDepth) {
        if (depth >= maximumDepth) return {};
        stack = stack.slice(0);
        stack.push(value);
        try {
            if (typeof value === "object") {
                if (!value) return null;
                if (value instanceof Serializable) {
                    if (!this.serializables[value.id]) {
                        this.serializables[value.id] = true;
                        value.onBeforeSerialize();
                        var fields = value.getSerializableFields(value, excluded);
                        for (var f in fields) {
                            fields[f] = this.serializableCopy(stack, fields[f], excluded, depth + 1, maximumDepth);
                        }
                        value.onAfterSerialize();
                        this.serializables[value.id] = {
                            _type_: value.type(),
                            _properties_: fields
                        };
                    }
                    return {
                        _reference_: true,
                        _id_: value.id
                    };
                } else if (value instanceof Array || value instanceof Float32Array) {
                    var result = [];
                    for (var f in value) {
                        result.push(this.serializableCopy(stack, value[f], excluded, depth + 1, maximumDepth));
                    }
                    return result;
                } else {
                    if (value._visited_) {
                        console.log("Already visited object: ", value);
                        return;
                    }
                    value._visited = true;
                    var fields = {};
                    for (var f in value) {
                        fields[f] = this.serializableCopy(stack, value[f], excluded, depth + 1, maximumDepth);
                    }
                    return fields;
                }
            } else {
                return value;
            }
        } catch (e) {
            console.log("Caught: ", value, e);
            console.log("Stack: ");
            console.log(stack);
            throw e;
        }
    },
    serialize: function(object, excluded, maximumDepth) {
        this.serializables = {};
        var r = this.serializableCopy([], object, excluded, 0, maximumDepth);
        return JSON.stringify({
            _root_: r,
            _serializables_: this.serializables
        }, undefined, 2);
    },
    unserializeSerializables: function(data) {
        for (var id in data) {
            this.serializables[id] = this.unserializeCopy(data[id]);
        }
    },
    unserializeCopy: function(v) {
        if (v instanceof Array) {
            for (var p in v) {
                v[p] = this.unserializeCopy(v[p]);
            }
            return v;
        } else if (v instanceof Object) {
            if (v._reference_) {
                return v;
            } else if (v._type_) {
                var t = new window[v._type_]();
                t.onBeforeUnserialize();
                for (var p in v._properties_) {
                    t[p] = this.unserializeCopy(v._properties_[p]);
                }
                return t;
            }
            return v;
        } else {
            return v;
        }
    },
    resolveReferences: function(object, key, depth) {
        if (depth > 32) return;
        if (object[key] instanceof Array) {
            for (var p in object[key]) {
                this.resolveReferences(object[key], p, depth + 1);
            }
        } else if (object[key] instanceof Object && !("_visited_" in object[key])) {
            if (object[key]._reference_) {
                object[key] = this.serializables[object[key]._id_];
            } else if (object[key] instanceof Serializable) {
                object[key]._visited_ = true;
                this.visited.push(object[key]);
                for (var k in object[key]) {
                    this.resolveReferences(object[key], k, depth + 1);
                }
            } else {}
        }
    },
    unserialize: function(text) {
        var data = $.parseJSON(text);
        this.serializables = {};
        this.unserializeSerializables(data["_serializables_"]);
        var unserialized = {
            _root_: this.unserializeCopy(data["_root_"])
        };
        this.resolveReferences(unserialized, "_root_", 0);
        for (var i in this.serializables) {
            this.resolveReferences(this.serializables, i, 0);
        }
        for (var i in this.visited) {
            if (this.visited[i] instanceof Serializable) {
                this.visited[i].onAfterUnserialize();
            }
        }
        for (var i in this.visited) {
            delete this.visited[i]._visited_;
        }
        return unserialized["_root_"];
    }
});

var TypeReference = Serializable.extend({
    init: function(type, value) {
        this._super();
        this.valueType = type;
        this.value = value;
    },
    type: function() {
        return "TypeReference";
    },
    isNull: function() {
        return !this.value;
    }
});

var Color = function(r, g, b, a) {
    this.r = 1;
    this.g = 1;
    this.b = 1;
    this.a = 1;
    this.clone = function() {
        return new Color(this.r, this.g, this.b, this.a);
    };
    this.fromHex = function(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(hex);
        if (result) {
            this.r = parseInt(result[1], 16) / 255;
            this.g = parseInt(result[2], 16) / 255;
            this.b = parseInt(result[3], 16) / 255;
            if (result[4]) this.a = parseInt(result[4], 16) / 255;
        }
        return this;
    };
    this.toHex = function() {
        var componentToHex = function(v) {
            var h = v.toString(16);
            return h.length == 1 ? "0" + h : h;
        };
        return "#" + componentToHex(this.r * 255) + componentToHex(this.g * 255) + componentToHex(this.b * 255) + componentToHex(this.a * 255);
    };
    this.toString = function() {
        return "rgba(" + this.r * 255 + ", " + this.g * 255 + ", " + this.b * 255 + ", " + this.a + ")";
    };
    this.toVector = function() {
        return vec4.fromValues(this.r, this.g, this.b, this.a);
    };
    this.set = function(r, g, b, a) {
        if (typeof r == "number") this.r = r;
        if (typeof g == "number") this.g = g;
        if (typeof b == "number") this.b = b;
        if (typeof a == "number") this.a = a;
    };
    this.set(r, g, b, a);
};

var MatrixStack = Class.extend({
    init: function() {
        this.stack = [ mat4.identity(mat4.create()) ];
        this.allocated = [];
        for (var i = 0; i < 64; i++) this.allocated.push(mat4.create());
    },
    top: function() {
        return this.stack[this.stack.length - 1];
    },
    push: function() {
        if (this.allocated.length == 0) this.allocated.push(mat4.create());
        this.stack.push(mat4.copy(this.allocated.pop(), this.stack[this.stack.length - 1]));
    },
    pop: function() {
        this.allocated.push(this.stack.pop());
    },
    multiply: function(matrix) {
        mat4.multiply(this.stack[this.stack.length - 1], this.stack[this.stack.length - 1], matrix);
    },
    load: function(matrix) {
        mat4.copy(this.stack[this.stack.length - 1], matrix);
    },
    size: function() {
        return this.stack.length;
    }
});

var RenderingContext = Class.extend({
    init: function(canvas, contextOptions) {
        if (!("WebGLRenderingContext" in window)) throw "Unable to create rendering context, because browser doesn't support WebGL";
        if (!canvas || canvas.length === 0) throw "RenderingContext requires canvas element";
        this.canvas = canvas;
        contextOptions = contextOptions || {
            alpha: false
        };
        this.gl = canvas[0].getContext("webgl", contextOptions);
        if (!this.gl) this.gl = canvas[0].getContext("experimental-webgl", contextOptions);
        if (!this.gl) this.gl = canvas[0].getContext("moz-webgl", contextOptions);
        if (!this.gl) this.gl = canvas[0].getContext("webkit-3d", contextOptions);
        if (!this.gl) {
            var offset = canvas.offset();
            var msg = $("<div>").css("position", "relative").css("z-index", 100).css("background-color", "red").css("padding", 8).text("WebGL seems to be unavailable in this browser.");
            canvas.parent().prepend(msg);
            throw "Failed to acquire GL context from canvas";
        }
        if (typeof WebGLDebugUtils != "undefined") {
            function throwOnGLError(err, funcName, args) {
                throw WebGLDebugUtils.glEnumToString(err) + " was caused by call to: " + funcName + JSON.stringify(args);
            }
            this.gl = WebGLDebugUtils.makeDebugContext(this.gl, throwOnGLError);
            console.log("Using WebGLDebugUtils");
        }
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.viewport(0, 0, canvas.width(), canvas.height());
        this.modelview = new MatrixStack();
        this.projection = new MatrixStack();
        this.light = false;
        this.shadow = false;
        this.camera = false;
        this.engine = false;
    }
});

var Subshader = Class.extend({
    init: function(shader, code, type) {
        this.shader = shader;
        this.context = shader.context;
        this.code = code;
        this.type = type;
        this.VERTEX_SHADER = 0;
        this.FRAGMENT_SHADER = 1;
        this.compiledShader = false;
        this.failedCompilation = false;
    },
    attach: function() {
        this.context.gl.attachShader(this.shader.program, this.compiledShader);
    },
    compile: function() {
        if (this.failedCompilation) return;
        if (!this.compiledShader) throw "WebGL shader has not been created. FragmentShader or VertexShader class instances should be used, not Shader.";
        this.context.gl.shaderSource(this.compiledShader, this.code);
        this.context.gl.compileShader(this.compiledShader);
        if (!this.context.gl.getShaderParameter(this.compiledShader, this.context.gl.COMPILE_STATUS)) {
            if (!this.failedCompilation) {
                this.failedCompilation = true;
                throw "Shader '" + this.shader.name + "' failed to compile: " + this.context.gl.getShaderInfoLog(this.compiledShader);
            }
        }
    }
});

var VertexShader = Subshader.extend({
    init: function(shader, code) {
        this._super(shader, code, this.VERTEX_SHADER);
        this.compiledShader = this.context.gl.createShader(this.context.gl.VERTEX_SHADER);
    }
});

var FragmentShader = Subshader.extend({
    init: function(shader, code) {
        this._super(shader, code, this.FRAGMENT_SHADER);
        this.compiledShader = this.context.gl.createShader(this.context.gl.FRAGMENT_SHADER);
    }
});

var ShaderRequirements = Class.extend({
    init: function() {
        this.barycentric = false;
        this.bitangents = false;
        this.tangents = false;
        this.transparent = false;
        this.texCoords2D = true;
    },
    apply: function(renderBuffer) {
        if (this.barycentric && !renderBuffer.buffers["barycentric"]) renderBuffer.generateBarycentric();
        if (this.texCoords2D && !renderBuffer.buffers["texcoord2d0"]) renderBuffer.generateTexCoords();
    }
});

var Shader = Serializable.extend({
    init: function(context, descriptor) {
        this._super();
        if (!context) throw "RenderingContext not passed to canvas";
        this.descriptor = descriptor;
        this.context = context;
        this.program = context.gl.createProgram();
        this.shaders = [];
        this.requirements = new ShaderRequirements();
        this.linked = false;
        this.failed = false;
        this.uniformLocations = {};
    },
    excluded: function() {
        return true;
    },
    included: function() {
        return [ "descriptor" ];
    },
    addVertexShader: function(code) {
        var shader = new VertexShader(this, code);
        this.addShader(shader);
    },
    addFragmentShader: function(code) {
        var shader = new FragmentShader(this, code);
        this.addShader(shader);
    },
    addShader: function(shader) {
        this.shaders.push(shader);
        shader.attach();
    },
    link: function() {
        if (this.failed) return;
        for (var i in this.shaders) {
            this.shaders[i].compile(this.context);
        }
        this.uniformLocations = {};
        this.linked = true;
        this.context.gl.linkProgram(this.program);
        if (!this.context.gl.getProgramParameter(this.program, this.context.gl.LINK_STATUS)) {
            this.linked = false;
            this.failed = true;
        }
    },
    use: function(uniforms) {
        if (this.failed) return;
        if (this.shaders.length < 2) return;
        if (!this.linked) this.link();
        if (!this.linked) return;
        this.context.gl.useProgram(this.program);
        this.bindUniforms(uniforms);
    },
    getUniformLocation: function(uniformName) {
        if (!this.uniformLocations[uniformName]) {
            this.uniformLocations[uniformName] = this.context.gl.getUniformLocation(this.program, uniformName);
        }
        return this.uniformLocations[uniformName];
    },
    bindUniforms: function(uniforms) {
        if (!uniforms) return;
        if (!this.linked) return;
        for (var uniformName in uniforms) {
            var uniformLocation = this.getUniformLocation(uniformName);
            if (!uniformLocation || uniformLocation == -1) continue;
            var uniform = uniforms[uniformName];
            if (!uniform) throw "Uniform '" + uniformName + "' is undefined.";
            uniform.bind(this.context, uniformLocation);
        }
    },
    bindSamplers: function(samplers) {
        if (!samplers || samplers.length == 0) return;
        if (!this.linked) return;
        var gl = this.context.gl;
        var slotIndex = 0;
        for (var samplerIndex in samplers) {
            var sampler = samplers[samplerIndex];
            var uniformLocation = this.getUniformLocation(sampler.name);
            if (uniformLocation == -1) continue;
            sampler.bind(this.context, uniformLocation, slotIndex);
            slotIndex++;
        }
        gl.activeTexture(gl.TEXTURE0);
    },
    unbindSamplers: function(samplers) {
        if (!samplers || samplers.length == 0) return;
        if (!this.linked) return;
        var gl = this.context.gl;
        var slotIndex = 0;
        for (var samplerIndex in samplers) {
            var sampler = samplers[samplerIndex];
            var uniformLocation = this.getUniformLocation(sampler.name);
            if (uniformLocation == -1) continue;
            sampler.unbind(this.context, uniformLocation, slotIndex);
            slotIndex++;
        }
        gl.activeTexture(gl.TEXTURE0);
    }
});

var Uniform = Cloneable.extend({
    init: function(value) {
        this.value = value;
    },
    bind: function(context, uniformLocation) {},
    clone: function() {
        var c = this._super();
        c.value = value;
        return c;
    }
});

var UniformInt = Uniform.extend({
    bind: function(context, uniformLocation) {
        context.gl.uniform1i(uniformLocation, this.value);
    },
    type: function() {
        return "UniformInt";
    }
});

var UniformFloat = Uniform.extend({
    bind: function(context, uniformLocation) {
        context.gl.uniform1f(uniformLocation, this.value);
    },
    type: function() {
        return "UniformFloat";
    }
});

var UniformVec2 = Uniform.extend({
    init: function(value) {
        if (value instanceof Float32Array) {
            this._super(value);
        } else this._super(new Float32Array(value));
    },
    type: function() {
        return "UniformVec2";
    },
    bind: function(context, uniformLocation) {
        context.gl.uniform2fv(uniformLocation, this.value);
    },
    clone: function() {
        var c = this._super();
        c.value = vec2.clone(value);
        return c;
    }
});

var UniformVec3 = Uniform.extend({
    init: function(value) {
        if (value instanceof Float32Array) {
            this._super(value);
        } else this._super(new Float32Array(value));
    },
    type: function() {
        return "UniformVec3";
    },
    bind: function(context, uniformLocation) {
        context.gl.uniform3fv(uniformLocation, this.value);
    },
    clone: function() {
        var c = this._super();
        c.value = vec3.clone(value);
        return c;
    }
});

var UniformVec4 = Uniform.extend({
    init: function(value) {
        if (value instanceof Float32Array) {
            this._super(value);
        } else this._super(new Float32Array(value));
    },
    type: function() {
        return "UniformVec4";
    },
    bind: function(context, uniformLocation) {
        context.gl.uniform4fv(uniformLocation, this.value);
    },
    clone: function() {
        var c = this._super();
        c.value = mat2.clone(value);
        return c;
    }
});

var UniformColor = UniformVec4.extend({
    init: function(value) {
        this._super([ value.r, value.g, value.b, value.a ]);
    },
    type: function() {
        return "UniformColor";
    }
});

var UniformMat4 = Uniform.extend({
    bind: function(context, uniformLocation) {
        context.gl.uniformMatrix4fv(uniformLocation, false, this.value);
    },
    type: function() {
        return "UniformMat4";
    },
    clone: function() {
        var c = this._super();
        c.value = mat4.clone(value);
        return c;
    }
});

var fallbackTexture = false;

var Sampler = Serializable.extend({
    init: function(name, texture) {
        this.name = name;
        this.texture = texture;
    },
    type: function() {
        return "Sampler";
    },
    createFallbackTexture: function(context) {
        fallbackTexture = new Texture(context);
        var canvas = document.createElement("canvas");
        canvas.width = 2;
        canvas.height = 2;
        var ctx = canvas.getContext("2d");
        ctx.fillStyle = "rgb(255,255,255)";
        ctx.fillRect(0, 0, 2, 2);
        fallbackTexture.setImage(context, canvas);
    },
    bind: function(context, uniformLocation, slotIndex) {
        context.gl.activeTexture(slotIndex + context.gl.TEXTURE0);
        context.gl.uniform1i(uniformLocation, slotIndex);
        if (!this.texture || !this.texture.loaded) {
            if (!fallbackTexture) {
                this.createFallbackTexture(context);
            }
            fallbackTexture.bind(context);
            return;
        }
        this.texture.bind(context);
    },
    unbind: function(context, uniformLocation, slotIndex) {
        context.gl.activeTexture(slotIndex + context.gl.TEXTURE0);
        if (!this.texture || !this.texture.loaded) {
            fallbackTexture.unbind(context);
            return;
        }
        this.texture.unbind(context);
    },
    clone: function() {
        var c = this._super();
        c.name = this.name;
        c.texture = this.texture;
        return c;
    }
});

var Camera = Serializable.extend({
    init: function(viewMatrix, projectionMatrix, renderStage) {
        this.viewMatrix = viewMatrix;
        this.viewInverseMatrix = mat4.invert(mat4.create(), this.viewMatrix);
        this.projectionMatrix = projectionMatrix;
        this.renderStage = renderStage;
        this.target = new TargetScreen();
        this.backgroundColor = new Color(0, 0, 0, 0);
        this.clearMask = false;
        this.order = 0;
        this.layerMask = 4294967295;
        this.frustum = false;
    },
    type: function() {
        return "Camera";
    },
    excluded: function() {
        return [ "renderStage", "target" ];
    },
    startRender: function(context) {
        context.projection.push();
        context.projection.multiply(this.projectionMatrix);
        context.modelview.push();
        context.modelview.multiply(this.viewMatrix);
        mat4.invert(this.viewInverseMatrix, this.viewMatrix);
        context.gl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
        context.gl.clearDepth(1);
        context.gl.depthMask(true);
        if (this.clearMask === false) {
            context.gl.clear(context.gl.COLOR_BUFFER_BIT | context.gl.DEPTH_BUFFER_BIT);
        } else {
            context.gl.clear(this.clearMask);
        }
    },
    endRender: function(context) {
        context.modelview.pop();
        context.projection.pop();
    },
    render: function(context, scene) {
        context.camera = this;
        this.renderStage.render(context, scene, this);
        context.camera = false;
    },
    getFieldOfView: function() {
        return 2 * Math.atan(1 / this.projectionMatrix[5]);
    },
    getDirection: function(out) {
        if (!out) out = vec3.create();
        out[0] = -this.viewMatrix[2];
        out[1] = -this.viewMatrix[6];
        out[2] = -this.viewMatrix[10];
        return out;
    },
    getPosition: function(out) {
        if (!out) out = vec3.create();
        var m = mat4.invert(mat4.create(), this.viewMatrix);
        mat4.translation(out, m);
        return out;
    },
    setPosition: function(position) {
        var p = this.getPosition();
        vec3.sub(p, p, position);
        var m = mat4.fromTranslation(mat4.create(), p);
        mat4.mul(this.viewMatrix, this.viewMatrix, m);
    },
    center: function(point) {
        var dir = this.getDirection();
        var pos = this.getPosition();
        var plane = new Plane();
        plane.setByNormalAndPoint(dir, pos);
        var p = plane.projectToPlane(point);
        this.setPosition(p);
    },
    fitToView: function(boundingVolume) {
        if (!(boundingVolume instanceof BoundingVolume) || !boundingVolume.center) return;
        this.center(boundingVolume.center);
        if (boundingVolume.isPoint()) return;
        var size = 0;
        if (boundingVolume instanceof BoundingSphere) {
            size = boundingVolume.radius * 2;
        } else if (boundingVolume instanceof BoundingBox) {
            size = boundingVolume.getOuterSphereRadius() * 2;
        }
        var distance = size / Math.sin(this.getFieldOfView() / 2) - size;
        var dir = this.getDirection();
        var pos = vec3.create();
        vec3.scale(dir, dir, -distance);
        vec3.add(pos, boundingVolume.center, dir);
        this.setPosition(pos);
    }
});

var RenderStage = Class.extend({
    init: function() {
        this.parent = false;
        this.substages = [];
        this.started = false;
    },
    addStage: function(stage) {
        stage.parent = this;
        this.substages.push(stage);
        return stage;
    },
    removeStage: function(stage) {
        for (var i = 0; i < this.substages.length; i++) {
            if (this.substages[i] === stage) {
                stage.parent = false;
                this.substages.splice(i, 1);
                return true;
            }
        }
        return false;
    },
    removeStagesByType: function(stageType) {
        var removed = [];
        for (var i = 0; i < this.substages.length; i++) {
            if (this.substages[i] instanceof stageType) {
                removed.push(this.substages[i]);
                this.substages.splice(i, 1);
                i--;
            }
        }
        for (var i in removed) {
            removed[i].parent = false;
        }
        return removed;
    },
    clearStages: function() {
        this.substages = [];
    },
    start: function(context, engine, camera) {
        this.started = true;
        this.onStart(context, engine, camera);
        for (var stage in this.substages) this.substages[stage].start(context, engine, camera);
    },
    render: function(context, scene, camera) {
        this.onPreRender(context, scene, camera);
        for (var stage in this.substages) {
            if (!this.substages[stage].started) this.substages[stage].start(context, scene.engine, camera);
            this.substages[stage].render(context, scene, camera);
        }
        this.onPostRender(context, scene, camera);
    },
    onStart: function(context, engine, camera) {},
    onPreRender: function(context, scene, camera) {},
    onPostRender: function(context, scene, camera) {}
});

var MaterialRenderStage = RenderStage.extend({
    init: function() {
        this._super();
        this.visibleRenderers = 0;
        this.visibleSolidRenderers = 0;
        this.visibleSolidBatches = 0;
        this.visibleSolidFaces = 0;
        this.visibleTransparentRenderers = 0;
        this.visibleTransparentFaces = 0;
        this.solidRenderers = [];
        this.solidRendererBatches = [];
        this.transparentRenderers = [];
        this.shadowMapStage = this.addStage(new ShadowMapRenderStage());
        this.shadowMapFallbackSampler = false;
        this.transparencyTarget = false;
        this.transparencySampler = false;
        this.transparencyWeight = false;
        this.transparencyWeightSampler = false;
        this.transparencyAccum = false;
        this.oitClearColor = new Color(0, 0, 0, 0);
        this.eyePosition = vec3.create();
        this.invModelview = mat4.create();
        this.sharedUniforms = {
            time: new UniformFloat(0),
            view: new UniformMat4(mat4.create()),
            viewInverse: new UniformMat4(mat4.create()),
            projection: new UniformMat4(mat4.create())
        };
        this.rendererUniforms = {
            model: new UniformMat4(mat4.create()),
            modelview: new UniformMat4(mat4.create()),
            modelviewInverse: new UniformMat4(mat4.create())
        };
        this.lightUniforms = {
            lightDirection: new UniformVec3(vec3.create()),
            lightColor: new UniformColor(new Color()),
            lightIntensity: new UniformFloat(0),
            useShadows: new UniformInt(0)
        };
        this.shadowUniforms = {
            linearDepthConstant: new UniformFloat(0),
            lightView: new UniformMat4(mat4.create()),
            lightProjection: new UniformMat4(mat4.create()),
            shadowIntensity: new UniformFloat(0)
        };
        this.enableDynamicBatching = true;
        this._addUniforms = function(uniforms, other) {
            if (!other) return;
            for (var key in other) uniforms[key] = other[key];
        };
    },
    onStart: function(context, engine, camera) {
        var size = camera.target.size;
        this.transparencyTarget = new TargetTextureFloat(size, context, false);
        this.transparencySampler = new Sampler("oitAccum", this.transparencyTarget.texture);
        this.transparencyWeight = new TargetTextureFloat(size, context, false);
        this.transparencyWeightSampler = new Sampler("oitWeight", this.transparencyWeight.texture);
        this.transparencyAccum = new Material(engine.assetsManager.addShaderSource("shaders/default/OITAccum"), {
            render_mode: new UniformInt(0)
        }, []);
        engine.assetsManager.load();
    },
    prepareShadowContext: function(context, scene) {
        if (this.shadowMapFallbackSampler === false) {
            this.shadowMapFallbackSampler = new Sampler("shadow0", scene.engine.WhiteTexture);
        }
        if (!this.shadowMapStage.active) return;
        var light = this.shadowMapStage.getFirstShadowCastingLight(scene);
        if (!light) return;
        context.shadow = {
            shadow0: this.shadowMapStage.shadowSampler,
            linearDepthConstant: this.shadowMapStage.material.uniforms["linearDepthConstant"],
            lightProjection: new UniformMat4(this.shadowMapStage.lightProj),
            lightView: new UniformMat4(this.shadowMapStage.lightView),
            shadowIntensity: new UniformFloat(light.shadowIntensity)
        };
    },
    onPreRender: function(context, scene, camera) {
        this.solidRendererBatches = {};
        this.solidRenderers.length = 0;
        this.transparentRenderers.length = 0;
        this.visibleSolidRenderers = 0;
        this.visibleSolidBatches = 0;
        this.visibleSolidFaces = 0;
        this.visibleTransparentFaces = 0;
        var renderers = scene.dynamicSpace.frustumCast(camera.frustum, camera.layerMask);
        for (var i in renderers) {
            if (renderers[i].transparent) {
                this.transparentRenderers.push(renderers[i]);
                this.visibleTransparentFaces += renderers[i].submesh.faces.length;
            } else {
                if (this.enableDynamicBatching) {
                    if (renderers[i].material.id in this.solidRendererBatches) this.solidRendererBatches[renderers[i].material.id].push(renderers[i]); else {
                        this.solidRendererBatches[renderers[i].material.id] = [ renderers[i] ];
                        this.visibleSolidBatches++;
                    }
                }
                this.visibleSolidFaces += renderers[i].submesh.faces.length;
                this.solidRenderers.push(renderers[i]);
                this.visibleSolidRenderers++;
            }
        }
        this.visibleRenderers = renderers.length;
        this.visibleTransparentRenderers = this.transparentRenderers.length;
        if (scene.engine.options.transparencyMode == "sorted") {
            mat4.invert(this.invModelview, context.modelview.top());
            mat4.translation(this.eyePosition, this.invModelview);
            var eyePosition = this.eyePosition;
            this.transparentRenderers.sort(function(a, b) {
                var d1 = vec3.squaredDistance(eyePosition, a.globalBoundingSphere.center);
                var d2 = vec3.squaredDistance(eyePosition, b.globalBoundingSphere.center);
                if (d1 > d2) return -1;
                if (d1 < d2) return 1;
                return 0;
            });
        }
    },
    renderBatched: function(context) {
        var date = new Date();
        var batches = this.solidRendererBatches;
        var globalSamplers = [];
        this.sharedUniforms.projection = new UniformMat4(context.projection.top());
        this.sharedUniforms.view = new UniformMat4(context.camera.viewMatrix);
        this.sharedUniforms.viewInverse = new UniformMat4(context.camera.viewInverseMatrix);
        this.sharedUniforms.time.value = date.getTime();
        if (context.light) {
            this.lightUniforms.lightDirection = new UniformVec3(context.light.direction);
            this.lightUniforms.lightColor = new UniformColor(context.light.color);
            this.lightUniforms.lightIntensity = new UniformFloat(context.light.intensity);
            this.lightUniforms.useShadows = new UniformInt(context.shadow ? 1 : 0);
        }
        if (context.shadow) {
            this.shadowUniforms.linearDepthConstant = context.shadow.linearDepthConstant;
            this.shadowUniforms.lightView = context.shadow.lightView;
            this.shadowUniforms.lightProjection = context.shadow.lightProjection;
            this.shadowUniforms.shadowIntensity = context.shadow.shadowIntensity;
            globalSamplers.push(context.shadow.shadow0);
        } else {
            globalSamplers.push(this.shadowMapFallbackSampler);
        }
        var usedShader = false;
        for (var i in batches) {
            var batch = batches[i];
            var material = batch[0].material;
            var shader = material.shader;
            if (shader != usedShader) {
                shader.use();
                usedShader = shader;
                if (context.shadow) shader.bindUniforms(this.shadowUniforms);
                shader.bindUniforms(this.sharedUniforms);
                if (context.light) shader.bindUniforms(this.lightUniforms);
            }
            var samplers = globalSamplers.concat(material.samplers);
            shader.bindSamplers(samplers);
            shader.bindUniforms(material.uniforms);
            for (var j = 0; j < batch.length; ++j) {
                context.modelview.push();
                context.modelview.multiply(batch[j].matrix);
                this.rendererUniforms.model.value = batch[j].matrix;
                this.rendererUniforms.modelview.value = context.modelview.top();
                this.rendererUniforms.modelviewInverse.value = mat4.invert(mat4.create(), context.modelview.top());
                shader.bindUniforms(this.rendererUniforms);
                batch[j].render(context);
                context.modelview.pop();
            }
            shader.unbindSamplers(samplers);
        }
    },
    renderBruteForce: function(context, renderers) {
        var globalSamplers = [];
        if (context.shadow) {
            globalSamplers.push(context.shadow.shadow0);
        } else {
            globalSamplers.push(this.shadowMapFallbackSampler);
        }
        for (var j = 0; j < renderers.length; ++j) {
            var renderer = renderers[j];
            context.modelview.push();
            context.modelview.multiply(renderer.matrix);
            renderer.material.bind(renderer.getDefaultUniforms(context), globalSamplers);
            renderer.render(context);
            renderer.material.unbind(globalSamplers);
            context.modelview.pop();
        }
    },
    renderSolid: function(context, scene, camera) {
        var gl = context.gl;
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        gl.depthMask(true);
        if (scene.lights.length > 0) context.light = scene.lights[0];
        if (this.enableDynamicBatching) {
            this.renderBatched(context);
        } else {
            this.renderBruteForce(context, this.solidRenderers);
        }
        context.light = false;
        if (scene.lights.length > 1) {
            gl.depthMask(false);
            gl.depthFunc(gl.LEQUAL);
            gl.blendFunc(gl.ONE, gl.ONE);
            gl.enable(gl.BLEND);
            for (var l = 1; l < scene.lights.length; l++) {
                context.light = scene.lights[l];
                if (this.enableDynamicBatching) {
                    this.renderBatched(context);
                } else {
                    this.renderBruteForce(context, this.solidRenderers);
                }
            }
            gl.disable(gl.BLEND);
            gl.depthMask(true);
            gl.depthFunc(gl.LESS);
        }
        gl.disable(gl.DEPTH_TEST);
    },
    renderAlphaMapped: function(context, scene, camera) {
        var gl = context.gl;
        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
        this.transparencyAccum.uniforms["render_mode"].value = 2;
        for (var i in this.transparentRenderers) {
            var renderer = this.transparentRenderers[i];
            context.modelview.push();
            context.modelview.multiply(renderer.matrix);
            var uniforms = {};
            this._addUniforms(uniforms, renderer.material.uniforms);
            this._addUniforms(uniforms, renderer.getDefaultUniforms(context));
            this.transparencyAccum.bind(uniforms, renderer.material.samplers);
            renderer.renderGeometry(context, this.transparencyAccum.shader);
            this.transparencyAccum.unbind();
            context.modelview.pop();
        }
        gl.disable(gl.DEPTH_TEST);
    },
    renderTransparent: function(context, scene, camera) {
        var gl = context.gl;
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);
        gl.depthMask(false);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
        this.renderBruteForce(context, this.transparentRenderers);
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        gl.depthMask(true);
    },
    _renderOITPass: function(context, scene, camera, renderColor) {
        var gl = context.gl;
        gl.depthMask(true);
        gl.colorMask(false, false, false, false);
        this.renderSolid(context, scene, camera);
        this.renderAlphaMapped(context, scene, camera);
        gl.colorMask(true, true, true, true);
        gl.depthFunc(gl.LESS);
        gl.enable(gl.DEPTH_TEST);
        if (scene.engine.options.transparencyMode == "blended") {
            if (renderColor) {
                gl.depthMask(false);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.enable(gl.BLEND);
                this.transparencyAccum.uniforms["render_mode"].value = 0;
            } else {
                gl.depthMask(false);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                this.transparencyAccum.uniforms["render_mode"].value = 1;
            }
        }
        if (scene.engine.options.transparencyMode == "stochastic") {
            if (renderColor) {
                gl.depthMask(true);
                this.transparencyAccum.uniforms["render_mode"].value = 3;
            } else {
                gl.depthMask(false);
                gl.blendEquation(gl.FUNC_ADD);
                gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
                gl.enable(gl.BLEND);
                this.transparencyAccum.uniforms["render_mode"].value = 1;
            }
        }
        for (var i in this.transparentRenderers) {
            var renderer = this.transparentRenderers[i];
            context.modelview.push();
            context.modelview.multiply(renderer.matrix);
            var uniforms = {};
            this._addUniforms(uniforms, renderer.material.uniforms);
            this._addUniforms(uniforms, renderer.getDefaultUniforms(context));
            this.transparencyAccum.bind(uniforms, renderer.material.samplers);
            renderer.renderGeometry(context, this.transparencyAccum.shader);
            this.transparencyAccum.unbind();
            context.modelview.pop();
        }
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        gl.depthMask(true);
    },
    renderOIT: function(context, scene, camera) {
        this.oitClearColor.set(0, 0, 0, 0);
        this.transparencyTarget.bind(context, false, this.oitClearColor);
        this._renderOITPass(context, scene, camera, true);
        this.transparencyTarget.unbind(context);
        this.oitClearColor.set(1, 1, 1, 1);
        this.transparencyWeight.bind(context, false, this.oitClearColor);
        this._renderOITPass(context, scene, camera, false);
        this.transparencyWeight.unbind(context);
    },
    onPostRender: function(context, scene, camera) {
        this.prepareShadowContext(context, scene);
        if (scene.engine.options.transparencyMode == "sorted") {
            camera.target.bind(context);
            this.renderSolid(context, scene, camera);
            this.renderTransparent(context, scene, camera);
            camera.target.unbind(context);
        } else if (scene.engine.options.transparencyMode == "blended" || scene.engine.options.transparencyMode == "stochastic") {
            camera.target.bind(context);
            this.renderSolid(context, scene, camera);
            this.renderAlphaMapped(context, scene, camera);
            camera.target.unbind(context);
            this.renderOIT(context, scene, camera);
        }
        context.shadow = false;
    }
});

var ShaderRenderStage = RenderStage.extend({
    init: function(shader, target) {
        this._super(target);
        this.shader = shader;
        this.uniforms = {};
    },
    onPostRender: function(context, scene, camera) {
        this.shader.use(this.uniforms);
        if (this.shader.requirements.transparent) {
            context.gl.blendFunc(context.gl.SRC_ALPHA, context.gl.ONE);
            context.gl.enable(context.gl.BLEND);
        }
        var renderers = scene.dynamicSpace.frustumCast(camera.frustum, camera.layerMask);
        for (var i in renderers) {
            renderers[i].renderGeometry(context, this.shader);
        }
        if (this.shader.requirements.transparent) {
            context.gl.disable(context.gl.BLEND);
        }
    }
});

var DebugRenderStage = RenderStage.extend({
    init: function(target, engine) {
        this._super(target);
        this.shader = engine.assetsManager.addShaderSource("shaders/default/debug");
        engine.assetsManager.load();
    },
    onPostRender: function(context, scene, camera) {
        var renderers = scene.dynamicSpace.frustumCast(camera.frustum, camera.layerMask);
        context.gl.blendFunc(context.gl.SRC_ALPHA, context.gl.ONE_MINUS_SRC_ALPHA);
        context.gl.enable(context.gl.BLEND);
        this.shader.use({
            color: new UniformVec4([ .5, 1, 0, .3 ])
        });
        var transparentRenderers = [];
        for (var i in renderers) {
            if (!renderers[i].transparent) {
                renderers[i].renderGeometry(context, this.shader);
                this.visibleSolidRenderers++;
            } else {
                transparentRenderers.push(renderers[i]);
            }
        }
        this.shader.use({
            color: new UniformVec4([ .5, .5, 1, .3 ])
        });
        for (var i in transparentRenderers) {
            transparentRenderers[i].renderGeometry(context, this.shader);
        }
        context.gl.disable(context.gl.BLEND);
    }
});

var ShadowMapRenderStage = RenderStage.extend({
    init: function(size) {
        this._super();
        this.target = false;
        this.shadowSampler = false;
        this.material = false;
        this.lightView = mat4.create();
        this.lightProj = mat4.create();
        this.size = 2048;
        this.active = false;
        if (size) this.size = size;
        this.lightPosition = vec3.create();
        this.blurProj = mat4.create();
        this.blurView = mat4.identity(mat4.create());
    },
    getFirstShadowCastingLight: function(scene) {
        for (var i in scene.lights) {
            if (scene.lights[i].shadowCasting === true) return scene.lights[i];
        }
        return false;
    },
    getSceneBounds: function(scene) {
        var bounds = new BoundingSphere();
        scene.root.onEachChild(function(subnode) {
            var meshRenderer = subnode.getComponent(MeshRendererComponent);
            if (meshRenderer && meshRenderer.enabled && meshRenderer.castShadows) bounds.encapsulateSphere(meshRenderer.getBoundingSphere());
        });
        return bounds;
    },
    renderShadows: function(context, scene, light) {
        var bounds = this.getSceneBounds(scene);
        mat4.ortho(this.lightProj, -bounds.radius, bounds.radius, -bounds.radius, bounds.radius, .1, bounds.radius * 2);
        vec3.scale(this.lightPosition, light.direction, bounds.radius);
        mat4.lookAt(this.lightView, this.lightPosition, [ 0, 0, 0 ], [ 0, 1, 0 ]);
        this.target.bind(context);
        var gl = context.gl;
        gl.depthMask(true);
        gl.clearDepth(1);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        context.projection.push();
        context.projection.load(this.lightProj);
        context.modelview.push();
        context.modelview.load(this.lightView);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LESS);
        this.material.uniforms["linearDepthConstant"].value = 1 / (bounds.radius * 2);
        this.material.bind();
        for (var i in this.parent.solidRenderers) {
            if (this.parent.solidRenderers[i].layer & light.shadowMask && this.parent.solidRenderers[i].visible && this.parent.solidRenderers[i].castShadows) {
                context.modelview.push();
                context.modelview.multiply(this.parent.solidRenderers[i].matrix);
                this.parent.solidRenderers[i].renderGeometry(context, this.material.shader);
                context.modelview.pop();
            }
        }
        for (var i in this.parent.transparentRenderers) {
            if (this.parent.transparentRenderers[i].layer & light.shadowMask && this.parent.transparentRenderers[i].visible && this.parent.transparentRenderers[i].castShadows) {
                context.modelview.push();
                context.modelview.multiply(this.parent.transparentRenderers[i].matrix);
                this.parent.transparentRenderers[i].renderGeometry(context, this.material.shader);
                context.modelview.pop();
            }
        }
        this.material.unbind();
        gl.depthMask(true);
        gl.disable(gl.DEPTH_TEST);
        context.modelview.pop();
        context.projection.pop();
        this.target.unbind(context);
    },
    blurShadows: function(context, target, source, orientation, kernelSize) {
        if (!this.gaussianBlurMaterial.shader.linked) return;
        var gl = context.gl;
        var size = target.getSize();
        mat4.ortho(this.blurProj, 0, size[0], size[1], 0, -10, 10);
        this.gaussianBlurMaterial.uniforms["screenWidth"].value = size[0];
        this.gaussianBlurMaterial.uniforms["screenHeight"].value = size[1];
        this.gaussianBlurMaterial.uniforms["orientation"].value = orientation;
        this.gaussianBlurMaterial.uniforms["kernelSize"].value = kernelSize;
        context.projection.push();
        context.projection.load(this.blurProj);
        context.modelview.push();
        context.modelview.load(this.blurView);
        target.bind(context);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        this.gaussianBlurMaterial.uniforms["modelview"].value = context.modelview.top();
        this.gaussianBlurMaterial.uniforms["projection"].value = context.projection.top();
        this.gaussianBlurMaterial.bind({}, [ source ]);
        var shader = this.gaussianBlurMaterial.shader;
        var locations = [];
        for (var bufferName in this.quad.buffers) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.buffers[bufferName]);
            var bufferLocation = gl.getAttribLocation(shader.program, bufferName);
            if (bufferLocation == -1) continue;
            gl.enableVertexAttribArray(bufferLocation);
            locations.push(bufferLocation);
            gl.vertexAttribPointer(bufferLocation, this.quad.buffers[bufferName].itemSize, gl.FLOAT, false, 0, 0);
        }
        this.quad.drawElements();
        for (var i in locations) gl.disableVertexAttribArray(locations[i]);
        this.gaussianBlurMaterial.unbind();
        target.unbind(context);
        context.modelview.pop();
        context.projection.pop();
    },
    onStart: function(context, engine) {
        this.target = new TargetTexture([ this.size, this.size ], context, false);
        this.shadowSampler = new Sampler("shadow0", this.target.texture);
        this.blurSampler = new Sampler("tex0", this.target.texture);
        this.helperTarget = new TargetTexture([ this.size, this.size ], context, false);
        this.helperTargetSampler = new Sampler("tex0", this.helperTarget.texture);
        this.material = new Material(engine.assetsManager.addShaderSource("DepthRGBA"), {
            linearDepthConstant: new UniformFloat(1),
            packingType: new UniformInt(2)
        }, []);
        this.gaussianBlurMaterial = new Material(engine.assetsManager.addShaderSource("GaussianBlur"), {
            screenWidth: new UniformFloat(1),
            screenHeight: new UniformFloat(1),
            orientation: new UniformInt(0),
            kernelSize: new UniformInt(5),
            modelview: new UniformMat4(false),
            projection: new UniformMat4(false)
        }, []);
        var vertices = [ 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0 ];
        var uvs = [ 0, 1, 0, 0, 1, 0, 1, 1 ];
        var faces = [ 0, 1, 2, 0, 2, 3 ];
        this.quad = new TrianglesRenderBuffer(context, faces);
        this.quad.add("position", vertices, 3);
        this.quad.add("texcoord2d0", uvs, 2);
        engine.assetsManager.load(function() {});
    },
    onPostRender: function(context, scene, camera) {
        this.active = false;
        if (!this.parent || !(this.parent instanceof MaterialRenderStage)) return;
        if (!this.target || !this.material) return;
        var light = this.getFirstShadowCastingLight(scene);
        if (!light) return;
        this.renderShadows(context, scene, light);
        this.blurShadows(context, this.helperTarget, this.blurSampler, 0, light.shadowBlurKernelSize);
        this.blurShadows(context, this.target, this.helperTargetSampler, 1, light.shadowBlurKernelSize);
        this.active = true;
    }
});

var PostProcessRenderStage = RenderStage.extend({
    init: function() {
        this._super();
        this.size = false;
        this.src = false;
        this.dst = false;
        this.srcSampler = false;
        this.dstSampler = false;
        this.quad = false;
        this.material = false;
        this.generator = this.getGeneratorStage();
        this.generator.parent = this;
    },
    setSize: function(width, height) {
        if (this.size === false) this.size = vec2.create();
        this.size[0] = width;
        this.size[1] = height;
    },
    getGeneratorStage: function() {
        return new MaterialRenderStage();
    },
    onStart: function(context, engine, camera) {
        if (!this.size) {
            this.size = vec2.clone(camera.target.size);
        }
        this.src = new TargetTexture(this.size, context, false);
        this.srcSampler = new Sampler("src", this.src.texture);
        this.dst = new TargetTexture(this.size, context, false);
        this.dstSampler = new Sampler("dst", this.dst.texture);
        this.material = new Material(engine.assetsManager.addShaderSource("shaders/default/ScreenQuad"), {}, []);
        var vertices = [ -1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0 ];
        var uv = [ 0, 0, 0, 1, 1, 1, 1, 0 ];
        var faces = [ 0, 1, 2, 0, 2, 3 ];
        this.quad = new TrianglesRenderBuffer(context, faces);
        this.quad.add("position", vertices, 3);
        this.quad.add("uv0", uv, 2);
        engine.assetsManager.load();
        this.generator.start(context, engine, camera);
    },
    onPreRender: function(context, scene, camera) {
        var cameraTarget = camera.target;
        if (this.substages.length > 0) {
            camera.target = this.src;
        }
        this.generator.render(context, scene, camera);
        camera.target = cameraTarget;
    },
    onPostRender: function(context, scene, camera) {
        if (this.substages.length == 0) return;
        this.renderEffect(context, this.material, this.srcSampler);
        this.swapBuffers();
    },
    swapBuffers: function() {
        var tmpTexture = this.src;
        var tmpSampler = this.srcSampler;
        this.src = this.dst;
        this.srcSampler = this.dstSampler;
        this.dst = tmpTexture;
        this.dstSampler = tmpSampler;
    },
    renderEffect: function(context, material, sampler) {
        var gl = context.gl;
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.CULL_FACE);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        material.bind({}, [ sampler ]);
        this.renderQuad(context, material.shader);
        material.unbind();
    },
    renderQuad: function(context, shader) {
        if (!shader.linked) return;
        var gl = context.gl;
        var locations = [];
        for (var bufferName in this.quad.buffers) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.buffers[bufferName]);
            var bufferLocation = gl.getAttribLocation(shader.program, bufferName);
            if (bufferLocation == -1) continue;
            gl.enableVertexAttribArray(bufferLocation);
            locations.push(bufferLocation);
            gl.vertexAttribPointer(bufferLocation, this.quad.buffers[bufferName].itemSize, gl.FLOAT, false, 0, 0);
        }
        this.quad.drawElements();
        for (var i in locations) gl.disableVertexAttribArray(locations[i]);
    }
});

var PostProcess = RenderStage.extend({
    init: function() {
        this._super();
        this.material = false;
    },
    onPostRender: function(context, scene, camera) {
        if (!(this.parent instanceof PostProcessRenderStage)) throw "PostProcess can only be the sub-stage of a PostProcessRenderStage";
        if (!this.material) throw "PostProcess must have a material defined";
        this.parent.dst.bind(context);
        this.parent.renderEffect(context, this.material, this.parent.srcSampler);
        this.parent.dst.unbind(context);
        this.parent.swapBuffers();
    }
});

var AntiAliasPostProcess = PostProcess.extend({
    init: function() {
        this._super();
    },
    onStart: function(context, engine) {
        this.material = new Material(engine.assetsManager.addShaderSource("shaders/default/postprocess_fxaa"), {
            ViewportSize: new UniformVec2(vec2.clone(this.parent.size)),
            reduce_min: new UniformFloat(1 / 16),
            reduce_mul: new UniformFloat(1 / 8),
            span_max: new UniformFloat(8)
        }, []);
        this.material.name = "AntiAlias";
        engine.assetsManager.load();
    }
});

var OITPostProcess = PostProcess.extend({
    init: function() {
        this._super();
    },
    onStart: function(context, engine) {
        this.material = new Material(engine.assetsManager.addShaderSource("shaders/default/OITRender"), {
            ViewportSize: new UniformVec2(vec2.clone(this.parent.size)),
            render_mode: new UniformInt(0)
        }, [ this.parent.generator.transparencySampler, this.parent.generator.transparencyWeightSampler ]);
        this.material.name = "OIT";
        engine.assetsManager.load();
    },
    onPreRender: function(context, scene, camera) {
        this._super(context, scene, camera);
        switch (scene.engine.options.transparencyMode) {
          case "blended":
            this.material.uniforms["render_mode"].value = 0;
            break;

          case "stochastic":
            this.material.uniforms["render_mode"].value = 1;
            break;
        }
    }
});

var RenderTarget = Class.extend({
    init: function(size) {
        this.size = vec2.create();
        if (size) vec2.copy(this.size, size);
    },
    bind: function(context) {
        context.gl.viewport(0, 0, this.size[0], this.size[1]);
    },
    unbind: function(context) {},
    setSize: function(width, height) {
        this.size[0] = width;
        this.size[1] = height;
    },
    getSize: function() {
        return this.size;
    }
});

var TargetScreen = RenderTarget.extend({
    init: function(size) {
        this._super(size);
        this.position = vec2.create();
    },
    setPosition: function(x, y) {
        this.position[0] = x;
        this.position[1] = y;
    },
    getPosition: function() {
        return this.position;
    },
    bind: function(context) {
        context.gl.viewport(0, 0, this.size[0], this.size[1]);
    },
    unbind: function(context) {}
});

var TargetTexture = RenderTarget.extend({
    init: function(sizeOrTexture, context, useDepthTexture) {
        var size = sizeOrTexture;
        if (sizeOrTexture instanceof Texture) {
            size = sizeOrTexture.size;
            this.texture = sizeOrTexture;
        }
        this.useDepthTexture = useDepthTexture === true;
        this._super(size);
        if (this.useDepthTexture) {
            var depthTextureExt = context.gl.getExtension("WEBGL_depth_texture") || context.gl.getExtension("WEBKIT_WEBGL_depth_texture");
            if (!depthTextureExt) throw "TargetTexture: Depth texture reqeusted, but not available.";
        }
        this.build(context);
    },
    build: function(context) {
        var gl = context.gl;
        this.frameBuffer = gl.createFramebuffer();
        if (!this.texture) {
            this.texture = new Texture(context);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size[0], this.size[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        if (this.useDepthTexture) {
            this.depth = new Texture(context);
            gl.bindTexture(gl.TEXTURE_2D, this.depth.glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, this.size[0], this.size[1], 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        } else {
            this.depth = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.size[0], this.size[1]);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.glTexture, 0);
        if (this.useDepthTexture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depth.glTexture, 0);
        } else {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth);
        }
        this.checkStatus(context);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this.texture.loaded = true;
    },
    checkStatus: function(context) {
        var gl = context.gl;
        var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        switch (status) {
          case gl.FRAMEBUFFER_COMPLETE:
            return true;

          case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT";

          case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";

          case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS";

          case gl.FRAMEBUFFER_UNSUPPORTED:
            throw "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED";

          default:
            throw "Incomplete framebuffer: " + status;
        }
    },
    bind: function(context, doNotClear, clearColor) {
        doNotClear = doNotClear === true;
        clearColor = clearColor instanceof Color ? clearColor : false;
        if (!clearColor) {
            if (context.camera) clearColor = context.camera.backgroundColor; else doNotClear = true;
        }
        context.gl.bindFramebuffer(context.gl.FRAMEBUFFER, this.frameBuffer);
        this._super(context);
        if (!doNotClear) {
            context.gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
            context.gl.clearDepth(1);
            context.gl.clear(context.gl.COLOR_BUFFER_BIT | context.gl.DEPTH_BUFFER_BIT);
        }
    },
    unbind: function(context) {
        this._super(context);
        context.gl.bindFramebuffer(context.gl.FRAMEBUFFER, null);
    }
});

var TargetTextureFloat = TargetTexture.extend({
    init: function(sizeOrTexture, context, useDepthTexture) {
        var floatTextureExt = !!context.gl.getExtension("OES_texture_float");
        if (!floatTextureExt) throw 'TargetTextureFloat: "OES_texture_float" WebGL extension is not supported on this system.';
        this._super(sizeOrTexture, context, useDepthTexture);
    },
    build: function(context) {
        var gl = context.gl;
        this.frameBuffer = gl.createFramebuffer();
        if (!this.texture) {
            this.texture = new Texture(context);
            gl.bindTexture(gl.TEXTURE_2D, this.texture.glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.size[0], this.size[1], 0, gl.RGBA, gl.FLOAT, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        }
        if (this.useDepthTexture) {
            this.depth = new Texture(context);
            gl.bindTexture(gl.TEXTURE_2D, this.depth.glTexture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT, this.size[0], this.size[1], 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_SHORT, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
        } else {
            this.depth = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, this.depth);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.size[0], this.size[1]);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.frameBuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.glTexture, 0);
        if (this.useDepthTexture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, this.depth.glTexture, 0);
        } else {
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depth);
        }
        this.checkStatus(context);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this.texture.loaded = true;
    }
});

var RenderBuffer = Class.extend({
    init: function(context, faces, type) {
        if (!type) type = context.gl.STATIC_DRAW;
        this.type = type;
        this.context = context;
        this.debug = false;
        this.buffers = {};
        this.maxFaceIndex = 0;
        for (var i in faces) this.maxFaceIndex = faces[i] > this.maxFaceIndex ? faces[i] : this.maxFaceIndex;
        this.createFacesBuffer(faces);
    },
    add: function(name, items, itemSize) {
        if (items.length / itemSize <= this.maxFaceIndex) throw "Buffer too small.";
        var gl = this.context.gl;
        this.buffers[name] = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers[name]);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(items), this.type);
        this.buffers[name].itemSize = itemSize;
        this.buffers[name].numItems = items.length / this.buffers[name].itemSize;
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
    },
    render: function(shader) {
        if (!shader.linked) return;
        var gl = this.context.gl;
        shader.requirements.apply(this);
        var locations = [];
        for (var bufferName in this.buffers) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers[bufferName]);
            var bufferLocation = gl.getAttribLocation(shader.program, bufferName);
            if (bufferLocation == -1) continue;
            gl.enableVertexAttribArray(bufferLocation);
            locations.push(bufferLocation);
            gl.vertexAttribPointer(bufferLocation, this.buffers[bufferName].itemSize, gl.FLOAT, false, 0, 0);
        }
        this.drawElements();
        for (var i = 0, l = locations.length; i < l; i++) {
            gl.disableVertexAttribArray(locations[i]);
        }
    },
    generateBarycentric: function() {
        var barycentric = new Float32Array(this.buffers["position"].numItems * 3);
        for (var i = 0; i < barycentric.length; i += 9) {
            barycentric[i + 0] = 1;
            barycentric[i + 1] = 0;
            barycentric[i + 2] = 0;
            barycentric[i + 3] = 0;
            barycentric[i + 4] = 1;
            barycentric[i + 5] = 0;
            barycentric[i + 6] = 0;
            barycentric[i + 7] = 0;
            barycentric[i + 8] = 1;
        }
        this.add("barycentric", barycentric, 3);
    },
    generateTexCoords: function() {
        var texcoords = new Float32Array(this.buffers["position"].numItems * 2);
        for (var i = 0; i < texcoords.length; i++) {
            texcoords[i] = 0;
        }
        this.add("texcoord2d0", texcoords, 2);
    },
    drawElements: function() {},
    createFacesBuffer: function(faces) {
        var gl = this.context.gl;
        this.facesBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.facesBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(faces), this.type);
        this.facesBuffer.itemSize = 1;
        this.facesBuffer.numItems = faces.length;
    }
});

var TrianglesRenderBuffer = RenderBuffer.extend({
    init: function(context, faces, type) {
        this._super(context, faces, type);
    },
    drawElements: function() {
        var gl = this.context.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.facesBuffer);
        gl.drawElements(gl.TRIANGLES, this.facesBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    }
});

var QuadsRenderBuffer = TrianglesRenderBuffer.extend({
    init: function(context, faces, type) {
        var triangles = [];
        for (var i = 0; i < faces.length - 3; i++) {
            triangles.push(faces[i]);
            triangles.push(faces[i + 1]);
            triangles.push(faces[i + 2]);
            triangles.push(faces[i]);
            triangles.push(faces[i + 2]);
            triangles.push(faces[i + 3]);
        }
        this._super(context, triangles, type);
    }
});

var Texture = Serializable.extend({
    init: function(context) {
        this.glTexture = false;
        this.name = false;
        this.size = false;
        this.mipmapped = true;
        this.loaded = false;
        if (context) this.create(context);
    },
    type: function() {
        return "Texture";
    },
    excluded: function() {
        return this._super().concat([ "glTexture", "context", "loaded", "size" ]);
    },
    create: function(context) {
        this.glTexture = context.gl.createTexture();
    },
    clearImage: function(context, color, size) {
        if (this.glTexture === false) this.create(context);
        size = size || 1;
        var gl = context.gl;
        gl.bindTexture(context.gl.TEXTURE_2D, this.glTexture);
        var data = new Uint8Array(size * size * 4);
        for (var i = 0; i < size * size * 4; i += 4) {
            data[i + 0] = color[0];
            data[i + 1] = color[1];
            data[i + 2] = color[2];
            data[i + 3] = color[3];
        }
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(context.gl.TEXTURE_2D, null);
        this.size = [ size, size ];
        this.loaded = true;
    },
    pasteImage: function(context, position, image) {
        if (!this.loaded) return;
        var gl = context.gl;
        this.bind(context);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, position[0] * this.size[0], position[1] * this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, image);
        if (this.mipmapped) gl.generateMipmap(gl.TEXTURE_2D);
        this.unbind(context);
        this.loaded = true;
    },
    setImage: function(context, inputImage) {
        if (this.glTexture === false) this.create(context);
        if (!this.glTexture) throw "Unable to update texture. glTexture not available.";
        var gl = context.gl;
        context.gl.bindTexture(context.gl.TEXTURE_2D, this.glTexture);
        var image = this.resizeToPowerOfTwo(inputImage);
        this.size = [ image.width, image.height ];
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        if (this.mipmapped) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
            gl.generateMipmap(gl.TEXTURE_2D);
        } else gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        context.gl.bindTexture(context.gl.TEXTURE_2D, null);
        if (image != inputImage) delete image;
        this.loaded = true;
    },
    getImage: function(context) {
        if (!this.glTexture) throw "Unable to get image. glTexture not available.";
        var gl = context.gl;
        var targetTexture = new TargetTexture(this, context, false);
        targetTexture.bind(context);
        var result = new Uint8Array(this.size[0] * this.size[1] * 4);
        context.gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
        targetTexture.unbind(context);
        return result;
    },
    bind: function(context) {
        if (!this.loaded) return;
        if ((this.size[0] & this.size[0] - 1) != 0 || (this.size[1] & this.size[1] - 1) != 0) {
            console.log("Not power of 2 texture: ", this.name, " (", this.size[0], "x", this.size[1]);
        }
        context.gl.bindTexture(context.gl.TEXTURE_2D, this.glTexture);
    },
    unbind: function(context) {
        if (!this.loaded) return;
        context.gl.bindTexture(context.gl.TEXTURE_2D, null);
    },
    resizeToPowerOfTwo: function(image) {
        function isPowerOfTwo(x) {
            return (x & x - 1) == 0;
        }
        function nextHighestPowerOfTwo(x) {
            return Math.max(Math.min(Math.pow(2, Math.ceil(Math.log(x) / Math.log(2))), 2048), 1);
        }
        function nextLowestPowerOfTwo(x) {
            return Math.max(Math.min(Math.pow(2, Math.floor(Math.log(x) / Math.log(2))), 2048), 1);
        }
        if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
            var canvas = document.createElement("canvas");
            canvas.width = nextLowestPowerOfTwo(image.width);
            canvas.height = nextLowestPowerOfTwo(image.height);
            var ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
            image = canvas;
        }
        return image;
    }
});

var Material = Serializable.extend({
    init: function(shader, uniforms, samplers, descriptor) {
        this._super();
        this.name = "Unnamed";
        this.shader = shader;
        this.uniforms = uniforms;
        this.samplers = samplers;
        this.descriptor = descriptor;
    },
    type: function() {
        return "Material";
    },
    bind: function(uniforms, samplers) {
        if (!this.shader) return;
        this.shader.use(this.uniforms);
        if (uniforms) this.shader.bindUniforms(uniforms);
        if ((!this.samplers || this.samplers.length == 0) && (!samplers || samplers.length == 0)) {
            if (this.shader.context.engine) this.shader.bindSamplers([ this.shader.context.engine.WhiteTextureSampler ]);
        } else {
            if (samplers) this.shader.bindSamplers(this.samplers.concat(samplers)); else this.shader.bindSamplers(this.samplers);
        }
    },
    unbind: function(samplers) {
        if (!this.shader) return;
        if ((!this.samplers || this.samplers.length == 0) && (!samplers || samplers.length == 0)) {
            if (this.shader.context.engine) this.shader.unbindSamplers([ this.shader.context.engine.WhiteTextureSampler ]);
        } else {
            if (samplers) this.shader.unbindSamplers(this.samplers.concat(samplers)); else this.shader.unbindSamplers(this.samplers);
        }
    },
    instantiate: function() {
        var uniforms = {};
        for (var u in this.uniforms) {
            uniforms[u] = this.uniforms[i].clone();
        }
        var samplers = [];
        for (var s in this.samplers) {
            samplers.push(this.samplers[s].clone());
        }
        var copy = new Material(this.shader, uniforms, samplers, this.descriptor);
        copy.name = this.name + " (instance)";
        return copy;
    }
});

var Space = Class.extend({
    init: function() {},
    frustumCast: function(frustum, layerMask) {},
    rayCast: function(ray) {},
    lineCast: function(line) {}
});

var DynamicSpace = Space.extend({
    init: function() {
        this.renderers = [];
        this.colliders = [];
    },
    addRenderer: function(renderer) {
        this.renderers.push(renderer);
    },
    removeRenderer: function(renderer) {
        for (var i in this.renderers) {
            if (this.renderers[i] === renderer) {
                this.renderers.splice(i, 1);
                return true;
            }
        }
        return false;
    },
    addCollider: function(collider) {
        this.colliders.push(collider);
    },
    removeCollider: function(collider) {
        for (var i in this.colliders) {
            if (this.colliders[i] === collider) {
                this.colliders.splice(i, 1);
                return true;
            }
        }
        return false;
    },
    frustumCast: function(frustum, layerMask) {
        var ret = [];
        for (var i in this.renderers) {
            if (this.renderers[i].visible && this.renderers[i].layer & layerMask) ret.push(this.renderers[i]);
        }
        return ret;
    },
    rayCast: function(ray, layerMask, collideInvisible) {
        var result = new RayTestResult(ray);
        if (!layerMask) return result;
        for (var i in this.colliders) {
            if (!this.colliders[i].enabled) continue;
            if (this.colliders[i].node.layer & layerMask) {
                this.colliders[i].rayTest(ray, result, collideInvisible);
            }
        }
        return result;
    }
});

var Renderer = Class.extend({
    init: function(matrix) {
        this.matrix = matrix;
        this.layer = 1;
        this.visible = true;
        this.castShadows = true;
        this.transparent = false;
        this.localBoundingBox = new BoundingBox();
        this.localBoundingSphere = new BoundingSphere();
        this.globalBoundingBox = new BoundingBox();
        this.globalBoundingSphere = new BoundingSphere();
        this.cacheMatrix = mat4.create();
    },
    render: function(context, pass) {
        this.onRender(context, pass);
    },
    renderGeometry: function(context, shader) {
        this.onRenderGeometry(context, shader);
    },
    getDefaultUniforms: function(context) {
        var date = new Date();
        var time = date.getTime();
        var uniforms = {
            time: new UniformFloat(time),
            model: new UniformMat4(this.matrix),
            modelview: new UniformMat4(context.modelview.top()),
            modelviewInverse: new UniformMat4(mat4.invert(mat4.create(), context.modelview.top())),
            projection: new UniformMat4(context.projection.top())
        };
        if (context.camera) {
            uniforms.view = new UniformMat4(context.camera.viewMatrix);
            uniforms.viewInverse = new UniformMat4(context.camera.viewInverseMatrix);
            if (context.camera.near) uniforms.zNear = new UniformFloat(context.camera.near);
            if (context.camera.far) uniforms.zFar = new UniformFloat(context.camera.far);
        }
        if (context.light) {
            uniforms.lightDirection = new UniformVec3(context.light.direction);
            uniforms.lightColor = new UniformColor(context.light.color);
            uniforms.lightIntensity = new UniformFloat(context.light.intensity);
        }
        if (context.shadow) {
            uniforms.linearDepthConstant = context.shadow.linearDepthConstant;
            uniforms.lightView = context.shadow.lightView;
            uniforms.lightProjection = context.shadow.lightProjection;
            uniforms.shadowIntensity = context.shadow.shadowIntensity;
        }
        return uniforms;
    },
    getGlobalSamplers: function(context) {
        var samplers = [];
        if (context.shadow) {
            samplers.push(context.shadow.shadow0);
        }
        return samplers;
    },
    setMatrix: function(matrix) {
        this.matrix = matrix;
        this.updateGlobalBoundingVolumes();
    },
    updateGlobalBoundingVolumes: function() {
        this.globalBoundingBox = this.localBoundingBox.transform(this.matrix);
        this.globalBoundingSphere = this.localBoundingSphere.transform(this.matrix);
    },
    onRender: function(context, pass) {},
    onRenderGeometry: function(context, shader) {}
});

var PrimitiveRenderer = Renderer.extend({
    init: function(matrix, material) {
        this._super(matrix);
        this.material = material;
    }
});

var MeshRenderer = Renderer.extend({
    init: function(context, matrix, mesh) {
        this._super(matrix);
        this.mesh = mesh;
        this.buffers = [];
        for (var submeshIndex in this.mesh.submeshes) {
            var submesh = this.mesh.submeshes[submeshIndex];
            var renderBuffer = new TrianglesRenderBuffer(context, submesh.faces);
            renderBuffer.add("position", submesh.positions, 3);
            for (var texCoords1DIndex in submesh.texCoords1D) {
                renderBuffer.add("texcoord1d" + texCoords1DIndex, submesh.texCoords1D[texCoords1DIndex], 1);
            }
            for (var texCoords2DIndex in submesh.texCoords2D) {
                renderBuffer.add("texcoord2d" + texCoords2DIndex, submesh.texCoords2D[texCoords2DIndex], 2);
            }
            for (var texCoords3DIndex in submesh.texCoords3D) {
                renderBuffer.add("texcoord3d" + texCoords3DIndex, submesh.texCoords3D[texCoords3DIndex], 3);
            }
            if (submesh.normals) renderBuffer.add("normal", submesh.normals, 3);
            if (submesh.tangents) renderBuffer.add("tangent", submesh.tangents, 3);
            if (submesh.bitangents) renderBuffer.add("bitangent", submesh.bitangents, 3);
            this.buffers.push(renderBuffer);
        }
    },
    onRender: function(context) {
        var uniforms = this.getDefaultUniforms(context);
        for (var submeshIndex in this.mesh.submeshes) {
            var submesh = this.mesh.submeshes[submeshIndex];
            console.log("rendering submesh: ", submesh);
            var material = this.mesh.getMaterial(submesh.materialIndex);
            if (!material) continue;
            material.bind(uniforms);
            this.buffers[submeshIndex].render(material.shader);
            material.unbind();
        }
    },
    onRenderGeometry: function(context, shader) {
        shader.bindUniforms(this.getDefaultUniforms(context));
        for (var i in this.buffers) {
            this.buffers[i].render(shader);
        }
    }
});

var SubmeshRenderer = Renderer.extend({
    init: function(context, matrix, submesh, material) {
        this._super(matrix);
        this.submesh = submesh;
        this.material = material;
        this.buffer = [];
        this.localBoundingBox = this.submesh.boundingBox;
        this.localBoundingSphere = this.submesh.boundingSphere;
        this.updateGlobalBoundingVolumes();
        this.buffer = new TrianglesRenderBuffer(context, submesh.faces);
        this.buffer.add("position", submesh.positions, 3);
        for (var texCoords1DIndex in submesh.texCoords1D) {
            if (submesh.positions.length / 3 != submesh.texCoords1D[texCoords1DIndex].length) {
                console.log("Wrong number of texture coordinates 1. Must be the same as positions.");
                continue;
            }
            this.buffer.add("texcoord1d" + texCoords1DIndex, submesh.texCoords1D[texCoords1DIndex], 1);
        }
        for (var texCoords2DIndex in submesh.texCoords2D) {
            if (submesh.positions.length / 3 != submesh.texCoords2D[texCoords2DIndex].length / 2) {
                console.log("Wrong number of texture coordinates 2 (" + submesh.texCoords2D[texCoords2DIndex].length + "). Must be the same as positions (" + submesh.positions.length + ").");
                continue;
            }
            this.buffer.add("texcoord2d" + texCoords2DIndex, submesh.texCoords2D[texCoords2DIndex], 2);
        }
        for (var texCoords3DIndex in submesh.texCoords3D) {
            if (submesh.positions.length != submesh.texCoords3D[texCoords3DIndex].length) {
                console.log("Wrong number of texture coordinates 3. Must be the same as positions.");
                continue;
            }
            this.buffer.add("texcoord3d" + texCoords3DIndex, submesh.texCoords3D[texCoords3DIndex], 3);
        }
        if (submesh.normals) {
            if (submesh.positions.length != submesh.normals.length) {
                console.log("Wrong number of normals. Must be the same as positions.");
            } else {
                this.buffer.add("normal", submesh.normals, 3);
            }
        }
        if (submesh.tangents) {
            if (submesh.positions.length != submesh.tangents.length) {
                console.log("Wrong number of tangents. Must be the same as positions.");
            } else {
                this.buffer.add("tangent", submesh.tangents, 3);
            }
        }
        if (submesh.bitangents) {
            if (submesh.positions.length != submesh.bitangents.length) {
                console.log("Wrong number of bitangents. Must be the same as positions.");
            } else {
                this.buffer.add("bitangent", submesh.bitangents, 3);
            }
        }
        if (!material.uniforms.diffuse) material.uniforms.diffuse = new UniformColor(new Color(1, 1, 1, 1));
        if (!material.uniforms.ambient) material.uniforms.ambient = new UniformColor(new Color(.2, .2, .2, 1));
        this.transparent = material.shader.requirements.transparent || material.uniforms["diffuse"] && material.uniforms["diffuse"].value[3] < 1 || material.uniforms["ambient"] && material.uniforms["ambient"].value[3] < 1;
        this.failed = false;
    },
    onRender: function(context) {
        try {
            this.buffer.render(this.material.shader);
        } catch (e) {
            if (this.failed) return;
            this.failed = true;
            console.log("Failed to render buffer: ", this.buffer);
            console.log("material: ", this.material.name, this.material);
            console.log("positions: ", this.submesh.positions.length);
            console.log("normals: ", this.submesh.normals.length);
            console.log("texcoords: ", this.submesh.texCoords2D);
            console.log("faces: ", this.submesh.faces.length);
            console.log(e);
        }
    },
    onRenderGeometry: function(context, shader) {
        shader.bindUniforms(this.getDefaultUniforms(context));
        this.buffer.render(shader);
    }
});

var FontRenderer = SubmeshRenderer.extend({
    init: function(context, matrix, submesh, material) {
        this._super(context, matrix, submesh, material);
        this.fontData = false;
    },
    onRender: function(context) {
        var globalSamplers = this.getGlobalSamplers(context);
        var uniforms = this.getDefaultUniforms(context);
        uniforms["page"] = this.submesh.page;
        this.material.bind(uniforms, this.material.samplers);
        try {
            this.buffer.render(this.material.shader);
        } catch (e) {
            if (this.failed) return;
            this.failed = true;
            console.log("Failed to render buffer: ", this.buffer);
            console.log("material: ", this.material.name, this.material);
            console.log("positions: ", this.submesh.positions.length);
            console.log("normals: ", this.submesh.normals.length);
            console.log("texcoords: ", this.submesh.texCoords2D);
            console.log("faces: ", this.submesh.faces.length);
            console.log(e);
        }
        this.material.unbind(globalSamplers);
    }
});

var CubeRenderer = PrimitiveRenderer.extend({
    init: function(context, matrix, size, material) {
        console.log("Cube renderer: ", matrix);
        this._super(matrix, material);
        this.size = size;
        var halfsize = this.size / 2;
        var vertices = [ -halfsize, -halfsize, halfsize, halfsize, -halfsize, halfsize, halfsize, -halfsize, -halfsize, -halfsize, -halfsize, -halfsize, -halfsize, halfsize, halfsize, halfsize, halfsize, halfsize, halfsize, halfsize, -halfsize, -halfsize, halfsize, -halfsize ];
        var faces = [ 0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 5, 4, 1, 2, 6, 5, 2, 3, 7, 6, 3, 0, 0, 7 ];
        this.renderBuffer = new QuadsRenderBuffer(context, faces);
        this.renderBuffer.add("position", vertices, 3);
    },
    onRender: function(context) {
        this.material.bind({
            modelview: new UniformMat4(context.modelview.top()),
            projection: new UniformMat4(context.projection.top())
        });
        this.renderBuffer.render(this.material.shader);
        this.material.unbind();
    }
});

var FontData = Class.extend({
    init: function(xmlData) {
        this.xmlData = xmlData;
        var common = $(xmlData).find("font common");
        this.width = parseInt(common.attr("scaleW"));
        this.height = parseInt(common.attr("scaleH"));
        this.size = vec2.fromValues(this.width, this.height);
        this.lineHeight = parseInt(common.attr("lineHeight"));
        this.baseline = parseInt(common.attr("base"));
        this.characters = {};
        this.kernings = {};
        var me = this;
        $(xmlData).find("font chars char").each(function() {
            me.characters[$(this).attr("id")] = {
                position: vec2.fromValues($(this).attr("x"), $(this).attr("y")),
                size: vec2.fromValues(parseInt($(this).attr("width")), parseInt($(this).attr("height"))),
                offset: vec2.fromValues($(this).attr("xoffset"), $(this).attr("yoffset")),
                normalizedPosition: vec2.fromValues($(this).attr("x") / me.width, 1 - $(this).attr("y") / me.height - $(this).attr("height") / me.height),
                normalizedSize: vec2.fromValues(-$(this).attr("width") / me.width, -$(this).attr("height") / me.height),
                xadvance: $(this).attr("xadvance"),
                page: $(this).attr("page")
            };
        });
        $(xmlData).find("font kernings kerning").each(function() {
            if (!me.kernings[$(this).attr("first")]) me.kernings[$(this).attr("first")] = {};
            me.kernings[$(this).attr("first")][$(this).attr("second")] = parseInt($(this).attr("amount"));
        });
    }
});

var Font = Class.extend({
    init: function(materialSource, descriptor) {
        this.data = false;
        this.materialSource = materialSource;
        this.descriptor = descriptor;
    }
});

function DownloadBinary(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "arraybuffer";
    xhr.onload = function() {
        if (this.status == 200) callback(this.response); else callback(false);
    };
    xhr.send();
}

var DataParserTypes = {
    NODE_ROOT: 4096,
    NODE_STRING: 4097,
    NODE_MATRIX3X3: 4098,
    NODE_MATRIX4X4: 4099,
    NODE_MATERIALS: 8192,
    NODE_MATERIAL: 8193,
    NODE_COLOR_AMBIENT: 8194,
    NODE_COLOR_DIFFUSE: 8195,
    NODE_COLOR_SPECULAR: 8196,
    NODE_COLOR_EMISSIVE: 8197,
    NODE_TWOSIDED: 8198,
    NODE_SHININESS: 8199,
    NODE_SHININESS_STRENGTH: 8200,
    NODE_TEXTURES_AMBIENT: 8272,
    NODE_TEXTURES_DIFFUSE: 8273,
    NODE_TEXTURES_SPECULAR: 8274,
    NODE_TEXTURES_EMISSIVE: 8275,
    NODE_TEXTURES_NORMALS: 8276,
    NODE_TEXTURES_HEIGHT: 8277,
    NODE_TEXTURES_SHININESS: 8278,
    NODE_TEXTURES_OPACITY: 8279,
    NODE_TEXTURES_DISPLACEMENT: 8280,
    NODE_TEXTURES_LIGHTMAP: 8281,
    NODE_TEXTURES_REFLECTION: 8282,
    NODE_TEXTURE: 8448,
    NODE_TEXTURE_SCALE: 8449,
    NODE_SHADER_NAME: 8704,
    NODE_GEOMETRY: 12288,
    NODE_MESH: 12544,
    NODE_MATERIAL_REFERENCE: 12545,
    NODE_VERTICES: 12546,
    NODE_NORMALS: 12547,
    NODE_TANGENTS: 12548,
    NODE_BITANGENTS: 12549,
    NODE_TEXTURE_COORDINATES: 12550,
    NODE_FACES: 12551,
    NODE_SCENE: 16384,
    NODE_GROUP: 16385,
    NODE_MESH_REFERENCE: 16386,
    NODE_TRANSFORM_POSITION: 16387,
    NODE_TRANSFORM_ROTATION: 16388,
    NODE_TRANSFORM_SCALE: 16389,
    NODE_GROUP_ID: 16390,
    NODE_COLLISION: 20480,
    NODE_COLLISION_NODE: 20481,
    NODE_COLLISION_AABB_CENTER: 20482,
    NODE_COLLISION_AABB_EXTENTS: 20483,
    NODE_COLLISION_FACE_LIST: 20484,
    NODE_FACE_LIST_NODE_ID: 20496,
    NODE_FACE_LIST_MESH_REFERENCE: 20497,
    NODE_FACE_LIST_INDICES: 20498,
    getName: function(value) {
        for (var name in DataParserTypes) {
            if (DataParserTypes[name] === value) return name;
        }
        return false;
    }
};

var DataParserNode = function(id, length, position) {
    this.id = id;
    this.length = length;
    this.position = position;
    this.HEADER_LENGTH = 8;
    this.end = function() {
        return this.position + this.HEADER_LENGTH + this.length;
    };
};

var DataParserResult = Class.extend({
    init: function() {
        this.data = {
            meshes: [],
            materials: [],
            hierarchy: false,
            collision: false,
            hierarchyNodesByID: {}
        };
    },
    getData: function() {
        return this.data;
    },
    linkReferences: function() {
        for (var i in this.data.meshes) {
            if (this.data.meshes[i].material != -1 && this.data.meshes[i].material in this.data.materials) this.data.meshes[i].material = this.data.materials[this.data.meshes[i].material];
        }
        if (this.data.hierarchy !== false) {
            var scope = this;
            var linkMeshesToGroups = function(group) {
                for (var i in group.meshes) {
                    if (group.meshes[i] >= 0 && group.meshes[i] in scope.data.meshes) group.meshes[i] = scope.data.meshes[group.meshes[i]];
                }
                for (var j in group.children) {
                    linkMeshesToGroups(group.children[j]);
                }
            };
            linkMeshesToGroups(this.data.hierarchy);
        }
    },
    createGroup: function() {
        return {
            name: "",
            id: false,
            parent: false,
            children: [],
            meshes: [],
            position: {
                x: 0,
                y: 0,
                z: 0
            },
            rotation: {
                x: 0,
                y: 0,
                z: 0,
                w: 0
            },
            scale: {
                x: 0,
                y: 0,
                z: 0
            },
            transform: false
        };
    },
    mapGroupID: function(group) {
        this.data.hierarchyNodesByID[group.id] = group;
    },
    setRoot: function(group) {
        this.data.hierarchy = group;
    },
    createMaterialTexture: function() {
        return {
            path: false,
            scale: {
                u: 1,
                v: 1,
                w: 1
            }
        };
    },
    createMaterial: function() {
        return {
            name: "",
            color: {
                ambient: false,
                diffuse: false,
                specular: false,
                emissive: false
            },
            twosided: false,
            shininess: 0,
            shininess_strength: 0,
            shader: false,
            textures: {
                ambient: [],
                diffuse: [],
                specular: [],
                emissive: [],
                normals: [],
                height: [],
                shininess: [],
                opacity: [],
                displacement: [],
                lightmap: [],
                reflection: []
            }
        };
    },
    addMaterial: function(material) {
        this.data.materials.push(material);
    },
    getMaterial: function(index) {
        if (index >= 0 && index < this.data.materials.length) return this.data.materials[index];
        return false;
    },
    createMesh: function(numPoints) {
        var mesh = {
            index: -1,
            material: -1,
            indices: [],
            vertices: []
        };
        for (var i = 0; i < numPoints; i++) mesh.vertices.push(this.createVertex());
        return mesh;
    },
    createVertex: function() {
        return {
            position: {
                x: 0,
                y: 0,
                z: 0
            },
            normal: {
                x: 0,
                y: 0,
                z: 0
            },
            texCoord: [],
            tangent: {
                x: 0,
                y: 0,
                z: 0
            },
            bitangent: {
                x: 0,
                y: 0,
                z: 0
            }
        };
    },
    addMesh: function(mesh) {
        this.data.meshes.push(mesh);
        mesh.index = this.data.meshes.length - 1;
    },
    createCollisionTreeNode: function() {
        return {
            parent: false,
            children: [],
            center: {
                x: 0,
                y: 0,
                z: 0
            },
            extents: {
                x: 0,
                y: 0,
                z: 0
            },
            faces: false
        };
    },
    addFaceList: function(collisionNode, nodeID, meshID, indices) {
        if (nodeID < 0 || meshID < 0 || indices.length == 0) return false;
        if (collisionNode.faces === false) collisionNode.faces = {};
        if (!(nodeID in collisionNode.faces)) collisionNode.faces[nodeID] = {};
        if (!(meshID in collisionNode.faces[nodeID])) collisionNode.faces[nodeID][meshID] = [];
        collisionNode.faces[nodeID][meshID] = collisionNode.faces[nodeID][meshID].concat(indices);
        return true;
    },
    setCollisionTreeRoot: function(node) {
        this.data.collision = node;
    }
});

var DataParser = Class.extend({
    init: function(data, cbOnComplete, cbOnError, cbOnProgress, userdata) {
        this.VERSION = 1;
        this.view = new jDataView(data);
        this.onComplete = cbOnComplete;
        this.onProgress = cbOnProgress;
        this.onError = cbOnError;
        this.userdata = userdata;
        this.result = new DataParserResult();
        this.errors = [];
        this.stack = [];
        this.linkReferences = true;
        this.flipX = false;
        this.warnOnUnknownChunks = true;
    },
    parse: function() {
        this.push(false, this.parseHeader);
        while (!this.completed()) {
            if (!this.step()) {
                if ($.isFunction(this.onError)) this.onError(this.errors, this.userdata);
                return false;
            }
        }
        if (this.linkReferences) this.result.linkReferences();
        if ($.isFunction(this.onComplete)) this.onComplete(this.result.getData(), this.userdata);
        return true;
    },
    error: function(msg) {
        this.errors.push(msg);
        return false;
    },
    errorExpect: function(bytes, parameter) {
        return this.error("Expected at least " + bytes + " byte" + (bytes > 1 ? "s" : "") + ' for "' + parameter + '"');
    },
    completed: function() {
        if (this.view.tell() == this.view.byteLength) return true;
        return false;
    },
    step: function() {
        var call = this.getCurrentCall();
        if (call) {
            var ret = call(this.getCurrentNode());
            if ($.isFunction(this.onProgress)) this.onProgress(this.view.tell() / this.view.byteLength * 100, this.userdata);
            return ret;
        }
        return false;
    },
    push: function(node, call) {
        this.stack.push({
            node: node,
            call: ClassCallback(this, call)
        });
    },
    pop: function() {
        this.stack.pop();
    },
    getCurrentNode: function() {
        if (this.stack.length > 0) return this.stack[this.stack.length - 1].node;
        return false;
    },
    getCurrentCall: function() {
        if (this.stack.length > 0) return this.stack[this.stack.length - 1].call;
        return false;
    },
    hasDataFor: function(numBytes) {
        if (this.view.byteLength < this.view.tell() + numBytes) return false;
        return true;
    },
    hasDataForNode: function(node) {
        if (this.view.byteLength < node.position + node.length + 8) return false;
        return true;
    },
    getUint32: function() {
        return this.view.getUint32(this.view.tell(), true);
    },
    getFloat32: function() {
        return this.view.getFloat32(this.view.tell(), true);
    },
    getMatrix4x4: function() {
        var mat = [];
        for (var i = 0; i < 4; i++) {
            mat.push([ this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32() ]);
        }
        return mat;
    },
    getColor: function() {
        return {
            r: this.view.getFloat32(this.view.tell(), true),
            g: this.view.getFloat32(this.view.tell(), true),
            b: this.view.getFloat32(this.view.tell(), true),
            a: this.view.getFloat32(this.view.tell(), true)
        };
    },
    parseHeader: function() {
        if (!this.view) return this.error("No data to parse");
        if (!this.parseSignature()) return false;
        var rootNode = this.parseNodeHeader();
        if (rootNode === false) return false;
        if (rootNode.id !== DataParserTypes.NODE_ROOT) return this.error("Root node type is incorrect");
        this.push(rootNode, this.parseRoot);
        return true;
    },
    parseSignature: function() {
        if (!this.hasDataFor(12)) return this.error("Not enough data for 3DTech DATA format header");
        var sig = this.view.getString(10);
        if (sig != "3DTECHDATA") return this.error("The data is not in 3DTech DATA format");
        var version = this.view.getInt16(this.view.tell(), true);
        if (version != this.VERSION) return this.error("Incompatible version");
        if (!this.hasDataFor(8)) return this.error("Could not find root node");
        return true;
    },
    parseNodeHeader: function() {
        if (!this.hasDataFor(8)) return this.error("Not enough data for parsing node header");
        var position = this.view.tell();
        var id = this.getUint32();
        var length = this.getUint32();
        return new DataParserNode(id, length, position);
    },
    skipNode: function(node) {
        if (this.warnOnUnknownChunks) console.log("DataParser: skipping node ", DataParserTypes.getName(node.id));
        this.view.seek(this.view.tell() + node.length);
    },
    parseMaterial: function(materialNode) {
        var material = this.result.createMaterial();
        while (this.view.tell() < materialNode.end()) {
            var param = this.parseNodeHeader();
            switch (param.id) {
              case DataParserTypes.NODE_STRING:
                material.name = this.view.getString(param.length);
                break;

              case DataParserTypes.NODE_SHADER_NAME:
                material.shader = this.view.getString(param.length);
                break;

              case DataParserTypes.NODE_COLOR_AMBIENT:
                if (param.length != 16) return this.error("Ambient color corrupted");
                material.color.ambient = this.getColor();
                break;

              case DataParserTypes.NODE_COLOR_DIFFUSE:
                if (param.length != 16) return this.error("Diffuse color corrupted");
                material.color.diffuse = this.getColor();
                break;

              case DataParserTypes.NODE_COLOR_SPECULAR:
                if (param.length != 16) return this.error("Specular color corrupted");
                material.color.specular = this.getColor();
                break;

              case DataParserTypes.NODE_COLOR_EMISSIVE:
                if (param.length != 16) return this.error("Emissive color corrupted");
                material.color.emissive = this.getColor();
                break;

              case DataParserTypes.NODE_TWOSIDED:
                if (param.length < 1) return this.errorExpect(1, "material.twosided");
                var twosided = this.view.getChar();
                material.twosided = twosided == 255 ? true : false;
                break;

              case DataParserTypes.NODE_SHININESS:
                if (param.length < 4) return this.errorExpect(4, "material.shininess");
                material.shininess = this.getFloat32();
                break;

              case DataParserTypes.NODE_SHININESS_STRENGTH:
                if (param.length < 4) return this.errorExpect(4, "material.shininess_strength");
                material.shininess_strength = this.getFloat32();
                break;

              case DataParserTypes.NODE_TEXTURES_AMBIENT:
                this.parseMaterialTextures(param, material.textures.ambient);
                break;

              case DataParserTypes.NODE_TEXTURES_DIFFUSE:
                this.parseMaterialTextures(param, material.textures.diffuse);
                break;

              case DataParserTypes.NODE_TEXTURES_SPECULAR:
                this.parseMaterialTextures(param, material.textures.specular);
                break;

              case DataParserTypes.NODE_TEXTURES_EMISSIVE:
                this.parseMaterialTextures(param, material.textures.emissive);
                break;

              case DataParserTypes.NODE_TEXTURES_NORMALS:
                this.parseMaterialTextures(param, material.textures.normals);
                break;

              case DataParserTypes.NODE_TEXTURES_HEIGHT:
                this.parseMaterialTextures(param, material.textures.height);
                break;

              case DataParserTypes.NODE_TEXTURES_SHININESS:
                this.parseMaterialTextures(param, material.textures.shininess);
                break;

              case DataParserTypes.NODE_TEXTURES_OPACITY:
                this.parseMaterialTextures(param, material.textures.opacity);
                break;

              case DataParserTypes.NODE_TEXTURES_DISPLACEMENT:
                this.parseMaterialTextures(param, material.textures.displacement);
                break;

              case DataParserTypes.NODE_TEXTURES_LIGHTMAP:
                this.parseMaterialTextures(param, material.textures.lightmap);
                break;

              case DataParserTypes.NODE_TEXTURES_REFLECTION:
                this.parseMaterialTextures(param, material.textures.reflection);
                break;

              default:
                this.skipNode(param);
                break;
            }
        }
        this.result.addMaterial(material);
        return true;
    },
    parseMaterialTextures: function(texturesNode, list) {
        while (this.view.tell() < texturesNode.end()) {
            var textureNode = this.parseNodeHeader();
            if (textureNode.id == DataParserTypes.NODE_TEXTURE) {
                var texture = this.result.createMaterialTexture();
                while (this.view.tell() < textureNode.end()) {
                    var node = this.parseNodeHeader();
                    switch (node.id) {
                      case DataParserTypes.NODE_STRING:
                        texture.path = this.view.getString(node.length);
                        break;

                      case DataParserTypes.NODE_TEXTURE_SCALE:
                        if (node.length != 12) return this.error("Texture scale is corrupted");
                        texture.scale.u = this.getFloat32();
                        texture.scale.v = this.getFloat32();
                        texture.scale.w = this.getFloat32();
                        break;

                      default:
                        this.skipNode(node);
                        break;
                    }
                }
                if (texture.path !== false) list.push(texture);
            } else {
                this.skipNode(textureNode);
            }
        }
        return true;
    },
    parseMaterials: function(materialsNode) {
        if (!this.hasDataForNode(materialsNode)) {
            return this.error("Not enough data for node '" + DataParserTypes.getName(materialsNode.id) + "'");
        }
        while (this.view.tell() < materialsNode.end()) {
            var node = this.parseNodeHeader();
            if (node.id == DataParserTypes.NODE_MATERIAL) {
                this.parseMaterial(node);
            } else {
                this.skipNode(node);
            }
        }
        this.pop();
        return true;
    },
    parseGeometry: function(geometryNode) {
        if (!this.hasDataForNode(geometryNode)) return this.error("Not enough data for node '" + DataParserTypes.getName(geometryNode.id) + "'");
        if (this.view.tell() >= geometryNode.end()) {
            this.pop();
            return true;
        }
        var meshNode = this.parseNodeHeader();
        if (meshNode.id == DataParserTypes.NODE_MESH) {
            if (!this.hasDataForNode(meshNode)) return this.error("Not enough data for node '" + DataParserTypes.getName(meshNode.id) + "'");
            this.push(meshNode, this.parseMesh);
        } else this.skipNode(meshNode);
        return true;
    },
    parseMesh: function(meshNode) {
        var numPoints = this.getUint32();
        var mesh = this.result.createMesh(numPoints);
        var texCoordSetIndex = 0;
        var noScale = [ 1, 1, 1 ];
        var flipScale = [ 1, 1, 1 ];
        if (this.flipX) flipScale[0] = -1;
        while (this.view.tell() < meshNode.end()) {
            var node = this.parseNodeHeader();
            if (!this.hasDataForNode(node)) return this.error("Not enough data for node '" + DataParserTypes.getName(node.id) + "'");
            switch (node.id) {
              case DataParserTypes.NODE_MATERIAL_REFERENCE:
                if (node.length < 4) return this.errorExpect(4, "mesh.material_reference");
                mesh.material = this.getUint32();
                break;

              case DataParserTypes.NODE_VERTICES:
                if (!this.parseVertices(node, numPoints, mesh.vertices, "position", flipScale)) return false;
                break;

              case DataParserTypes.NODE_NORMALS:
                if (!this.parseVertices(node, numPoints, mesh.vertices, "normal", noScale)) return false;
                break;

              case DataParserTypes.NODE_TANGENTS:
                if (!this.parseVertices(node, numPoints, mesh.vertices, "tangent", noScale)) return false;
                break;

              case DataParserTypes.NODE_BITANGENTS:
                if (!this.parseVertices(node, numPoints, mesh.vertices, "bitangent", noScale)) return false;
                break;

              case DataParserTypes.NODE_TEXTURE_COORDINATES:
                if (node.length < 4) return this.errorExpect(4, "mesh texture coordinates component count");
                var numComponents = this.getUint32();
                if (numComponents == 0 || numComponents > 3) return this.error("Unsupported number of texture coordinate components: " + numComponents);
                if (node.length - 4 != numComponents * numPoints * 4) return this.error("Texture coordinate set " + texCoordSetIndex + " is corrupted");
                var labels = [ "x", "y", "z" ];
                for (var i = 0; i < numPoints; i++) {
                    var texCoord = {};
                    for (var j = 0; j < numComponents; j++) {
                        texCoord[labels[j]] = this.getFloat32();
                    }
                    mesh.vertices[i].texCoord.push(texCoord);
                }
                texCoordSetIndex++;
                break;

              case DataParserTypes.NODE_FACES:
                if (!this.parseFaces(node, mesh.indices)) return false;
                break;

              default:
                this.skipNode(node);
            }
        }
        this.result.addMesh(mesh);
        this.pop();
        return true;
    },
    parseVertices: function(node, count, buffer, component, staticScale) {
        if (node.length != count * 12) return this.error("Node " + DataParserTypes.getName(node.id) + " is corrupted");
        for (var i = 0; i < count; i++) {
            buffer[i][component].x = staticScale[0] * this.getFloat32();
            buffer[i][component].y = staticScale[1] * this.getFloat32();
            buffer[i][component].z = staticScale[2] * this.getFloat32();
        }
        return true;
    },
    parseFaces: function(facesNode, buffer) {
        if (facesNode.length < 4) return this.errorExpect(4, "faces.num_triangles");
        var numTriangles = this.getUint32();
        if (facesNode.length - 4 != numTriangles * 12) return this.error("Faces list is corrupted");
        for (var i = 0; i < numTriangles; i++) {
            buffer.push(this.getUint32());
            buffer.push(this.getUint32());
            buffer.push(this.getUint32());
        }
        return true;
    },
    parseScene: function(sceneNode) {
        if (!this.hasDataForNode(sceneNode)) return this.error("Not enough data for node '" + DataParserTypes.getName(sceneNode.id) + "'");
        while (this.view.tell() < sceneNode.end()) {
            var node = this.parseNodeHeader();
            if (node.id == DataParserTypes.NODE_GROUP) {
                if (!this.parseGroup(node, false)) return false;
            } else this.skipNode(node);
        }
        this.pop();
        return true;
    },
    parseGroup: function(groupNode, parent) {
        if (!this.hasDataForNode(groupNode)) return this.error("Not enough data for node '" + DataParserTypes.getName(groupNode.id) + "'");
        var group = this.result.createGroup();
        if (parent === false) this.result.setRoot(group); else {
            parent.children.push(group);
            group.parent = parent;
        }
        while (this.view.tell() < groupNode.end()) {
            var node = this.parseNodeHeader();
            if (!this.hasDataForNode(node)) return this.error("Not enough data for node '" + DataParserTypes.getName(node.id) + "'");
            switch (node.id) {
              case DataParserTypes.NODE_GROUP_ID:
                if (node.length < 4) return this.error("Group ID is corrupted");
                group.id = this.getUint32();
                this.result.mapGroupID(group);
                break;

              case DataParserTypes.NODE_STRING:
                group.name = this.view.getString(node.length);
                break;

              case DataParserTypes.NODE_TRANSFORM_POSITION:
                if (node.length != 12) return this.error("Group position is corrupted");
                group.position.x = this.getFloat32();
                group.position.y = this.getFloat32();
                group.position.z = this.getFloat32();
                break;

              case DataParserTypes.NODE_TRANSFORM_ROTATION:
                if (node.length != 16) return this.error("Group rotation is corrupted");
                group.rotation.x = this.getFloat32();
                group.rotation.y = this.getFloat32();
                group.rotation.z = this.getFloat32();
                group.rotation.w = this.getFloat32();
                break;

              case DataParserTypes.NODE_TRANSFORM_SCALE:
                if (node.length != 12) return this.error("Group scale is corrupted");
                group.scale.x = this.getFloat32();
                group.scale.y = this.getFloat32();
                group.scale.z = this.getFloat32();
                break;

              case DataParserTypes.NODE_MATRIX4X4:
                if (node.length != 64) return this.error("Group transformation matrix is corrupted");
                group.transform = this.getMatrix4x4();
                break;

              case DataParserTypes.NODE_MESH_REFERENCE:
                if (node.length < 4) return this.error("Group mesh reference is corrupted");
                group.meshes.push(this.getUint32());
                break;

              case DataParserTypes.NODE_GROUP:
                this.parseGroup(node, group);
                break;

              default:
                this.skipNode(node);
            }
        }
        return true;
    },
    parseCollision: function(collisionNode) {
        if (!this.hasDataForNode(collisionNode)) return this.error("Not enough data for node '" + DataParserTypes.getName(collisionNode.id) + "'");
        while (this.view.tell() < collisionNode.end()) {
            var node = this.parseNodeHeader();
            if (node.id == DataParserTypes.NODE_COLLISION_NODE) {
                if (!this.parseCollisionNode(node, false)) return false;
            } else this.skipNode(node);
        }
        this.pop();
        return true;
    },
    parseCollisionNode: function(node, parent) {
        if (!this.hasDataForNode(node)) return this.error("Not enough data for node '" + DataParserTypes.getName(node.id) + "'");
        var collisionTreeNode = this.result.createCollisionTreeNode();
        if (parent === false) this.result.setCollisionTreeRoot(collisionTreeNode); else {
            parent.children.push(collisionTreeNode);
            collisionTreeNode.parent = parent;
        }
        while (this.view.tell() < node.end()) {
            var child = this.parseNodeHeader();
            if (!this.hasDataForNode(child)) return this.error("Not enough data for node '" + DataParserTypes.getName(child.id) + "'");
            switch (child.id) {
              case DataParserTypes.NODE_COLLISION_AABB_CENTER:
                if (child.length != 12) return this.error("Collision node center is corrupted");
                collisionTreeNode.center.x = this.getFloat32();
                collisionTreeNode.center.y = this.getFloat32();
                collisionTreeNode.center.z = this.getFloat32();
                break;

              case DataParserTypes.NODE_COLLISION_AABB_EXTENTS:
                if (child.length != 12) return this.error("Collision node extents are corrupted");
                collisionTreeNode.extents.x = this.getFloat32();
                collisionTreeNode.extents.y = this.getFloat32();
                collisionTreeNode.extents.z = this.getFloat32();
                break;

              case DataParserTypes.NODE_COLLISION_NODE:
                this.parseCollisionNode(child, collisionTreeNode);
                break;

              case DataParserTypes.NODE_COLLISION_FACE_LIST:
                this.parseCollisionFaceList(child, collisionTreeNode);
                break;

              default:
                this.skipNode(child);
            }
        }
        return true;
    },
    parseCollisionFaceList: function(node, collisionTreeNode) {
        if (!this.hasDataForNode(node)) return this.error("Not enough data for node '" + DataParserTypes.getName(node.id) + "'");
        var nodeID = -1;
        var meshID = -1;
        var indices = [];
        while (this.view.tell() < node.end()) {
            var child = this.parseNodeHeader();
            if (!this.hasDataForNode(child)) return this.error("Not enough data for node '" + DataParserTypes.getName(child.id) + "'");
            switch (child.id) {
              case DataParserTypes.NODE_FACE_LIST_NODE_ID:
                if (child.length != 4) return this.error("Face list node ID is corrupted");
                nodeID = this.getUint32();
                break;

              case DataParserTypes.NODE_FACE_LIST_MESH_REFERENCE:
                if (child.length != 4) return this.error("Face list mesh ID is corrupted");
                meshID = this.getUint32();
                break;

              case DataParserTypes.NODE_FACE_LIST_INDICES:
                while (this.view.tell() < child.end()) indices.push(this.getUint32());
                break;

              default:
                this.skipNode(child);
            }
        }
        return this.result.addFaceList(collisionTreeNode, nodeID, meshID, indices);
    },
    parseRoot: function(root) {
        if (!this.hasDataForNode(root)) return this.error("Not enough data for node '" + DataParserTypes.getName(root.id) + "'");
        if (this.view.tell() >= root.end()) return true;
        var node = this.parseNodeHeader();
        switch (node.id) {
          case DataParserTypes.NODE_MATERIALS:
            this.push(node, this.parseMaterials);
            break;

          case DataParserTypes.NODE_GEOMETRY:
            this.push(node, this.parseGeometry);
            break;

          case DataParserTypes.NODE_SCENE:
            this.push(node, this.parseScene);
            break;

          case DataParserTypes.NODE_COLLISION:
            this.push(node, this.parseCollision);
            break;

          default:
            this.skipNode(node);
            break;
        }
        return true;
    }
});

var ThreadedDataParser = DataParser.extend({
    init: function(data, cbOnComplete, cbOnError, cbOnProgress, userdata) {
        this._super(data, cbOnComplete, cbOnError, cbOnProgress, userdata);
        this.timer = false;
        this.inverval = 10;
    },
    parse: function() {
        this.push(false, this.parseHeader);
        this.timer = setTimeout(ClassCallback(this, this.threadStep), this.inverval);
        return true;
    },
    threadStep: function() {
        if (this.completed()) {
            if (this.linkReferences) this.result.linkReferences();
            if ($.isFunction(this.onComplete)) this.onComplete(this.result.getData(), this.userdata);
            return;
        }
        if (!this.step()) {
            if (this.onError && typeof this.onError === "function") this.onError(this.errors, this.userdata);
            return;
        }
        this.timer = setTimeout(ClassCallback(this, this.threadStep), this.inverval);
    }
});

var ModelLoader = Class.extend({
    init: function(context, descriptor, prefix, shadersManager, texturesManager, noCollisionTree) {
        this.descriptor = descriptor;
        this.shadersManager = shadersManager;
        this.texturesManager = texturesManager;
        this.prefix = prefix;
        this.defaultTexture = false;
        this.defaultSampler = false;
        this.noCollisionTree = noCollisionTree;
        this.nodesByID = {};
        this.submeshesByID = {};
        this.submeshes = [];
    },
    createDefaultTextureSampler: function(context) {
        if (this.defaultTexture) return;
        this.defaultTexture = new Texture(context);
        this.defaultTexture.clearImage(context, [ 255, 255, 255, 255 ]);
        this.defaultSampler = new Sampler("diffuse0", this.defaultTexture);
    },
    load: function(node, parsedData) {
        node.name = parsedData.hierarchy.name;
        this.loadSubmeshes(parsedData.meshes);
        this.loadNode(node, parsedData.hierarchy);
        this.loadCollision(node, parsedData);
    },
    loadSubmeshes: function(parsedMeshes) {
        for (var i = 0; i < parsedMeshes.length; i++) {
            var submesh = new Submesh();
            this.loadSubmesh(submesh, parsedMeshes[i]);
            var material = new Material();
            this.loadMaterial(material, parsedMeshes[i].material);
            this.submeshesByID[parsedMeshes[i].index] = {
                submesh: submesh,
                material: material
            };
        }
    },
    loadNode: function(node, parsedNode) {
        this.nodesByID[parsedNode.id] = node;
        this.loadTransform(node.transform, parsedNode.transform);
        this.loadMesh(node, parsedNode.meshes);
        for (var child in parsedNode.children) {
            var childNode = new Node(parsedNode.children[child].name);
            this.loadNode(childNode, parsedNode.children[child]);
            node.addNode(childNode);
        }
    },
    loadMesh: function(node, parsedMeshes) {
        if (!parsedMeshes || parsedMeshes.length == 0) return;
        var mesh = new Mesh();
        for (var i in parsedMeshes) {
            if (parsedMeshes[i].index in this.submeshesByID) {
                var o = this.submeshesByID[parsedMeshes[i].index];
                mesh.addSubmesh(o.submesh, o.material);
            }
        }
        node.addComponent(new MeshComponent(mesh));
        node.addComponent(new MeshRendererComponent());
    },
    loadSubmesh: function(submesh, parsedSubmesh) {
        submesh.faces = parsedSubmesh.indices;
        if (parsedSubmesh.vertices.length == 0) return;
        var vertex = parsedSubmesh.vertices[0];
        submesh.positions = this.loadSubmeshBuffer("position", parsedSubmesh.vertices, [ "x", "y", "z" ]);
        if (vertex.normal) submesh.normals = this.loadSubmeshBuffer("normal", parsedSubmesh.vertices, [ "x", "y", "z" ]);
        if (vertex.tangent) submesh.tangents = this.loadSubmeshBuffer("tangent", parsedSubmesh.vertices, [ "x", "y", "z" ]);
        if (vertex.bitangent) submesh.bitangents = this.loadSubmeshBuffer("bitangent", parsedSubmesh.vertices, [ "x", "y", "z" ]);
        if (vertex.texCoord) {
            for (var texCoordIndex in vertex.texCoord) {
                submesh.texCoords2D.push(this.loadSubmeshIndexedBuffer("texCoord", parsedSubmesh.vertices, [ "x", "y" ], texCoordIndex));
            }
        }
        submesh.recalculateBounds();
    },
    loadSubmeshBuffer: function(vertexAttribute, vertices, attributeParameters) {
        buffer = [];
        for (var i in vertices) {
            vertex = vertices[i];
            for (var i in attributeParameters) {
                var attributeParameter = attributeParameters[i];
                buffer.push(vertex[vertexAttribute][attributeParameter]);
            }
        }
        return buffer;
    },
    loadSubmeshIndexedBuffer: function(vertexAttribute, vertices, attributeParameters, attributeIndex) {
        buffer = [];
        for (var i in vertices) {
            vertex = vertices[i];
            for (var i in attributeParameters) {
                var attributeParameter = attributeParameters[i];
                buffer.push(vertex[vertexAttribute][attributeIndex][attributeParameter]);
            }
        }
        return buffer;
    },
    loadMaterial: function(material, parsedMaterial) {
        material.name = parsedMaterial.name;
        material.shader = this.shadersManager.addSource(parsedMaterial.shader);
        material.uniforms = {};
        this.loadUniforms(material.uniforms, parsedMaterial);
        for (var textureType in parsedMaterial.textures) {
            var textures = parsedMaterial.textures[textureType];
            for (var i = 0; i < textures.length; i++) {
                var textureDescriptor = new TextureDescriptor(textures[i].path);
                textureDescriptor.parentDescriptor = this.descriptor;
                var texture = this.texturesManager.addDescriptor(textureDescriptor);
                if (!material.samplers) material.samplers = [];
                material.samplers.push(new Sampler(textureType + i, texture));
            }
        }
        if (!material.samplers && parsedMaterial.shader.toLowerCase() == "diffuse") {
            material.samplers = [];
            this.createDefaultTextureSampler(this.texturesManager.context);
            material.samplers.push(this.defaultSampler);
        }
    },
    getModelDirectory: function() {
        var path = this.descriptor.source;
        var lastIndex = path.lastIndexOf("/");
        var dir = path.substr(0, lastIndex);
        return dir;
    },
    getRelativePath: function(path) {
        var lastIndex = path.lastIndexOf("/");
        return path.substr(lastIndex + 1, path.length - lastIndex - 1);
    },
    loadUniforms: function(uniforms, parsedMaterial) {
        if (parsedMaterial.color.ambient) uniforms["ambient"] = new UniformColor(parsedMaterial.color.ambient); else uniforms["ambient"] = new UniformColor(new Color(.2, .2, .2, 1));
        if (parsedMaterial.color.diffuse) uniforms["diffuse"] = new UniformColor(parsedMaterial.color.diffuse);
        if (parsedMaterial.color.emissive) uniforms["emissive"] = new UniformColor(parsedMaterial.color.emissive);
        if (parsedMaterial.color.specular) uniforms["specular"] = new UniformColor(parsedMaterial.color.specular);
        if (parsedMaterial.shininess) uniforms["shininess"] = new UniformFloat(parsedMaterial.shininess);
        if (parsedMaterial.shininess_strength) uniforms["shininess_strength"] = new UniformFloat(parsedMaterial.shininess_strength);
        uniforms["twosided"] = new UniformInt(parsedMaterial.twosided + 0);
    },
    loadTransform: function(transform, parsedTransform) {
        transform.relative[0] = parsedTransform[0][0];
        transform.relative[4] = parsedTransform[0][1];
        transform.relative[8] = parsedTransform[0][2];
        transform.relative[12] = parsedTransform[0][3];
        transform.relative[1] = parsedTransform[1][0];
        transform.relative[5] = parsedTransform[1][1];
        transform.relative[9] = parsedTransform[1][2];
        transform.relative[13] = parsedTransform[1][3];
        transform.relative[2] = parsedTransform[2][0];
        transform.relative[6] = parsedTransform[2][1];
        transform.relative[10] = parsedTransform[2][2];
        transform.relative[14] = parsedTransform[2][3];
        transform.relative[3] = parsedTransform[3][0];
        transform.relative[7] = parsedTransform[3][1];
        transform.relative[11] = parsedTransform[3][2];
        transform.relative[15] = parsedTransform[3][3];
    },
    loadCollisionNodeParameters: function(parsedNode, parentCollisionNode) {
        var n = new CollisionOctreeNode([ parsedNode.center.x, parsedNode.center.y, parsedNode.center.z ], parsedNode.extents.x * 2, parentCollisionNode);
        if (parsedNode.faces) n.faces = parsedNode.faces;
        return n;
    },
    loadCollisionNodeSubnodes: function(collisionNode, parsedNode, parsedData) {
        if (parsedNode.children.length == 0) return;
        collisionNode.subnodes = [];
        for (var i = 0; i < 8; i++) {
            var subnode = this.loadCollisionNodeParameters(parsedNode.children[i], collisionNode);
            collisionNode.subnodes.push(subnode);
            this.loadCollisionNodeSubnodes(subnode, parsedNode.children[i], parsedData);
        }
    },
    loadCollision: function(rootNode, parsedData) {
        if (parsedData.collision === false) return;
        var lmc = rootNode.addComponent(new LargeMeshCollider());
        lmc.tree = this.loadCollisionNodeParameters(parsedData.collision, false);
        lmc.tree.nodes = this.nodesByID;
        lmc.tree.submeshes = {};
        for (var mesh_id in this.submeshesByID) lmc.tree.submeshes[mesh_id] = this.submeshesByID[mesh_id].submesh;
        this.loadCollisionNodeSubnodes(lmc.tree, parsedData.collision, parsedData);
    }
});

var Manager = Class.extend({
    init: function() {
        this.sourceCallback = function(source, descriptor) {
            return source;
        };
        this.onAddToQueue = function(descriptor) {};
        this.onLoaded = function(descriptor) {};
        this.queue = [];
        this.loading = [];
        this.cache = {};
        this.cacheSize = 0;
        this.callbacks = [];
        this.progressCallbacks = [];
    },
    getTotalItems: function() {
        return this.queue.length + this.loading.length + this.cacheSize;
    },
    getWaitingItems: function() {
        return this.queue.length + this.loading.length;
    },
    getProgress: function() {
        if (this.getTotalItems() == 0) return 1;
        return 1 - this.getWaitingItems() / this.getTotalItems();
    },
    addDescriptor: function(descriptor) {
        var resource = this.cache[descriptor.serialize([ "id" ])];
        if (resource) {
            return resource;
        }
        resource = this.getLoadingResource(descriptor);
        if (resource) {
            return resource;
        }
        this.onAddToQueue(descriptor);
        resource = this.createResource(descriptor);
        this.queue.push([ descriptor, descriptor.serialize([ "id" ]), resource ]);
        return resource;
    },
    getLoadingResource: function(descriptor) {
        var descriptorString = descriptor.serialize([ "id" ]);
        for (var l in this.loading) {
            if (this.loading[l][1] == descriptorString) return this.loading[l][2];
        }
        for (var q in this.queue) {
            if (this.queue[q][1] == descriptorString) return this.queue[q][2];
        }
        return null;
    },
    removeFromCache: function(descriptor) {
        delete this.cache[descriptor];
        this.cacheSize--;
    },
    cleanCache: function() {
        this.cache = {};
        this.cacheSize = 0;
    },
    load: function(callback, progressCallback) {
        if (progressCallback) {
            this.progressCallbacks.push(progressCallback);
        }
        if (callback) {
            this.callbacks.push(callback);
            if (this.callbacks.length > 1) {
                if (this.queue.length == 0) {
                    this.callDoneCallbacks();
                }
                return;
            }
        }
        this.keepLoading();
    },
    keepLoading: function() {
        for (var i in this.progressCallbacks) {
            this.progressCallbacks[i](this.getProgress());
        }
        if (this.queue.length == 0) {
            this.callDoneCallbacks();
            return;
        }
        var me = this;
        var next = this.queue.shift();
        this.loading.push(next);
        this.loadResource(next[0], next[2], function(d, r) {
            me.cache[d.serialize([ "id" ])] = r;
            me.cacheSize++;
            me.removeLoadedResource(d);
            me.onLoaded(d);
            me.keepLoading();
        }, function(d) {
            console.log("Failed to load resource with descriptor: ", d.serialize([ "id" ]));
            me.removeLoadedResource(d);
            me.onLoaded(d);
            if (d.getFullPath) console.log("Full path: ", d.getFullPath());
            me.keepLoading();
        });
    },
    removeLoadedResource: function(descriptor) {
        for (var i in this.loading) {
            if (this.loading[i][0] === descriptor) {
                this.loading.splice(i, 1);
                break;
            }
        }
    },
    callDoneCallbacks: function() {
        var doneCallbacks = this.callbacks;
        this.callbacks = [];
        for (var c in doneCallbacks) {
            doneCallbacks[c]();
        }
    },
    createResource: function() {
        throw "createResource not implemented by this instance of Manager";
    },
    loadResource: function(descriptor, resource, loadedCallback, failedCallback) {
        throw "loadResource not implemented by this instance of Manager";
    }
});

var TextManager = Manager.extend({
    init: function() {
        this._super();
    },
    add: function(source) {
        return this.addDescriptor(new TextDescriptor(source));
    },
    createResource: function(textDescriptor) {
        return {
            data: false,
            descriptor: textDescriptor
        };
    },
    loadResource: function(textDescriptor, textResource, loadedCallback, failedCallback) {
        Logistics.getText(this.sourceCallback(textDescriptor.getFullPath(), textDescriptor), function(data) {
            textResource.data = data;
            loadedCallback(textDescriptor, textResource);
        }).error(function() {
            failedCallback(textDescriptor);
        });
    }
});

var ShadersManager = Manager.extend({
    init: function(context) {
        this._super();
        this.context = context;
        this.shadersPath = "";
        this.aliases = {
            diffuse: "shaders/default/diffuse",
            transparent: "shaders/default/transparent",
            test: "shaders/default/test",
            fallback: "shaders/default/fallback",
            depthrgba: "shaders/default/DepthRGBA",
            gaussianblur: "shaders/default/GaussianBlur"
        };
        this.textManager = new TextManager();
    },
    add: function(vertexSource, fragmentSource) {
        return this.addDescriptor(new ShaderDescriptor(vertexSource, fragmentSource));
    },
    addSource: function(source) {
        if (this.aliases[source.toLowerCase()]) source = this.aliases[source.toLowerCase()];
        source = this.shadersPath + source;
        return this.addDescriptor(new ShaderDescriptor(source + ".vert", source + ".frag"));
    },
    createResource: function(shaderDescriptor) {
        return new Shader(this.context, shaderDescriptor);
    },
    loadResource: function(shaderDescriptor, shaderResource, loadedCallback, failedCallback) {
        var vertexShader = this.textManager.add(shaderDescriptor.getVertexShaderPath());
        var fragmentShader = this.textManager.add(shaderDescriptor.getFragmentShaderPath());
        this.textManager.load(function() {
            if (!vertexShader.data) {
                failedCallback(shaderDescriptor);
                return;
            }
            if (!fragmentShader.data) {
                failedCallback(shaderDescriptor);
                return;
            }
            shaderResource.addVertexShader(vertexShader.data);
            shaderResource.addFragmentShader(fragmentShader.data);
            loadedCallback(shaderDescriptor, shaderResource);
        });
    }
});

var TexturesManager = Manager.extend({
    init: function(context) {
        this._super();
        this.context = context;
    },
    add: function(source) {
        var d = new TextureDescriptor(source);
        return this.addDescriptor(d);
    },
    createResource: function(textureDescriptor) {
        texture = new Texture(this.context);
        texture.name = textureDescriptor.source;
        return texture;
    },
    loadResource: function(textureDescriptor, textureResource, loadedCallback, failedCallback) {
        var me = this;
        Logistics.getImage(this.sourceCallback(textureDescriptor.getFullPath(), textureDescriptor), function(image) {
            textureResource.setImage(me.context, image);
            delete image;
            loadedCallback(textureDescriptor, textureResource);
        }).error(function() {
            failedCallback(textureDescriptor);
        });
    }
});

var MaterialsManager = Manager.extend({
    init: function(context, shadersManager, texturesManager) {
        this._super();
        if (shadersManager && !(shadersManager instanceof ShadersManager)) throw "shadersManager is not instance of ShadersManager";
        if (texturesManager && !(texturesManager instanceof TexturesManager)) throw "texturesManager is not instance of TexturesManager";
        if (!shadersManager) shadersManager = new ShadersManager(context);
        this.shadersManager = shadersManager;
        if (!texturesManager) texturesManager = new TexturesManager(context);
        this.texturesManager = texturesManager;
        this.context = context;
    },
    add: function(source) {
        return this.addDescriptor(new MaterialDescriptor(source));
    },
    createResource: function(materialDescriptor) {
        var material = new Material();
        material.descriptor = materialDescriptor;
        return material;
    },
    loadResource: function(materialDescriptor, material, loadedCallback, failedCallback) {
        var me = this;
        var shader;
        if (materialDescriptor.shaderDescriptor) {
            shader = this.shadersManager.addDescriptor(materialDescriptor.shaderDescriptor);
        }
        this.shadersManager.load(function() {
            var textures = {};
            for (var t in materialDescriptor.textureDescriptors) {
                textures[t] = me.texturesManager.addDescriptor(materialDescriptor.textureDescriptors[t]);
            }
            me.texturesManager.load(function() {
                if (!material.samplers) material.samplers = [];
                for (var mt in textures) {
                    material.samplers.push(new Sampler(mt, textures[mt]));
                }
                material.shader = shader;
                material.uniforms = materialDescriptor.uniforms;
                if (materialDescriptor.requirements && material.shader) {
                    material.shader.requirements.transparent = materialDescriptor.requirements.transparent;
                }
                loadedCallback(materialDescriptor, material);
            });
        });
    }
});

var MaterialSourcesManager = Manager.extend({
    init: function(context, materialsManager, textManager) {
        this._super();
        if (materialsManager && !(materialsManager instanceof MaterialsManager)) throw "materialsManager is not instance of MaterialsManager";
        if (textManager && !(textManager instanceof TextManager)) throw "textManager is not instance of TextManager";
        if (!materialsManager) materialsManager = new MaterialsManager(context);
        this.materialsManager = materialsManager;
        if (!textManager) textManager = new TextManager();
        this.textManager = textManager;
        this.context = context;
    },
    add: function(source) {
        return this.addDescriptor(new MaterialSourceDescriptor(source));
    },
    createResource: function(materialSourceDescriptor) {
        return new MaterialSource(materialSourceDescriptor);
    },
    loadResource: function(materialSourceDescriptor, materialSource, loadedCallback, failedCallback) {
        var text = this.textManager.add(materialSourceDescriptor.getFullPath());
        var me = this;
        this.textManager.load(function() {
            var result = $.parseJSON(text.data);
            var md = new MaterialDescriptor();
            md.parentDescriptor = materialSourceDescriptor;
            if (result.uniforms) {
                for (var u in result.uniforms) {
                    var uniform = result.uniforms[u];
                    if (uniform instanceof Array) {
                        if (uniform.length == 1) md.uniforms[u] = new UniformFloat(uniform);
                        if (uniform.length == 2) {
                            if (uniform[0] instanceof Array) md.uniforms[u] = new UniformMat2(uniform[0].concat(uniform[1])); else md.uniforms[u] = new UniformVec2(uniform);
                        }
                        if (uniform.length == 3) {
                            if (uniform[0] instanceof Array) md.uniforms[u] = new UniformMat3(uniform[0].concat(uniform[1]).concat(uniform[2])); else md.uniforms[u] = new UniformVec3(uniform);
                        }
                        if (uniform.length == 4) {
                            if (uniform[0] instanceof Array) md.uniforms[u] = new UniformMat4(uniform[0].concat(uniform[1]).concat(uniform[2]).concat(uniform[3])); else md.uniforms[u] = new UniformVec4(uniform);
                        }
                    } else if (uniform instanceof Object) {
                        if (!"a" in uniform) uniform.a = 0;
                        md.uniforms[u] = new UniformColor(uniform);
                    } else if (typeof uniform === "number" && parseFloat(uniform) == parseInt(uniform)) md.uniforms[u] = new UniformInt(uniform); else md.uniforms[u] = new UniformFloat(uniform);
                }
            }
            if (result.textures) {
                for (var t in result.textures) {
                    var textureDescriptor = new TextureDescriptor(result.textures[t]);
                    md.textureDescriptors[t] = textureDescriptor;
                    textureDescriptor.parentDescriptor = md;
                }
            }
            if (result.shader) {
                if (result.shader instanceof Array) {
                    md.shaderDescriptor = new ShaderDescriptor(result.shader[0], result.shader[1]);
                } else {
                    md.shaderDescriptor = new ShaderDescriptor(result.shader);
                }
                md.shaderDescriptor.parentDescriptor = md;
            }
            if (result.requirements) {
                md.requirements = result.requirements;
            }
            materialSource.material = me.materialsManager.addDescriptor(md);
            me.materialsManager.load(function() {
                loadedCallback(materialSourceDescriptor, materialSource);
            });
        });
    }
});

var ModelsManager = Manager.extend({
    init: function(context, shadersManager, texturesManager) {
        this._super();
        if (!shadersManager) shadersManager = new ShadersManager(context);
        this.shadersManager = shadersManager;
        if (!texturesManager) texturesManager = new TexturesManager(context);
        this.texturesManager = texturesManager;
        this.loadRelativeTextures = true;
    },
    getProgress: function() {
        if (this._super() == 1) return 1;
        return this._super() + (this.texturesManager.getProgress() + this.shadersManager.getProgress()) / 2 / this.getTotalItems();
    },
    add: function(source, noCollisionTree) {
        return this.addDescriptor(new ModelDescriptor(source, noCollisionTree));
    },
    createResource: function() {
        return new Node();
    },
    loadResource: function(descriptor, resource, loadedCallback, failedCallback) {
        var totalTime = 0;
        var me = this;
        Logistics.getBinary(descriptor.source, function(binaryData) {
            if (!binaryData) {
                failedCallback(descriptor);
                return;
            }
            var parser = me.createParser(binaryData, function(parsedData, userdata) {
                var end = new Date().getTime();
                var delta = end - fileStartTime;
                totalTime += delta;
                console.log("Parsed data: ", parsedData, " delta: ", delta, " time: ", totalTime);
                var modelLoader = new ModelLoader(me.context, descriptor, "", me.shadersManager, me.texturesManager, descriptor.noCollisionTree);
                modelLoader.load(resource, parsedData);
                loadedCallback(descriptor, resource);
                me.shadersManager.load(function() {});
                me.texturesManager.load(function() {});
            }, function(errors, userdata) {
                failedCallback(descriptor);
            }, function(progress, userdata) {});
            fileStartTime = new Date().getTime();
            parser.parse();
        });
    },
    createParser: function(data, cbOnComplete, cbOnError, cbOnProgress, userdata) {
        return new ThreadedDataParser(data, cbOnComplete, cbOnError, cbOnProgress, userdata);
    }
});

var FontsManager = Manager.extend({
    init: function(context, materialSourcesManager, materialsManager, texturesManager, textManager) {
        this._super();
        if (materialSourcesManager && !(materialSourcesManager instanceof MaterialSourcesManager)) throw "materialSourcesManager is not instance of MaterialSourcesManager";
        if (materialsManager && !(materialsManager instanceof MaterialsManager)) throw "materialsManager is not instance of MaterialsManager";
        if (texturesManager && !(texturesManager instanceof TexturesManager)) throw "texturesManager is not instance of TexturesManager";
        if (textManager && !(textManager instanceof TextManager)) throw "textManager is not instance of TextManager";
        if (!textManager) textManager = new TextManager();
        this.textManager = new TextManager();
        if (!materialsManager) materialsManager = new MaterialsManager(context);
        this.materialsManager = materialsManager;
        if (!materialSourcesManager) materialSourcesManager = new MaterialSourcesManager(context, this.materialsManager, this.textManager);
        this.materialSourcesManager = materialSourcesManager;
        if (!texturesManager) texturesManager = new TexturesManager(context);
        this.texturesManager = texturesManager;
    },
    add: function(fontTextures, fontData) {
        return this.addDescriptor(new FontDescriptor(fontTextures, fontData));
    },
    createResource: function(fontDescriptor) {
        return new Font(false, false, false, fontDescriptor);
    },
    loadResource: function(fontDescriptor, font, loadedCallback, failedCallback) {
        var me = this;
        var textures = [];
        var texturePaths = fontDescriptor.fontTexturePaths;
        for (var i in texturePaths) {
            var textureDescriptor = new TextureDescriptor(texturePaths[i]);
            textureDescriptor.parentDescriptor = fontDescriptor;
            textures.push(this.texturesManager.addDescriptor(textureDescriptor));
        }
        this.texturesManager.load(function() {
            font.textures = textures;
            if (!fontDescriptor.materialSourceDescriptor) {
                fontDescriptor.materialSourceDescriptor = new MaterialSourceDescriptor("materials/FontMaterial.json");
            }
            fontDescriptor.materialSourceDescriptor.parentDescriptor = fontDescriptor;
            font.materialSource = me.materialSourcesManager.addDescriptor(fontDescriptor.materialSourceDescriptor);
            me.materialSourcesManager.load(function() {
                font.materialSource.material.samplers = [];
                for (var t in font.textures) {
                    font.materialSource.material.samplers.push(new Sampler("page" + t, font.textures[t]));
                }
                var text = me.textManager.add(fontDescriptor.getFullDataPath());
                me.textManager.load(function() {
                    font.data = new FontData($.parseXML(text.data));
                    loadedCallback(fontDescriptor, font);
                });
            });
        });
    }
});

var FontSourcesManager = Manager.extend({
    init: function(context, fontsManager, textManager) {
        this._super();
        if (fontsManager && !(fontsManager instanceof FontsManager)) throw "fontsManager is not instance of FontsManager";
        if (textManager && !(textManager instanceof TextManager)) throw "textManager is not instance of TextManager";
        if (!textManager) textManager = new TextManager();
        this.textManager = textManager;
        if (!fontsManager) fontsManager = new FontsManager(context);
        this.fontsManager = fontsManager;
    },
    add: function(source) {
        return this.addDescriptor(new FontSourceDescriptor(source));
    },
    createResource: function(fontSourceDescriptor) {
        return new FontSource(fontSourceDescriptor);
    },
    loadResource: function(fontSourceDescriptor, fontSource, loadedCallback, failedCallback) {
        var scope = this;
        Logistics.getText(this.sourceCallback(fontSourceDescriptor.getFullPath(), fontSourceDescriptor), function(data) {
            var object = JSON && JSON.parse(data) || $.parseJSON(data);
            if (!object || !object.textures || !object.data || !object.material) {
                failedCallback(fontSourceDescriptor);
                return;
            }
            var fontDescriptor = new FontDescriptor(object.textures, object.data, new MaterialSourceDescriptor(object.material));
            fontDescriptor.parentDescriptor = fontSourceDescriptor;
            fontSource.font = scope.fontsManager.addDescriptor(fontDescriptor);
            scope.fontsManager.load(function() {
                loadedCallback(fontDescriptor, fontSource);
            });
        }).error(function() {
            failedCallback(fontSourceDescriptor);
        });
    }
});

var AssetsManager = Class.extend({
    init: function(renderingContext, shadersPath) {
        this.managers = [];
        var me = this;
        this.loadingCount = 0;
        this.loadedCallbacks = [];
        var addManager = function(manager) {
            manager.onAddToQueue = function(descriptor) {
                me.loadingCount++;
            };
            manager.onLoaded = function(descriptor) {
                me.loadingCount--;
                if (me.loadingCount <= 0) {
                    var callbacks = me.loadedCallbacks.slice(0);
                    me.loadedCallbacks = [];
                    for (i in callbacks) {
                        var c = callbacks[i];
                        c();
                    }
                }
            };
            me.managers.push(manager);
        };
        addManager(this.shadersManager = new ShadersManager(renderingContext));
        addManager(this.texturesManager = new TexturesManager(renderingContext));
        addManager(this.modelsManager = new ModelsManager(renderingContext, this.shadersManager, this.texturesManager));
        addManager(this.textManager = new TextManager());
        addManager(this.materialsManager = new MaterialsManager(renderingContext, this.shadersManager, this.texturesManager));
        addManager(this.materialSourcesManager = new MaterialSourcesManager(renderingContext, this.materialsManager, this.textManager));
        addManager(this.fontsManager = new FontsManager(renderingContext, this.materialSourcesManager, this.materialsManager, this.texturesManager, this.textManager));
        addManager(this.fontSourcesManager = new FontSourcesManager(renderingContext, this.fontsManager, this.textManager));
        if (shadersPath) this.shadersManager.shadersPath = shadersPath;
        this.shadersManager.fallbackVertexShader = this.shadersManager.addSource("Fallback");
    },
    addTexture: function(source) {
        return this.texturesManager.add(source);
    },
    addModel: function(source, noCollisionTree) {
        return this.modelsManager.add(source, noCollisionTree);
    },
    addShaderSource: function(source) {
        return this.shadersManager.addSource(source);
    },
    addShader: function(vertexSource, fragmentSource) {
        return this.shadersManager.add(vertexSource, fragmentSource);
    },
    addText: function(source) {
        return this.textManager.add(source);
    },
    addMaterial: function(source) {
        return this.materialSourcesManager.add(source);
    },
    addFont: function(source) {
        return this.fontSourcesManager.add(source);
    },
    hasItemsInQueue: function() {
        for (var m in this.managers) {
            if (this.managers[m].getWaitingItems() > 0) return true;
        }
        return false;
    },
    load: function(callback, progressCallback) {
        var me = this;
        if (callback) {
            this.loadedCallbacks.push(callback);
        }
        if (!this.hasItemsInQueue()) {
            var callbacks = this.loadedCallbacks.slice(0);
            this.loadedCallbacks = [];
            for (i in callbacks) {
                var c = callbacks[i];
                c();
            }
            return;
        }
        function onProgress() {
            if (!progressCallback) return;
            var progress = 0;
            for (var i in me.managers) progress += me.managers[i].getProgress();
            progressCallback(progress / me.managers.length);
        }
        for (var m in this.managers) {
            this.managers[m].load(function() {}, onProgress);
        }
    }
});

var BoundingVolume = Serializable.extend({
    init: function(center) {
        this.center = false;
        if (center) this.center = vec3.clone(center);
    },
    type: function() {
        return "BoundingVolume";
    },
    isPoint: function() {
        return true;
    },
    toString: function() {
        return "BoundingVolume[center=(" + this.center[0] + "," + this.center[1] + "," + this.center[2] + ")]";
    }
});

var BoundingVolumeVectorCache = [ vec3.create(), vec3.create(), vec3.create() ];

var BoundingBox = BoundingVolume.extend({
    init: function(center, size) {
        this._super(center);
        this.size = vec3.create();
        if (size) vec3.copy(this.size, size);
        this.extents = vec3.scale(vec3.create(), this.size, .5);
        this.min = vec3.create();
        this.max = vec3.create();
        this.recalculate();
    },
    type: function() {
        return "BoundingSphere";
    },
    recalculate: function() {
        vec3.scale(this.size, this.extents, 2);
        if (this.center) {
            vec3.subtract(this.min, this.center, this.extents);
            vec3.add(this.max, this.center, this.extents);
        }
    },
    transform: function(mat) {
        var box = new BoundingBox();
        if (!this.center) return box;
        var a = 0, b = 0;
        mat4.translation(box.min, mat);
        mat4.translation(box.max, mat);
        for (var j = 0; j < 3; j++) {
            for (var i = 0; i < 3; i++) {
                a = mat[i * 4 + j] * this.min[i];
                b = mat[i * 4 + j] * this.max[i];
                if (a < b) {
                    box.min[j] += a;
                    box.max[j] += b;
                } else {
                    box.min[j] += b;
                    box.max[j] += a;
                }
            }
        }
        vec3.subtract(box.size, box.max, box.min);
        vec3.scale(box.extents, box.size, .5);
        box.center = vec3.add(vec3.create(), box.min, box.extents);
        return box;
    },
    isPoint: function() {
        return this.size[0] == 0 && this.size[1] == 0 && this.size[2] == 0;
    },
    getOuterSphereRadius: function() {
        return vec3.len(this.extents);
    },
    containsPoint: function(point) {
        if (!this.center) return false;
        if (point[0] >= this.min[0] && point[1] >= this.min[1] && point[2] >= this.min[2] && point[0] <= this.max[0] && point[1] <= this.max[1] && point[2] <= this.max[2]) return true;
        return false;
    },
    containsBox: function(box) {
        if (!this.center) return false;
        return this.containsPoint(box.min) && this.containsPoint(box.max);
    },
    intersectsBox: function(box) {
        if (!this.center) return false;
        return this.max[0] > box.min[0] && this.min[0] < box.max[0] && this.max[1] > box.min[1] && this.min[0] < box.max[1] && this.max[2] > box.min[2] && this.min[2] < box.max[2];
    },
    intersectsPlane: function(plane) {
        if (!this.center) return false;
        var localMin = BoundingVolumeVectorCache[0];
        var localMax = BoundingVolumeVectorCache[1];
        var p = BoundingVolumeVectorCache[2];
        vec3.copy(localMin, this.max);
        vec3.copy(localMax, this.min);
        var minDist = Infinity;
        var maxDist = -Infinity;
        var d = plane.getDistanceToPoint(this.min);
        if (d < minDist) {
            vec3.copy(localMin, this.min);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, this.min);
            maxDist = d;
        }
        d = plane.getDistanceToPoint(this.max);
        if (d < minDist) {
            vec3.copy(localMin, this.max);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, this.max);
            maxDist = d;
        }
        vec3.set(p, this.min[0], this.min[1], this.max[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        vec3.set(p, this.min[0], this.max[1], this.min[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        vec3.set(p, this.min[0], this.max[1], this.max[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        vec3.set(p, this.max[0], this.min[1], this.min[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        vec3.set(p, this.max[0], this.min[1], this.max[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        vec3.set(p, this.max[0], this.max[1], this.min[2]);
        d = plane.getDistanceToPoint(p);
        if (d < minDist) {
            vec3.copy(localMin, p);
            minDist = d;
        }
        if (d > maxDist) {
            vec3.copy(localMax, p);
            maxDist = d;
        }
        if (!plane.sameSide(localMin, localMax)) return true;
        if (plane.pointOnPlane(localMin) || plane.pointOnPlane(localMax)) return true;
        return false;
    },
    intersectsTriangle: function(p0, p1, p2) {
        if (!this.center) return false;
        AABBPlaneCache.setByPoints(p0, p1, p2);
        if (!this.intersectsPlane(AABBPlaneCache)) return false;
        if (this.containsPoint(p0) || this.containsPoint(p1) || this.containsPoint(p2)) return true;
        var min = BoundingVolumeVectorCache[0];
        var max = BoundingVolumeVectorCache[1];
        vec3.copy(min, p0);
        vec3.copy(max, p0);
        for (var i = 0; i < 3; i++) {
            if (p1[i] < min[i]) min[i] = p1[i];
            if (p2[i] < min[i]) min[i] = p2[i];
            if (p1[i] > max[i]) max[i] = p1[i];
            if (p2[i] > max[i]) max[i] = p2[i];
        }
        if (!(this.max[0] >= min[0] && this.min[0] <= max[0] && this.max[1] >= min[1] && this.min[0] <= max[1] && this.max[2] >= min[2] && this.min[2] <= max[2])) return false;
        var proj0 = vec2.fromValues(p0[0], p0[1]);
        var proj1 = vec2.fromValues(p1[0], p1[1]);
        var proj2 = vec2.fromValues(p2[0], p2[1]);
        var projMin = vec2.fromValues(this.min[0], this.min[1]);
        var projMax = vec2.fromValues(this.max[0], this.max[1]);
        if (!LineRectIntersection2D(proj0, proj1, projMin, projMax) && !LineRectIntersection2D(proj1, proj2, projMin, projMax) && !LineRectIntersection2D(proj2, proj0, projMin, projMax)) {
            if (!PointInTriangle2D(proj0, proj1, proj2, projMin)) return false;
        }
        vec2.set(proj0, p0[2], p0[1]);
        vec2.set(proj1, p1[2], p1[1]);
        vec2.set(proj2, p2[2], p2[1]);
        vec2.set(projMin, this.min[2], this.min[1]);
        vec2.set(projMax, this.max[2], this.max[1]);
        if (!LineRectIntersection2D(proj0, proj1, projMin, projMax) && !LineRectIntersection2D(proj1, proj2, projMin, projMax) && !LineRectIntersection2D(proj2, proj0, projMin, projMax)) {
            if (!PointInTriangle2D(proj0, proj1, proj2, projMin)) return false;
        }
        vec2.set(proj0, p0[0], p0[2]);
        vec2.set(proj1, p1[0], p1[2]);
        vec2.set(proj2, p2[0], p2[2]);
        vec2.set(projMin, this.min[0], this.min[2]);
        vec2.set(projMax, this.max[0], this.max[2]);
        if (!LineRectIntersection2D(proj0, proj1, projMin, projMax) && !LineRectIntersection2D(proj1, proj2, projMin, projMax) && !LineRectIntersection2D(proj2, proj0, projMin, projMax)) {
            if (!PointInTriangle2D(proj0, proj1, proj2, projMin)) return false;
        }
        return true;
    },
    encapsulatePoint: function(point) {
        if (!this.center) {
            this.center = vec3.clone(point);
            this.extents[0] = 0;
            this.extents[1] = 0;
            this.extents[2] = 0;
            this.recalculate();
            return;
        }
        if (this.containsPoint(point)) return;
        var delta = vec3.subtract(BoundingVolumeVectorCache[0], point, this.center);
        for (var axis = 0; axis < 3; axis++) {
            if (Math.abs(delta[axis]) > this.extents[axis]) {
                this.extents[axis] += (Math.abs(delta[axis]) - this.extents[axis]) / 2;
                this.center[axis] = point[axis] + (point[axis] > this.center[axis] ? -1 : 1) * this.extents[axis];
            }
        }
        this.recalculate();
    },
    encapsulateBox: function(box) {
        if (!box.center) return;
        if (!this.center) {
            this.center = vec3.clone(box.center);
            this.extents = vec3.clone(box.extents);
            this.recalculate();
            return;
        }
        if (this.containsBox(box)) return;
        this.encapsulatePoint(box.min);
        this.encapsulatePoint(box.max);
    },
    getVertices: function() {
        var vertices = [];
        vertices.push(vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create());
        vec3.add(vertices[0], this.center, [ this.extents[0], this.extents[1], this.extents[2] ]);
        vec3.add(vertices[1], this.center, [ -this.extents[0], this.extents[1], this.extents[2] ]);
        vec3.add(vertices[2], this.center, [ this.extents[0], -this.extents[1], this.extents[2] ]);
        vec3.add(vertices[3], this.center, [ -this.extents[0], -this.extents[1], this.extents[2] ]);
        vec3.add(vertices[4], this.center, [ this.extents[0], this.extents[1], -this.extents[2] ]);
        vec3.add(vertices[5], this.center, [ -this.extents[0], this.extents[1], -this.extents[2] ]);
        vec3.add(vertices[6], this.center, [ this.extents[0], -this.extents[1], -this.extents[2] ]);
        vec3.add(vertices[7], this.center, [ -this.extents[0], -this.extents[1], -this.extents[2] ]);
        return vertices;
    },
    toString: function() {
        return "BoundingBox[\n" + "	center=(" + this.center[0] + ", " + this.center[1] + ", " + this.center[2] + ")\n" + "	min=(" + this.min[0] + ", " + this.min[1] + ", " + this.min[2] + ")\n" + "	max=(" + this.max[0] + ", " + this.max[1] + ", " + this.max[2] + ")\n" + "	extents=(" + this.extents[0] + ", " + this.extents[1] + ", " + this.extents[2] + ")\n" + "	size=(" + this.size[0] + ", " + this.size[1] + ", " + this.size[2] + ")\n" + "]\n";
    }
});

function LineLineIntersection2D(a, b, c, d, out) {
    var denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);
    if (denom == 0) return false;
    var r = ((a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1])) / denom;
    var s = ((a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1])) / denom;
    if (r < 0 || r > 1 || s < 0 || s > 1) return false;
    if (out) {
        out[0] = a[0] + r * (b[0] - a[0]);
        out[1] = a[1] + r * (b[1] - a[1]);
    }
    return true;
}

function LineRectIntersection2D(a, b, min, max) {
    if (LineLineIntersection2D(a, b, min, [ min[0], max[1] ]) || LineLineIntersection2D(a, b, [ min[0], max[1] ], max) || LineLineIntersection2D(a, b, max, [ max[0], min[1] ]) || LineLineIntersection2D(a, b, min, [ max[0], min[1] ])) return true;
    return false;
}

function PointInTriangle2D(p1, p2, p3, pt) {
    var det = (p2[1] - p3[1]) * (p1[0] - p3[0]) + (p3[0] - p2[0]) * (p1[1] - p3[1]);
    if (det == 0) return false;
    var u = ((p2[1] - p3[1]) * (pt[0] - p3[0]) + (p3[0] - p2[0]) * (pt[1] - p3[1])) / det;
    var v = ((p3[1] - p1[1]) * (pt[0] - p3[0]) + (p1[0] - p3[0]) * (pt[1] - p3[1])) / det;
    if (u >= 0 && v >= 0 && u + v <= 1) return true;
    return false;
}

var BoundingSphere = BoundingVolume.extend({
    init: function(center, radius) {
        this._super(center);
        this.radius = 0;
        if (radius) this.radius = radius;
    },
    type: function() {
        return "BoundingSphere";
    },
    isPoint: function() {
        return this.radius == 0;
    },
    containsPoint: function(point) {
        if (!this.center) return false;
        return vec3.distance(point, this.center) <= this.radius;
    },
    containsSphere: function(sphere) {
        if (!this.center) return false;
        return vec3.distance(sphere.center, this.center) <= this.radius - sphere.radius;
    },
    intersectsSphere: function(sphere) {
        if (!this.center) return false;
        var d = vec3.squaredLength(vec3.subtract(BoundingVolumeVectorCache[0], this.center, sphere.center));
        var radiiSum = this.radius + sphere.radius;
        return d <= radiiSum * radiiSum;
    },
    encapsulatePoint: function(point) {
        if (!this.center) {
            this.center = vec3.clone(point);
            this.radius = 0;
            return;
        }
        if (this.containsPoint(point)) return;
        var dir = vec3.subtract(BoundingVolumeVectorCache[0], this.center, point);
        var length = vec3.length(dir) + this.radius;
        vec3.normalize(dir, dir);
        this.radius = length / 2;
        var tmp = vec3.scale(BoundingVolumeVectorCache[1], dir, this.radius);
        vec3.add(this.center, point, tmp);
    },
    encapsulateSphere: function(sphere) {
        if (!sphere.center) return;
        if (!this.center) {
            this.center = vec3.clone(sphere.center);
            this.radius = sphere.radius;
            return;
        }
        if (this.containsSphere(sphere)) return;
        var dir = vec3.subtract(BoundingVolumeVectorCache[0], sphere.center, this.center);
        var length = vec3.length(dir) + sphere.radius;
        vec3.normalize(dir, dir);
        vec3.scale(dir, dir, length);
        var pt = vec3.add(BoundingVolumeVectorCache[2], this.center, dir);
        this.encapsulatePoint(pt);
    },
    transform: function(mat) {
        if (!this.center) return new BoundingSphere();
        var scale = mat4.getScale(BoundingVolumeVectorCache[0], mat);
        var c = vec3.transformMat4(BoundingVolumeVectorCache[1], this.center, mat);
        return new BoundingSphere(c, this.radius * Math.max(scale[0], scale[1], scale[2]));
    },
    toString: function() {
        return "BoundingSphere[" + "center=(" + this.center[0] + ", " + this.center[1] + ", " + this.center[2] + ") " + "radius=" + this.radius + "]";
    }
});

var Plane = Class.extend({
    init: function() {
        this.normal = vec3.create();
        this.distance = 0;
    },
    setByPoints: function(p1, p2, p3) {
        this.normal = vec3.cross(vec3.create(), vec3.subtract(vec3.create(), p2, p1), vec3.subtract(vec3.create(), p3, p1));
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, p2);
    },
    setByNormalAndPoint: function(normal, point) {
        this.normal = vec3.clone(normal);
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, point);
    },
    getDistanceToPoint: function(point) {
        return vec3.dot(this.normal, point) + this.distance;
    },
    projectToPlane: function(point, out) {
        if (!out) out = vec3.create();
        vec3.scale(out, this.normal, this.getDistanceToPoint(point));
        vec3.sub(out, point, out);
        return out;
    },
    pointInFront: function(point) {
        return vec3.dot(this.normal, point) + this.distance > 0;
    },
    pointInBack: function(point) {
        return vec3.dot(this.normal, point) + this.distance < 0;
    },
    pointOnPlane: function(point) {
        return Math.abs(vec3.dot(this.normal, point) + this.distance) < EPSILON;
    },
    sameSide: function(p1, p2) {
        var d1 = vec3.dot(this.normal, p1) + this.distance;
        var d2 = vec3.dot(this.normal, p2) + this.distance;
        return !(d1 * d2 < 0);
    },
    toString: function() {
        return "Plane[" + this.normal[0] + ", " + this.normal[1] + ", " + this.normal[2] + ", " + this.distance + "]";
    }
});

var AABBPlaneCache = new Plane();

var Ray = Class.extend({
    init: function(origin, destination) {
        this.infinite = false;
        this.origin = vec3.create();
        this.destination = vec3.create();
        if (origin) vec3.copy(this.origin, origin);
        if (destination) vec3.copy(this.destination, destination);
    },
    clone: function() {
        var ray = new Ray(this.origin, this.destination);
        ray.infinite = this.infinite;
        return ray;
    },
    getLength: function() {
        return vec3.distance(this.origin, this.destination);
    },
    getDirection: function(out) {
        if (!out) out = vec3.create();
        this.getVector(out);
        vec3.normalize(out, out);
        return out;
    },
    getVector: function(out) {
        if (!out) out = vec3.create();
        vec3.subtract(out, this.destination, this.origin);
        return out;
    },
    transform: function(mat) {
        vec3.transformMat4(this.origin, this.origin, mat);
        vec3.transformMat4(this.destination, this.destination, mat);
    },
    transformWithLength: function(mat, length) {
        var rotscale = mat4.clone(mat);
        rotscale[12] = 0;
        rotscale[13] = 0;
        rotscale[14] = 0;
        var dir = this.getDirection();
        vec3.transformMat4(this.origin, this.origin, mat);
        vec3.transformMat4(dir, dir, rotscale);
        vec3.scale(dir, dir, length);
        vec3.add(this.destination, this.origin, dir);
    },
    getPointOnRay: function(t) {
        var p = vec3.create();
        var d = this.getVector();
        vec3.add(p, this.origin, vec3.scale(d, d, t));
        return p;
    },
    getClosestPointOnRay: function(point) {
        var dir = this.getDirection();
        var length = vec3.dot(dir, vec3.subtract(vec3.create(), point, this.origin));
        return vec3.add(vec3.create(), this.origin, vec3.scale(dir, dir, length));
    },
    distanceOfPoint: function(point) {
        if (vec3.dot(this.getDirection(), vec3.subtract(vec3.create(), point, this.origin)) <= 0) return vec3.distance(point, this.origin);
        return vec3.distance(vec3.cross(vec3.create(), this.getDirection(), vec3.subtract(vec3.create(), point, this.origin)));
    },
    intersectBoundingVolume: function(boundingVolume, result) {
        if (!(boundingVolume instanceof BoundingVolume) || !boundingVolume.center) return false;
        if (boundingVolume instanceof BoundingSphere) {
            return this.intersectSphere(boundingVolume.center, boundingVolume.radius, result);
        }
        if (boundingVolume instanceof BoundingBox) {
            return this.intersectAABB(boundingVolume.min, boundingVolume.max, result);
        }
        return false;
    },
    intersectPlane: function(plane, result) {
        if (plane.sameSide(this.origin, this.destination)) return false;
        var dir = this.getDirection();
        var t = -plane.getDistanceToPoint(this.origin) / vec3.dot(dir, plane.normal);
        if (result) result.add(vec3.add(vec3.create(), this.origin, vec3.scale(dir, dir, t)));
        return true;
    },
    intersectTriangle: function(p0, p1, p2, result) {
        var v0 = vec3.subtract(RayTestLocalCache[0], p2, p0);
        var v1 = vec3.subtract(RayTestLocalCache[1], p1, p0);
        var normal = vec3.cross(RayTestLocalCache[2], v1, v0);
        vec3.normalize(normal, normal);
        var d1 = vec3.dot(vec3.subtract(RayTestLocalCache[3], this.origin, p0), normal);
        var d2 = vec3.dot(vec3.subtract(RayTestLocalCache[3], this.destination, p0), normal);
        if (d1 * d2 >= 0) return false;
        var hit = this.getVector();
        hit = vec3.add(hit, this.origin, vec3.scale(hit, hit, -d1 / (d2 - d1)));
        var v2 = vec3.subtract(RayTestLocalCache[2], hit, p0);
        var dot00 = vec3.dot(v0, v0);
        var dot01 = vec3.dot(v0, v1);
        var dot02 = vec3.dot(v0, v2);
        var dot11 = vec3.dot(v1, v1);
        var dot12 = vec3.dot(v1, v2);
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        if (u >= 0 && v >= 0 && u + v <= 1) {
            if (result) result.add(hit);
            return true;
        }
        return false;
    },
    intersectTriangleDistanceOnly: function(p0, p1, p2) {
        var v0 = vec3.subtract(RayTestLocalCache[0], p2, p0);
        var v1 = vec3.subtract(RayTestLocalCache[1], p1, p0);
        var normal = vec3.cross(RayTestLocalCache[2], v1, v0);
        vec3.normalize(normal, normal);
        var d1 = vec3.dot(vec3.subtract(RayTestLocalCache[3], this.origin, p0), normal);
        var d2 = vec3.dot(vec3.subtract(RayTestLocalCache[3], this.destination, p0), normal);
        if (d1 * d2 >= 0) return false;
        var hit = this.getVector();
        var t = -d1 / (d2 - d1);
        hit = vec3.add(hit, this.origin, vec3.scale(hit, hit, t));
        var v2 = vec3.subtract(RayTestLocalCache[2], hit, p0);
        var dot00 = vec3.dot(v0, v0);
        var dot01 = vec3.dot(v0, v1);
        var dot02 = vec3.dot(v0, v2);
        var dot11 = vec3.dot(v1, v1);
        var dot12 = vec3.dot(v1, v2);
        var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        if (u >= 0 && v >= 0 && u + v <= 1) return t;
        return false;
    },
    intersectSphere: function(center, radius, result) {
        var v = vec3.sub(RayTestLocalCache[0], this.origin, center);
        var direction = this.getDirection();
        var dv = vec3.dot(direction, v);
        var tmp = dv * dv - vec3.dot(v, v) + radius * radius;
        if (Math.abs(tmp) < EPSILON) {
            if (result) result.add(vec3.add(vec3.create(), this.origin, vec3.scale(direction, direction, -dv)));
            return true;
        }
        if (tmp > 0) {
            if (result) {
                result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[0], direction, -dv - Math.sqrt(tmp))));
                result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[0], direction, -dv + Math.sqrt(tmp))));
            }
            return true;
        }
        return false;
    },
    intersectAABB: function(min, max, result) {
        var dir = this.getDirection(RayTestLocalCache[0]);
        var tmin = RayTestLocalCache[1];
        var tmax = RayTestLocalCache[2];
        dir[0] = 1 / dir[0];
        dir[1] = 1 / dir[1];
        dir[2] = 1 / dir[2];
        tmin[0] = (min[0] - this.origin[0]) * dir[0];
        tmax[0] = (max[0] - this.origin[0]) * dir[0];
        tmin[1] = (min[1] - this.origin[1]) * dir[1];
        tmax[1] = (max[1] - this.origin[1]) * dir[1];
        tmin[2] = (min[2] - this.origin[2]) * dir[2];
        tmax[2] = (max[2] - this.origin[2]) * dir[2];
        var t0 = Math.max(Math.min(tmin[0], tmax[0]), Math.min(tmin[1], tmax[1]), Math.min(tmin[2], tmax[2]));
        var t1 = Math.min(Math.max(tmin[0], tmax[0]), Math.max(tmin[1], tmax[1]), Math.max(tmin[2], tmax[2]));
        if (t1 < 0 || t0 > t1) return false;
        if (this.infinite) {
            if (result) {
                this.getDirection(dir);
                result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[1], dir, t0)));
                result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[1], dir, t1)));
            }
            return true;
        }
        if (t0 * t0 > vec3.sqrDist(this.origin, this.destination)) {
            if ((this.origin[0] < min[0] || this.origin[1] < min[1] || this.origin[2] < min[2] || this.origin[0] > max[0] || this.origin[1] > max[1] || this.origin[2] > max[2]) && (this.destination[0] < min[0] || this.destination[1] < min[1] || this.destination[2] < min[2] || this.destination[0] > max[0] || this.destination[1] > max[1] || this.destination[2] > max[2])) return false;
        }
        if (result) {
            this.getDirection(dir);
            result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[1], dir, t0)));
            result.add(vec3.add(vec3.create(), this.origin, vec3.scale(RayTestLocalCache[1], dir, t1)));
        }
        return true;
    },
    toString: function() {
        return "Ray(" + vec3.str(this.origin) + ", " + vec3.str(this.destination) + ", infinite = " + this.infinite + ")";
    }
});

var RayTestResult = Class.extend({
    init: function(ray) {
        this.ray = ray.clone();
        this.hits = [];
        this.addCallback = false;
    },
    add: function(point) {
        var item = {
            point: point,
            collider: false,
            submesh: false,
            node: false
        };
        if ($.isFunction(this.addCallback)) this.addCallback(item);
        this.hits.push(item);
    },
    empty: function() {
        return this.hits.length == 0;
    },
    sort: function() {
        var scope = this;
        this.hits.sort(function(a, b) {
            var da = vec3.sqrDist(scope.ray.origin, a.point);
            var db = vec3.sqrDist(scope.ray.origin, b.point);
            return da - db;
        });
    },
    nearest: function() {
        if (this.empty()) return false;
        var minDist = Infinity;
        var minIndex = 0;
        for (var i in this.hits) {
            var d = vec3.sqrDist(this.ray.origin, this.hits[i].point);
            if (d < minDist) {
                minDist = d;
                minIndex = i;
            }
        }
        return this.hits[minIndex];
    }
});

var RayTestLocalCache = [ vec3.create(), vec3.create(), vec3.create(), vec3.create() ];

var Submesh = Class.extend({
    init: function() {
        this.materialIndex = -1;
        this.faces = [];
        this.positions = [];
        this.texCoords1D = [];
        this.texCoords2D = [];
        this.texCoords3D = [];
        this.tangents = false;
        this.normals = false;
        this.bitangents = false;
        this.barycentric = false;
        this.boundingBox = new BoundingBox();
        this.boundingSphere = new BoundingSphere();
    },
    recalculateBounds: function() {
        this.boundingBox = new BoundingBox();
        this.boundingSphere = new BoundingSphere();
        for (var i = 0, l = this.positions.length; i < l; i += 3) {
            this.boundingBox.encapsulatePoint(vec3.fromValues(this.positions[i + 0], this.positions[i + 1], this.positions[i + 2]));
            this.boundingSphere.encapsulatePoint(vec3.fromValues(this.positions[i + 0], this.positions[i + 1], this.positions[i + 2]));
        }
    },
    generateEdges: function() {
        var me = this;
        this.edges = {};
        function insert(a, b) {
            if (!me.edges[me.faces[a]]) me.edges[a] = {};
            me.edges[me.faces[a]][me.faces[b]] = true;
        }
        for (var i = 0, l = this.faces.length; i < l; i += 3) {
            insert(i, i + 1);
            insert(i + 1, i);
            insert(i + 1, i + 2);
            insert(i + 2, i + 1);
            insert(i + 2, i);
            insert(i, i + 2);
        }
    }
});

var Mesh = Class.extend({
    init: function() {
        this.submeshes = [];
        this.materials = [];
        this.boundingBox = new BoundingBox();
        this.boundingSphere = new BoundingSphere();
    },
    addSubmesh: function(submesh, material) {
        this.boundingBox.encapsulateBox(submesh.boundingBox);
        this.boundingSphere.encapsulateSphere(submesh.boundingSphere);
        this.submeshes.push(submesh);
        if (material) {
            this.materials.push(material);
            submesh.materialIndex = this.materials.length - 1;
        }
    },
    getMaterial: function(index) {
        if (index >= 0 && index < this.materials.length) return this.materials[index];
        return false;
    },
    getPolycount: function() {
        var c = 0;
        for (var i in this.submeshes) c += this.submeshes[i].faces.length / 3;
        return c;
    },
    empty: function() {
        return this.submeshes.length === 0;
    }
});

var Primitives = {
    plane: function(width, height, material) {
        var mesh = new Mesh();
        var submesh = new Submesh();
        submesh.positions = [ -.5 * width, -.5 * height, 0, -.5 * width, .5 * height, 0, .5 * width, .5 * height, 0, .5 * width, -.5 * height, 0 ];
        submesh.normals = [ 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1 ];
        submesh.texCoords2D = [ [ 0, 0, 0, 1, 1, 1, 1, 0 ] ];
        submesh.faces = [ 0, 1, 2, 0, 2, 3 ];
        submesh.recalculateBounds();
        mesh.addSubmesh(submesh, material);
        var plane = new Node("Plane");
        plane.addComponent(new MeshComponent(mesh));
        plane.addComponent(new MeshRendererComponent());
        return plane;
    },
    box: function(center, extents, material) {
        var mesh = new Mesh();
        var submesh = new Submesh();
        submesh.positions = [];
        submesh.normals = [];
        submesh.texCoords2D = [ [] ];
        var normal = vec3.create();
        var v1 = vec3.create();
        var v2 = vec3.create();
        function createSide(a, b, c, d) {
            vec3.sub(v1, b, a);
            vec3.sub(v2, d, a);
            vec3.cross(normal, v1, v2);
            vec3.negate(normal, normal);
            vec3.normalize(normal, normal);
            var offset = submesh.positions.length / 3;
            submesh.positions.push(a[0], a[1], a[2]);
            submesh.normals.push(normal[0], normal[1], normal[2]);
            submesh.texCoords2D[0].push(0, 1);
            submesh.positions.push(b[0], b[1], b[2]);
            submesh.normals.push(normal[0], normal[1], normal[2]);
            submesh.texCoords2D[0].push(1, 1);
            submesh.positions.push(c[0], c[1], c[2]);
            submesh.normals.push(normal[0], normal[1], normal[2]);
            submesh.texCoords2D[0].push(1, 0);
            submesh.positions.push(d[0], d[1], d[2]);
            submesh.normals.push(normal[0], normal[1], normal[2]);
            submesh.texCoords2D[0].push(0, 0);
            submesh.faces.push(offset + 0, offset + 3, offset + 2);
            submesh.faces.push(offset + 2, offset + 1, offset + 0);
        }
        var points = [ vec3.fromValues(center[0] - extents[0], center[1] - extents[1], center[2] - extents[2]), vec3.fromValues(center[0] + extents[0], center[1] - extents[1], center[2] - extents[2]), vec3.fromValues(center[0] + extents[0], center[1] + extents[1], center[2] - extents[2]), vec3.fromValues(center[0] - extents[0], center[1] + extents[1], center[2] - extents[2]), vec3.fromValues(center[0] - extents[0], center[1] - extents[1], center[2] + extents[2]), vec3.fromValues(center[0] + extents[0], center[1] - extents[1], center[2] + extents[2]), vec3.fromValues(center[0] + extents[0], center[1] + extents[1], center[2] + extents[2]), vec3.fromValues(center[0] - extents[0], center[1] + extents[1], center[2] + extents[2]) ];
        createSide(points[0], points[1], points[2], points[3]);
        createSide(points[5], points[4], points[7], points[6]);
        createSide(points[4], points[0], points[3], points[7]);
        createSide(points[1], points[5], points[6], points[2]);
        createSide(points[4], points[5], points[1], points[0]);
        createSide(points[3], points[2], points[6], points[7]);
        submesh.recalculateBounds();
        mesh.addSubmesh(submesh, material);
        var box = new Node("Box");
        box.addComponent(new MeshComponent(mesh));
        box.addComponent(new MeshRendererComponent());
        return box;
    }
};

var CollisionOctreeNode = Class.extend({
    init: function(center, size, parent) {
        this.parent = false;
        this.depth = 0;
        this.subnodes = false;
        this.bounds = false;
        if (parent) {
            this.parent = parent;
            this.root = parent.root;
            this.depth = parent.depth + 1;
        } else {
            this.maxDepth = 3;
            this.root = this;
            this.nodes = [];
            this.submeshes = [];
            this.cache = [ vec3.create(), vec3.create(), vec3.create(), vec3.create(), vec3.create() ];
        }
        this.faces = false;
        this.setSize(center, size);
    },
    getNodeID: function() {
        var id = "/";
        var subnodeIndex = "root";
        if (this.parent) {
            id = this.parent.getNodeID();
            for (var subnode in this.parent.subnodes) {
                if (this.parent.subnodes[subnode] === this) {
                    subnodeIndex = subnode;
                    break;
                }
            }
        }
        return "{0}{1}/".format(id, subnodeIndex);
    },
    setSize: function(center, size) {
        this.bounds = new BoundingBox(center, [ size, size, size ]);
    },
    isLeaf: function() {
        return this.subnodes === false;
    },
    hasGeometry: function() {
        return this.faces !== false;
    },
    subdivide: function() {
        this.subnodes = [];
        var size = this.bounds.size[0] * .5;
        var extent = size * .5;
        var c = vec3.create();
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ extent, extent, extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ -extent, extent, extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ extent, -extent, extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ -extent, -extent, extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ extent, extent, -extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ -extent, extent, -extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ extent, -extent, -extent ]), size, this));
        this.subnodes.push(new CollisionOctreeNode(vec3.add(c, this.bounds.center, [ -extent, -extent, -extent ]), size, this));
    },
    optimize: function() {
        if (!this.isLeaf()) {
            for (var i in this.subnodes) this.subnodes[i].optimize();
            var empty = 0;
            for (var i in this.subnodes) {
                if (!this.subnodes[i].hasGeometry() && this.subnodes[i].isLeaf()) empty++;
            }
            if (empty == 8) {
                delete this.subnodes;
                this.subnodes = false;
            }
        }
    },
    rayIntersectBounds: function(ray) {
        var dir = ray.getDirection(this.root.cache[0]);
        var tmin = this.root.cache[1];
        var tmax = this.root.cache[2];
        dir[0] = 1 / dir[0];
        dir[1] = 1 / dir[1];
        dir[2] = 1 / dir[2];
        tmin[0] = (this.bounds.min[0] - ray.origin[0]) * dir[0];
        tmax[0] = (this.bounds.max[0] - ray.origin[0]) * dir[0];
        tmin[1] = (this.bounds.min[1] - ray.origin[1]) * dir[1];
        tmax[1] = (this.bounds.max[1] - ray.origin[1]) * dir[1];
        tmin[2] = (this.bounds.min[2] - ray.origin[2]) * dir[2];
        tmax[2] = (this.bounds.max[2] - ray.origin[2]) * dir[2];
        var t0 = Math.max(Math.min(tmin[0], tmax[0]), Math.min(tmin[1], tmax[1]), Math.min(tmin[2], tmax[2]));
        var t1 = Math.min(Math.max(tmin[0], tmax[0]), Math.max(tmin[1], tmax[1]), Math.max(tmin[2], tmax[2]));
        if (t1 < 0 || t0 > t1) return false;
        if (ray.infinite) return t0;
        if (t0 * t0 > vec3.sqrDist(ray.origin, ray.destination)) {
            if ((ray.origin[0] < this.bounds.min[0] || ray.origin[1] < this.bounds.min[1] || ray.origin[2] < this.bounds.min[2] || ray.origin[0] > this.bounds.max[0] || ray.origin[1] > this.bounds.max[1] || ray.origin[2] > this.bounds.max[2]) && (ray.destination[0] < this.bounds.min[0] || ray.destination[1] < this.bounds.min[1] || ray.destination[2] < this.bounds.min[2] || ray.destination[0] > this.bounds.max[0] || ray.destination[1] > this.bounds.max[1] || ray.destination[2] > this.bounds.max[2])) return false;
        }
        return t0;
    },
    rayIntersectGeometry: function(worldRay) {
        if (!this.hasGeometry()) return false;
        var result = {
            submesh: false,
            node: false,
            t: Infinity,
            normal: vec3.create()
        };
        var a = this.root.cache[0];
        var b = this.root.cache[1];
        var c = this.root.cache[2];
        var inv = mat4.create();
        for (var nodeIndex in this.faces) {
            var localRay = worldRay.clone();
            if (!mat4.isIdentity(this.root.nodes[nodeIndex].transform.absolute)) {
                mat4.invert(inv, this.root.nodes[nodeIndex].transform.absolute);
                localRay.transform(inv);
            }
            for (var meshIndex in this.faces[nodeIndex]) {
                var faces = this.faces[nodeIndex][meshIndex];
                var positions = this.root.submeshes[meshIndex].positions;
                for (var i = 0; i < faces.length; i += 3) {
                    a[0] = positions[faces[i] * 3];
                    a[1] = positions[faces[i] * 3 + 1];
                    a[2] = positions[faces[i] * 3 + 2];
                    b[0] = positions[faces[i + 1] * 3];
                    b[1] = positions[faces[i + 1] * 3 + 1];
                    b[2] = positions[faces[i + 1] * 3 + 2];
                    c[0] = positions[faces[i + 2] * 3];
                    c[1] = positions[faces[i + 2] * 3 + 1];
                    c[2] = positions[faces[i + 2] * 3 + 2];
                    var t = localRay.intersectTriangleDistanceOnly(a, b, c);
                    if (t !== false) {
                        if (t < result.t) {
                            result.t = t;
                            result.submesh = this.root.submeshes[meshIndex];
                            result.node = this.root.nodes[nodeIndex];
                            vec3.cross(result.normal, vec3.subtract(this.root.cache[3], b, a), vec3.subtract(this.root.cache[4], c, a));
                            vec3.normalize(result.normal, result.normal);
                        }
                    }
                }
            }
        }
        return result;
    },
    getNodesWithGeometry: function(ray, list) {
        var t = this.rayIntersectBounds(ray);
        if (t !== false) {
            if (this.hasGeometry()) {
                var i = 0;
                for (;i < list.length; i++) {
                    if (list[i].t > t) break;
                }
                list.splice(i, 0, {
                    t: t,
                    octreeNode: this
                });
            }
            if (!this.isLeaf()) {
                for (var i in this.subnodes) this.subnodes[i].getNodesWithGeometry(ray, list);
            }
        }
    },
    getNearestRayCollision: function(localRay, worldRay) {
        var nodes = [];
        this.getNodesWithGeometry(localRay, nodes);
        var result = {
            t: Infinity,
            octreeNode: false,
            submesh: false,
            node: false,
            normal: false
        };
        for (var i = 0; i < nodes.length; i++) {
            if (result.octreeNode !== false && nodes[i].depth == result.octreeNode.depth && nodes[i].t > result.t) {
                continue;
            }
            var collision = nodes[i].octreeNode.rayIntersectGeometry(worldRay);
            if (collision.t < result.t) {
                result.t = collision.t;
                result.submesh = collision.submesh;
                result.octreeNode = nodes[i].octreeNode;
                result.node = collision.node;
                result.normal = collision.normal;
            }
        }
        return result;
    }
});

var Component = Serializable.extend({
    init: function() {
        this._super();
        this.updatePasses = 1;
        this.started = false;
        this.node = false;
        this.enable();
    },
    excluded: function() {
        return [ "started", "node" ];
    },
    getScene: function() {
        return this.node.scene;
    },
    enable: function() {
        if (!this.enabled) this.onEnable();
        this.enabled = true;
    },
    disable: function() {
        if (this.enabled) this.onDisable();
        this.enabled = false;
    },
    instantiate: function() {
        var instance = this.clone();
        return instance;
    },
    onAdd: function(node) {},
    onRemove: function(node) {},
    onAddScene: function(node) {},
    onRemoveScene: function(node) {},
    onEnable: function() {},
    onDisable: function() {},
    onStart: function(context, engine) {},
    start: function(context, engine) {
        this.onStart(context, engine);
    },
    onLoad: function(assetsManager, engine) {},
    onEnd: function(context, engine) {},
    onPreRender: function(context, camera) {},
    onPostRender: function(context, camera) {},
    onUpdateTransform: function(absolute) {},
    onUpdate: function(engine, pass) {}
});

var CameraComponent = Component.extend({
    init: function(viewMatrix, projectionMatrix) {
        if (!viewMatrix || !projectionMatrix) {
            throw "CameraComponent can be initialized only with given viewMatrix and projectionMatrix. Normally one should create OrthoCamera or PerspectiveCamera instead";
        }
        this._super();
        this.camera = new Camera(viewMatrix, projectionMatrix, new PostProcessRenderStage());
    },
    excluded: function() {
        return this._super().concat([ "camera" ]);
    },
    type: function() {
        return "CameraComponent";
    },
    onAddScene: function(node) {
        node.scene.cameras.push(this.camera);
        node.scene.cameras.sort(function(a, b) {
            return a.order - b.order;
        });
        this.useCameraViewMatrix();
    },
    onRemoveScene: function(node) {
        var cameras = node.scene.cameras;
        for (var i = 0; i < cameras.length; i++) {
            if (cameras[i] == this.camera) {
                cameras.splice(i, 1);
                i--;
            }
        }
    },
    onStart: function(context, engine) {
        if (this.camera.target instanceof TargetScreen) {
            var pos = context.canvas.parent().position();
            this.camera.target.setPosition(pos.left, pos.top);
            this.camera.target.setSize(context.canvas.width(), context.canvas.height());
        }
        if (engine.options.transparencyMode == "blended" || engine.options.transparencyMode == "stochastic") {
            this.camera.renderStage.addStage(new OITPostProcess());
        }
        if (engine.options.antialias === true) {
            this.camera.renderStage.addStage(new AntiAliasPostProcess());
        }
        this.camera.renderStage.start(context, engine, this.camera);
    },
    onUpdateTransform: function(absolute) {
        if (!this.node.transform) return;
        mat4.invert(this.camera.viewMatrix, this.node.transform.absolute);
    },
    lookAt: function(target, up) {
        if (!up) up = [ 0, 1, 0 ];
        mat4.lookAt(this.camera.viewMatrix, this.camera.getPosition(), target, up);
        this.useCameraViewMatrix();
    },
    setPosition: function(position) {
        this.camera.setPosition(position);
        this.useCameraViewMatrix();
    },
    center: function(point) {
        this.camera.center(point);
        this.useCameraViewMatrix();
    },
    fitToView: function(boundingVolume) {
        this.camera.fitToView(boundingVolume);
        this.useCameraViewMatrix();
    },
    fitNodeToView: function(node) {
        var bounds = new BoundingBox();
        node.onEachChild(function(subnode) {
            if (subnode.getComponent(MeshComponent)) {
                var meshComponent = subnode.getComponent(MeshComponent);
                bounds.encapsulateBox(meshComponent.mesh.boundingBox.transform(subnode.transform.absolute));
            }
        });
        this.fitToView(bounds);
    },
    screenPointToViewportPoint: function(point) {
        var p = vec2.create();
        var pos = vec2.create();
        if (this.camera.target instanceof TargetScreen) pos = this.camera.target.getPosition();
        var size = this.camera.target.getSize();
        if (Math.abs(size[0]) < EPSILON || Math.abs(size[1]) < EPSILON) return p;
        p[0] = (point[0] - pos[0]) / size[0];
        p[1] = (point[1] - pos[1]) / size[1];
        return p;
    },
    unprojectScreenPoint: function(point) {
        var size = this.node.scene.camera.target.getSize();
        var offset = vec2.create();
        var p = vec2.fromValues(point[0] - offset[0], size[1] - point[1] + offset[1]);
        if (Math.abs(size[0]) < EPSILON || Math.abs(size[1]) < EPSILON) return false;
        var pt = vec4.fromValues(2 * (p[0] / size[0]) - 1, 2 * (p[1] / size[1]) - 1, 2 * point[2] - 1, 1);
        var mat = mat4.mul(mat4.create(), this.camera.projectionMatrix, this.camera.viewMatrix);
        if (mat4.invert(mat, mat)) {
            vec4.transformMat4(pt, pt, mat);
            if (Math.abs(pt[3]) < EPSILON) return false;
            pt[3] = 1 / pt[3];
            return vec3.fromValues(pt[0] * pt[3], pt[1] * pt[3], pt[2] * pt[3]);
        }
        return false;
    },
    screenPointToRay: function(point) {
        var near = this.unprojectScreenPoint([ point[0], point[1], 0 ]);
        var far = this.unprojectScreenPoint([ point[0], point[1], 1 ]);
        if (near && far) return new Ray(near, far);
        return false;
    },
    useCameraViewMatrix: function() {
        if (!this.node.transform) return;
        this.node.transform.absolute = mat4.invert(mat4.create(), this.camera.viewMatrix);
        this.node.calculateRelativeFromAbsolute();
    }
});

var PerspectiveCamera = CameraComponent.extend({
    init: function(fov, aspect, near, far) {
        if (!fov) fov = 45;
        if (!near) near = .3;
        if (!far) far = 1e3;
        if (!aspect) aspect = 4 / 3;
        this.fov = fov;
        this.aspect = aspect;
        this.near = near;
        this.far = far;
        var lookAt = mat4.create();
        mat4.lookAt(lookAt, [ 0, 0, -100 ], [ 0, 0, 0 ], [ 0, 1, 0 ]);
        this._super(lookAt, this.calculatePerspective());
        this.camera.near = this.near;
        this.camera.far = this.far;
    },
    type: function() {
        return "PerspectiveCamera";
    },
    onStart: function(context, engine) {
        if (!this.aspect) {
            this.setAspectRatio(context.canvas.width() / context.canvas.height());
        }
        this._super(context, engine);
    },
    setClipPlanes: function(near, far) {
        this.near = near;
        this.far = far;
        this.camera.near = this.near;
        this.camera.far = this.far;
        this.camera.projectionMatrix = this.calculatePerspective();
    },
    setAspectRatio: function(aspect) {
        this.aspect = aspect;
        this.camera.projectionMatrix = this.calculatePerspective();
    },
    setVerticalFieldOfView: function(fov) {
        this.fov = fov;
        this.camera.projectionMatrix = this.calculatePerspective();
    },
    setHorizontalFieldOfView: function(fov) {
        fov = fov * (Math.PI * 2) / 360;
        var hpx = Math.tan(fov / 2);
        var vpx = hpx / this.aspect;
        this.fov = Math.atan(vpx) * 2 * 180 / Math.PI;
        this.camera.projectionMatrix = this.calculatePerspective();
    },
    getVerticalFieldOfView: function() {
        return this.camera.getFieldOfView() * 180 / Math.PI;
    },
    getHorizontalFieldOfView: function() {
        var vpx = Math.tan(this.camera.getFieldOfView() * .5);
        var hpx = this.aspect * vpx;
        var fovx = Math.atan(hpx) * 2;
        return fovx * 180 / Math.PI;
    },
    calculatePerspective: function() {
        var perspective = mat4.create();
        var aspect = this.aspect;
        if (!aspect) aspect = 1;
        mat4.perspective(perspective, this.fov * (Math.PI * 2) / 360, aspect, this.near, this.far);
        return perspective;
    }
});

var OrthoCamera = CameraComponent.extend({
    init: function(left, right, bottom, top, near, far) {
        if (!left) left = 0;
        if (!right) right = 512;
        if (!bottom) bottom = 512;
        if (!top) top = 0;
        if (!near) near = -100;
        if (!far) far = 100;
        var projection = mat4.ortho(mat4.create(), left, right, bottom, top, near, far);
        this._super(mat4.identity(mat4.create()), projection);
    },
    type: function() {
        return "OrthoCamera";
    }
});

var MeshComponent = Component.extend({
    init: function(mesh) {
        this.mesh = mesh;
        this._super();
    },
    type: function() {
        return "MeshComponent";
    },
    instantiate: function() {
        var c = this._super();
        c.mesh = this.mesh;
        return c;
    }
});

var RendererComponent = Component.extend({
    init: function() {
        this._super();
        this.castShadows = true;
    },
    type: function() {
        return "RendererComponent";
    },
    instantiate: function() {
        var instance = this._super();
        instance.castShadows = this.castShadows;
        return instance;
    }
});

var MeshRendererComponent = RendererComponent.extend({
    init: function() {
        this._super();
        this.meshRenderers = [];
    },
    type: function() {
        return "MeshRendererComponent";
    },
    excluded: function() {
        return this._super().concat([ "meshRenderers" ]);
    },
    createRenderer: function(context, matrix, submesh, material) {
        return new SubmeshRenderer(context, matrix, submesh, material);
    },
    onStart: function(context, engine) {
        this.updateRenderers(context, engine);
    },
    addRenderers: function(context, engine) {
        var me = this;
        this.node.onEachComponent(function(component) {
            if (component instanceof MeshComponent) {
                for (var submeshIndex in component.mesh.submeshes) {
                    var submesh = component.mesh.submeshes[submeshIndex];
                    var material = component.mesh.getMaterial(submesh.materialIndex);
                    if (!material) {
                        console.log(" *** Failed to to find submesh material in node: ", component.node.name, component.node);
                        continue;
                    }
                    var submeshRenderer = me.createRenderer(context, me.node.transform.absolute, submesh, material);
                    me.getScene().dynamicSpace.addRenderer(submeshRenderer);
                    me.meshRenderers.push(submeshRenderer);
                    if (!me.enabled) submeshRenderer.visible = false;
                }
            }
        });
    },
    removeRenderers: function() {
        for (var r in this.meshRenderers) {
            this.getScene().dynamicSpace.removeRenderer(this.meshRenderers[r]);
        }
    },
    updateRenderers: function(context, engine) {
        this.removeRenderers();
        this.addRenderers(context, engine);
    },
    onEnd: function(context) {
        this.removeRenderers();
    },
    onUpdateTransform: function(absolute) {
        for (var renderer in this.meshRenderers) {
            this.meshRenderers[renderer].layer = this.node.layer;
            this.meshRenderers[renderer].castShadows = this.castShadows;
            this.meshRenderers[renderer].setMatrix(absolute);
        }
    },
    onEnable: function() {
        for (var i in this.meshRenderers) this.meshRenderers[i].visible = true;
    },
    onDisable: function() {
        for (var i in this.meshRenderers) this.meshRenderers[i].visible = false;
    },
    getBoundingBox: function(excludeInvisible) {
        var bounds = new BoundingBox();
        for (var i in this.meshRenderers) {
            if (excludeInvisible && !this.meshRenderers[i].visible) continue;
            bounds.encapsulateBox(this.meshRenderers[i].globalBoundingBox);
        }
        return bounds;
    },
    getBoundingSphere: function(excludeInvisible) {
        var bounds = new BoundingSphere();
        for (var i in this.meshRenderers) {
            if (excludeInvisible && !this.meshRenderers[i].visible) continue;
            bounds.encapsulateSphere(this.meshRenderers[i].globalBoundingSphere);
        }
        return bounds;
    },
    setTransparency: function(value) {
        value = !!value;
        for (var i in this.meshRenderers) {
            this.meshRenderers[i].transparent = value;
        }
    }
});

var TextRendererComponent = MeshRendererComponent.extend({
    type: function() {
        return "TextRendererComponent";
    },
    createRenderer: function(context, matrix, submesh, material) {
        return new FontRenderer(context, matrix, submesh, material);
    }
});

var TextComponent = MeshComponent.extend({
    init: function(text, fontSourceDescriptor) {
        if (!fontSourceDescriptor) {
            fontSourceDescriptor = new FontSourceDescriptor("fonts/default.json");
        }
        this.fontSourceDescriptor = fontSourceDescriptor;
        this.fontSource = false;
        this.alignment = "center";
        this._super(new Mesh());
        this.engine = false;
        this.context = false;
        this.submeshes = {};
        this.loaded = false;
        this.setText(text);
    },
    excluded: function() {
        return this._super().concat([ "material", "engine", "context", "fontSource" ]);
    },
    type: function() {
        return "TextComponent";
    },
    onStart: function(context, engine) {
        this.context = context;
        this.engine = engine;
        if (!this.fontSource) {
            this.fontSource = engine.assetsManager.fontSourcesManager.addDescriptor(this.fontSourceDescriptor);
            var me = this;
            engine.assetsManager.load(function() {
                me.loaded = true;
                me.generateTextMesh();
                me.updateTextRenderer();
            });
        }
    },
    updateTextRenderer: function() {
        var me = this;
        this.node.onEachComponent(function(c) {
            if (c instanceof TextRendererComponent) c.updateRenderers(me.context, me.engine);
        });
    },
    setText: function(text) {
        this.text = String(text);
        this.generateTextMesh();
    },
    generateTextMesh: function() {
        if (!this.loaded) return;
        var fontData = this.fontSource.font.data;
        if (!fontData) {
            console.log("Warning: font data not available!", this.fontSource);
        }
        var text = this.text;
        var submeshPositions = {};
        var position = vec2.create();
        var size = vec2.create();
        for (var i in text) {
            var c = text.charCodeAt(i);
            if (!fontData.characters[c]) continue;
            var cData = fontData.characters[c];
            size = cData.size;
            var offset = vec2.fromValues(0, -cData.offset[1] + fontData.baseline - size[1]);
            var rectangle = [ cData.normalizedPosition, vec2.subtract(vec2.create(), cData.normalizedPosition, cData.normalizedSize) ];
            var kerning = 0;
            if (i < text.length - 1) {
                var nc = text.charCodeAt(i);
                if (fontData.kernings[c] && fontData.kernings[c][nc]) kerning = fontData.kernings[c][nc];
            }
            var submesh = this.getPageSubmesh(cData.page);
            if (!submeshPositions[cData.page]) submeshPositions[cData.page] = 0;
            var p = submeshPositions[cData.page];
            submeshPositions[cData.page]++;
            submesh.positions[(p * 4 + 0) * 3] = offset[0] + position[0];
            submesh.positions[(p * 4 + 0) * 3 + 1] = offset[1];
            submesh.positions[(p * 4 + 0) * 3 + 2] = 0;
            submesh.positions[(p * 4 + 1) * 3] = offset[0] + position[0] + size[0];
            submesh.positions[(p * 4 + 1) * 3 + 1] = offset[1];
            submesh.positions[(p * 4 + 1) * 3 + 2] = 0;
            submesh.positions[(p * 4 + 2) * 3] = offset[0] + position[0] + size[0];
            submesh.positions[(p * 4 + 2) * 3 + 1] = offset[1] + size[1];
            submesh.positions[(p * 4 + 2) * 3 + 2] = 0;
            submesh.positions[(p * 4 + 3) * 3] = offset[0] + position[0];
            submesh.positions[(p * 4 + 3) * 3 + 1] = offset[1] + size[1];
            submesh.positions[(p * 4 + 3) * 3 + 2] = 0;
            for (var j = 0; j < 4; j++) {
                submesh.normals[(p * 4 + j) * 3 + 0] = 0;
                submesh.normals[(p * 4 + j) * 3 + 1] = 0;
                submesh.normals[(p * 4 + j) * 3 + 2] = 1;
            }
            submesh.texCoords2D[0][(p * 4 + 0) * 2 + 0] = rectangle[0][0];
            submesh.texCoords2D[0][(p * 4 + 0) * 2 + 1] = rectangle[0][1];
            submesh.texCoords2D[0][(p * 4 + 1) * 2 + 0] = rectangle[1][0];
            submesh.texCoords2D[0][(p * 4 + 1) * 2 + 1] = rectangle[0][1];
            submesh.texCoords2D[0][(p * 4 + 2) * 2 + 0] = rectangle[1][0];
            submesh.texCoords2D[0][(p * 4 + 2) * 2 + 1] = rectangle[1][1];
            submesh.texCoords2D[0][(p * 4 + 3) * 2 + 0] = rectangle[0][0];
            submesh.texCoords2D[0][(p * 4 + 3) * 2 + 1] = rectangle[1][1];
            submesh.faces[p * 6 + 0] = p * 4 + 0;
            submesh.faces[p * 6 + 1] = p * 4 + 1;
            submesh.faces[p * 6 + 2] = p * 4 + 3;
            submesh.faces[p * 6 + 3] = p * 4 + 1;
            submesh.faces[p * 6 + 4] = p * 4 + 2;
            submesh.faces[p * 6 + 5] = p * 4 + 3;
            position[0] += size[0] + kerning;
        }
        for (var s in this.submeshes) {
            var submesh = this.submeshes[s];
            if (this.alignment) {
                var offset = 0;
                if (this.alignment == "center") offset = -position[0] / 2;
                if (this.alignment == "right") offset = -position[0];
                for (var i = 0; i < submesh.positions.length; i += 3) {
                    submesh.positions[i] += offset;
                }
            }
            submesh.recalculateBounds();
            submesh.materialIndex = 0;
            this.mesh.addSubmesh(submesh);
        }
        this.mesh.materials = [ this.fontSource.font.materialSource.material ];
        this.onTextSet();
    },
    onTextSet: function() {},
    calculateCharactersOnPage: function(page) {
        var count = 0;
        var fontData = this.fontSource.font.data;
        for (var i in fontData.characters) {
            var cData = fontData.characters[i];
            if (cData.page == page) count++;
        }
        return count;
    },
    getPageSubmesh: function(page) {
        if (this.submeshes[page]) return this.submeshes[page];
        var submesh = new Submesh();
        var characterCount = this.calculateCharactersOnPage(page);
        submesh.page = new UniformInt(page);
        submesh.faces = new Array(2 * 3 * characterCount);
        submesh.positions = new Array(3 * 4 * characterCount);
        submesh.normals = new Array(3 * 4 * characterCount);
        submesh.texCoords2D = [ new Array(2 * 4 * characterCount) ];
        this.submeshes[page] = submesh;
        return submesh;
    }
});

var Controller = Component.extend({
    init: function() {
        this._super();
        this.delta = vec2.create();
        this.dragDelta = vec2.create();
        this.position = false;
        this.oldPosition = false;
        this.startDragPosition = false;
        this.buttons = [ false, false, false ];
        this.keyStates = {};
        this.bindings = {};
        this.canvas = false;
        this.keymap = {
            enter: 13,
            escape: 27,
            backspace: 8,
            tab: 9,
            shift: 16,
            ctrl: 17,
            alt: 18,
            pause: 19,
            caps_lock: 20,
            page_up: 33,
            page_down: 34,
            end: 35,
            home: 36,
            left_arrow: 37,
            up_arrow: 38,
            right_arrow: 39,
            down_arrow: 40,
            insert: 45,
            "delete": 46,
            left_window_key: 91,
            right_window_key: 92,
            select_key: 93,
            numpad_0: 96,
            numpad_1: 97,
            numpad_2: 98,
            numpad_3: 99,
            numpad_4: 100,
            numpad_5: 101,
            numpad_6: 102,
            numpad_7: 103,
            numpad_8: 104,
            numpad_9: 105,
            multiply: 106,
            add: 107,
            subtract: 109,
            decimal_point: 110,
            divide: 111,
            f1: 112,
            f2: 113,
            f3: 114,
            f4: 115,
            f5: 116,
            f6: 117,
            f7: 118,
            f8: 119,
            f9: 120,
            f10: 121,
            f11: 122,
            f12: 123,
            num_lock: 144,
            scroll_lock: 145,
            semi_colon: 186,
            equal_sign: 187,
            comma: 188,
            dash: 189,
            period: 190,
            forward_slash: 191,
            grave_accent: 192,
            open_bracket: 219,
            back_slash: 220,
            close_braket: 221,
            single_quote: 222,
            "0": 48,
            "1": 49,
            "2": 50,
            "3": 51,
            "4": 52,
            "5": 53,
            "6": 54,
            "7": 55,
            "8": 56,
            "9": 57,
            a: 65,
            b: 66,
            c: 67,
            d: 68,
            e: 69,
            f: 70,
            g: 71,
            h: 72,
            i: 73,
            j: 74,
            k: 75,
            l: 76,
            m: 77,
            n: 78,
            o: 79,
            p: 80,
            q: 81,
            r: 82,
            s: 83,
            t: 84,
            u: 85,
            v: 86,
            w: 87,
            x: 88,
            y: 89,
            z: 90
        };
    },
    excluded: function() {
        return this._super().concat([ "delta", "dragDelta", "position", "oldPosition", "startDragPosition", "buttons", "keyStates" ]);
    },
    type: function() {
        return "Controller";
    },
    bind: function(key, callback) {
        if (key in this.keymap) this.bindings[this.keymap[key]] = callback; else this.bindings[key.charCodeAt(0)] = callback;
    },
    keyDown: function(key) {
        if (!this.enabled) return;
        this.keyStates[key] = true;
        this.onKeyDown(key);
        this.onKeyStateChange(key, true);
    },
    keyUp: function(key) {
        if (!this.enabled) return;
        delete this.keyStates[key];
        this.onKeyUp(key);
        this.onKeyStateChange(key, false);
    },
    mouseMove: function(position) {
        if (!this.enabled) return;
        this.position = position;
        if (this.oldPosition) {
            vec2.subtract(this.delta, this.oldPosition, this.position);
            this.onMouseMove(this.position, this.buttons, this.delta);
        }
        this.oldPosition = this.position;
    },
    mouseDown: function(position, button) {
        if (!this.enabled) return;
        this.buttons[button] = true;
        this.position = position;
        this.startDragPosition = vec2.clone(this.position);
        this.onButtonDown(this.position, button, this.delta);
    },
    mouseUp: function(position, button) {
        if (!this.enabled) return;
        this.buttons[button] = false;
        this.position = position;
        if (this.startDragPosition) vec2.subtract(this.dragDelta, this.position, this.startDragPosition);
        this.onButtonUp(this.position, button, this.delta);
    },
    click: function(button) {
        if (!this.enabled) return;
        this.onClick(this.position, button, this.dragDelta);
    },
    processKeyEvents: function(engine) {
        for (var key in this.keyStates) {
            this.onKey(key, engine.fps.getDelta() / 1e3);
        }
    },
    onStart: function(context, engine) {
        var me = this;
        this.canvas = context.canvas;
        this.buttons = [ false, false, false ];
        context.canvas.contextmenu(function() {
            return false;
        });
        context.canvas.attr("tabindex", "0");
        context.canvas.keydown(function(event) {
            me.keyDown(event.which);
        });
        context.canvas.keyup(function(event) {
            me.keyUp(event.which);
        });
        context.canvas.mousemove(function(event) {
            var offset = context.canvas.offset();
            var relX = event.pageX - offset.left;
            var relY = event.pageY - offset.top;
            me.mouseMove([ relX, relY ]);
        });
        context.canvas.mousedown(function(event) {
            var offset = context.canvas.offset();
            var relX = event.pageX - offset.left;
            var relY = event.pageY - offset.top;
            me.mouseDown([ relX, relY ], event.button);
        });
        context.canvas.mouseup(function(event) {
            var offset = context.canvas.offset();
            var relX = event.pageX - offset.left;
            var relY = event.pageY - offset.top;
            me.mouseUp([ relX, relY ], event.button);
        });
        context.canvas.click(function(event) {
            $(this).focus();
            me.click(event.button);
        });
    },
    onUpdate: function(engine) {
        this.processKeyEvents(engine);
    },
    onKey: function(keyCode, deltaTime) {
        if (this.bindings[keyCode]) {
            var method = this.bindings[keyCode];
            this[method](deltaTime);
        }
    },
    onKeyStateChange: function(key, state) {},
    onKeyDown: function(key) {},
    onKeyUp: function(key) {},
    onButtonDown: function(position, button, delta) {},
    onButtonUp: function(position, button, delta) {},
    onClick: function(position, button, delta) {},
    onMouseMove: function(position, buttons, delta) {}
});

var FlightController = Controller.extend({
    init: function() {
        this._super();
        this.bind("W", "accelerate");
        this.bind("S", "decelerate");
        this.bind("A", "strafeLeft");
        this.bind("D", "strafeRight");
        this.bind("up_arrow", "accelerate");
        this.bind("down_arrow", "decelerate");
        this.bind("left_arrow", "strafeLeft");
        this.bind("right_arrow", "strafeRight");
        this.rotation = vec3.create();
        this.velocity = vec3.fromValues(0, 0, 0);
        this.angularVelocity = vec3.fromValues(0, 0, 0);
        this.acceleration = .2;
        this.deceleration = .2;
        this.friction = .01;
        this.rotationAcceleration = .001;
        this.rotationFriction = .1;
    },
    type: function() {
        return "FlightController";
    },
    accelerate: function(deltaTime) {
        this.addLocalImpulse([ 0, 0, -this.acceleration * deltaTime ]);
    },
    decelerate: function(deltaTime) {
        this.addLocalImpulse([ 0, 0, this.deceleration * deltaTime ]);
    },
    strafeLeft: function(deltaTime) {
        this.addLocalImpulse([ -this.deceleration * deltaTime, 0, 0 ]);
    },
    strafeRight: function(deltaTime) {
        this.addLocalImpulse([ this.deceleration * deltaTime, 0, 0 ]);
    },
    addLocalImpulse: function(impulse) {
        var relativeImpulse = vec3.create();
        var rotation = quat.create();
        quat.fromMat4(rotation, this.node.transform.absolute);
        vec3.transformQuat(relativeImpulse, impulse, rotation);
        vec3.add(this.velocity, this.velocity, relativeImpulse);
    },
    onStep: function(oldPosition, newPosition, rotation) {
        return true;
    },
    onUpdate: function(engine, pass) {
        this._super(engine, pass);
        var td = engine.fps.getDelta();
        var ff = 1 + this.friction * td;
        vec3.scale(this.velocity, this.velocity, 1 / ff);
        var rf = 1 + this.rotationFriction * td;
        vec3.scale(this.angularVelocity, this.angularVelocity, 1 / rf);
        var temporaryVelocity = vec3.scale(vec3.create(), this.velocity, td);
        var temporaryAngularVelocity = vec3.scale(vec3.create(), this.angularVelocity, td);
        vec3.add(this.rotation, this.rotation, temporaryAngularVelocity);
        var rotation = quat.create();
        quat.rotateY(rotation, rotation, this.rotation[1]);
        quat.rotateX(rotation, rotation, this.rotation[0]);
        var oldPosition = mat4.translation(vec3.create(), this.node.transform.relative);
        var newPosition = vec3.add(vec3.create(), temporaryVelocity, oldPosition);
        if (this.onStep(oldPosition, newPosition, rotation)) mat4.fromRotationTranslation(this.node.transform.relative, rotation, newPosition);
    },
    onMouseMove: function(position, buttons, delta) {
        if (!buttons[0]) return;
        var impulse = vec3.create();
        var ra = this.rotationAcceleration;
        vec3.scale(impulse, [ delta[1], delta[0], 0 ], ra);
        vec3.add(this.angularVelocity, this.angularVelocity, impulse);
    }
});

var OrbitController = FlightController.extend({
    init: function() {
        this._super();
        this.target = new TypeReference("Transform");
        this.panButton = 2;
        this.rotateButton = 0;
        this.position = vec3.create();
        this.velocity = vec3.create();
        this.pan = vec3.create();
        this.minimumPan = [ -100, -100, -100 ];
        this.maximumPan = [ 100, 100, 100 ];
        this.panXAxis = [ 1, 0, 0 ];
        this.panYAxis = [ 0, 0, 1 ];
        this.panSpeed = .05;
        this.rotation = vec3.create();
        this.angularVelocity = vec3.create();
        this.minimumPitch = -Math.PI / 2.2;
        this.maximumPitch = 0;
        this.rotationAcceleration = .012;
        this.rotationFriction = .1;
        this.zoomSpeed = 1;
        this.doZoomIn = false;
        this.doZoomOut = false;
        this.distance = 5;
        this.minimumDistance = 2.5;
        this.maximumDistance = 7.5;
        this.distanceSteps = 4;
        this.direction = vec3.create();
        this.cameraPosition = vec3.create();
        this.targetPosition = vec3.create();
        this.lookat = mat4.create();
        this.bind("W", "zoomIn");
        this.bind("S", "zoomOut");
        this.bind("A", "rotateLeft");
        this.bind("D", "rotateRight");
        this.bind("E", "rotateUp");
        this.bind("Q", "rotateDown");
    },
    excluded: function() {
        return this._super().concat([ "velocity", "angularVelocity", "doZoomIn", "doZoomOut", "direction", "cameraPosition", "targetPosition", "lookat" ]);
    },
    type: function() {
        return "OrbitController";
    },
    getZoom: function() {
        var relativeDistance = this.distance - this.minimumDistance;
        var range = this.maximumDistance - this.minimumDistance;
        return relativeDistance / range;
    },
    setZoom: function(percentage) {
        percentage = Math.max(0, percentage);
        var range = this.maximumDistance - this.minimumDistance;
        this.distance = Math.min(this.minimumDistance + range * percentage, this.maximumDistance);
    },
    setDistance: function(_distance) {
        this.distance = Math.min(Math.max(_distance, this.minimumDistance), this.maximumDistance);
    },
    zoomIn: function(deltaTime) {
        if (!this.enabled) return;
        if (!deltaTime) deltaTime = 1;
        this.distance -= deltaTime * this.zoomSpeed * (this.maximumDistance - this.minimumDistance) / this.distanceSteps;
        if (this.distance < this.minimumDistance) this.distance = this.minimumDistance;
    },
    zoomOut: function(deltaTime) {
        if (!this.enabled) return;
        if (!deltaTime) deltaTime = 1;
        this.distance += deltaTime * this.zoomSpeed * (this.maximumDistance - this.minimumDistance) / this.distanceSteps;
        if (this.distance > this.maximumDistance) this.distance = this.maximumDistance;
    },
    rotateLeft: function(deltaTime) {
        this.accelerate([ 0, -this.rotationAcceleration, 0 ], deltaTime);
    },
    rotateRight: function(deltaTime) {
        this.accelerate([ 0, this.rotationAcceleration, 0 ], deltaTime);
    },
    rotateUp: function(deltaTime) {
        this.accelerate([ this.rotationAcceleration, 0, 0 ], deltaTime);
    },
    rotateDown: function(deltaTime) {
        this.accelerate([ -this.rotationAcceleration, 0, 0 ], deltaTime);
    },
    accelerate: function(accelerationVector, deltaTime) {
        if (!this.enabled) return;
        vec3.scale(accelerationVector, accelerationVector, deltaTime);
        vec3.add(this.angularVelocity, this.angularVelocity, accelerationVector);
    },
    onUpdate: function(engine, pass) {
        this._super(engine, pass);
        if (this.target.isNull()) return;
        vec3.add(this.rotation, this.rotation, this.angularVelocity);
        var rotation = quat.create();
        quat.rotateY(rotation, rotation, this.rotation[1]);
        quat.rotateX(rotation, rotation, this.rotation[0]);
        vec3.set(this.direction, 0, 0, 1);
        vec3.transformQuat(this.direction, this.direction, rotation);
        vec3.scale(this.direction, this.direction, this.distance);
        mat4.translation(this.targetPosition, this.target.value.absolute);
        vec3.add(this.cameraPosition, this.targetPosition, this.direction);
        vec3.add(this.targetPosition, this.targetPosition, this.pan);
        vec3.add(this.cameraPosition, this.cameraPosition, this.pan);
        mat4.lookAt(this.lookat, this.cameraPosition, this.targetPosition, [ 0, 1, 0 ]);
        mat4.invert(this.node.transform.absolute, this.lookat);
        this.node.calculateRelativeFromAbsolute();
        if (this.doZoomIn) this.zoomIn();
        if (this.doZoomOut) this.zoomOut();
    },
    onMouseMove: function(position, buttons, delta) {
        if (this.rotateButton !== false && buttons[this.rotateButton]) this.rotate(delta[1], delta[0]);
        if (this.panButton !== false && buttons[this.panButton]) this.move(delta[0], delta[1]);
    },
    rotate: function(xDelta, yDelta) {
        var impulse = vec3.create();
        vec3.scale(impulse, [ xDelta, yDelta, 0 ], this.rotationAcceleration);
        vec3.add(this.rotation, this.rotation, impulse);
        this.rotation[0] = Math.max(this.minimumPitch, this.rotation[0]);
        this.rotation[0] = Math.min(this.maximumPitch, this.rotation[0]);
    },
    move: function(xDelta, yDelta) {
        var delta = vec3.create();
        vec3.scale(delta, this.panXAxis, xDelta);
        vec3.add(delta, delta, vec3.scale(vec3.create(), this.panYAxis, yDelta));
        delta = vec3.scale(delta, delta, this.panSpeed);
        var q = quat.fromMat4(quat.create(), this.node.transform.absolute);
        var dir = vec3.fromValues(0, 0, 1);
        vec3.transformQuat(dir, dir, q);
        var angle = Math.atan2(dir[2], dir[0]);
        angle -= Math.PI / 2;
        quat.identity(q);
        quat.rotateY(q, q, angle);
        quat.conjugate(q, q);
        quat.normalize(q, q);
        vec3.transformQuat(delta, delta, q);
        vec3.add(this.pan, this.pan, delta);
        this.pan[0] = Math.max(this.pan[0], this.minimumPan[0]);
        this.pan[1] = Math.max(this.pan[1], this.minimumPan[1]);
        this.pan[2] = Math.max(this.pan[2], this.minimumPan[2]);
        this.pan[0] = Math.min(this.pan[0], this.maximumPan[0]);
        this.pan[1] = Math.min(this.pan[1], this.maximumPan[1]);
        this.pan[2] = Math.min(this.pan[2], this.maximumPan[2]);
    }
});

var SmoothOrbitController = OrbitController.extend({
    init: function() {
        this._super();
        this.speed = 5;
        this.currentRotation = vec2.create();
        this.currentDistance = this.distance;
        this.tmpRotation = quat.create();
    },
    excluded: function() {
        return this._super().concat([ "currentRotation", "currentDistance", "tmpRotation" ]);
    },
    type: function() {
        return "SmoothOrbitController";
    },
    onUpdate: function(engine, pass) {
        if (this.target.isNull()) return;
        this.processKeyEvents(engine);
        var dt = engine.fps.getDelta() / 1e3 * this.speed;
        this.currentRotation[0] = lerp(this.currentRotation[0], this.rotation[0], dt);
        this.currentRotation[1] = lerp(this.currentRotation[1], this.rotation[1], dt);
        this.currentDistance = lerp(this.currentDistance, this.distance, dt);
        quat.identity(this.tmpRotation);
        quat.rotateY(this.tmpRotation, this.tmpRotation, this.currentRotation[1]);
        quat.rotateX(this.tmpRotation, this.tmpRotation, this.currentRotation[0]);
        vec3.set(this.direction, 0, 0, 1);
        vec3.transformQuat(this.direction, this.direction, this.tmpRotation);
        vec3.scale(this.direction, this.direction, this.currentDistance);
        mat4.translation(this.targetPosition, this.target.value.absolute);
        vec3.add(this.cameraPosition, this.targetPosition, this.direction);
        vec3.add(this.targetPosition, this.targetPosition, this.pan);
        vec3.add(this.cameraPosition, this.cameraPosition, this.pan);
        mat4.lookAt(this.lookat, this.cameraPosition, this.targetPosition, [ 0, 1, 0 ]);
        mat4.invert(this.node.transform.absolute, this.lookat);
        this.node.calculateRelativeFromAbsolute();
        if (this.doZoomIn) this.zoomIn();
        if (this.doZoomOut) this.zoomOut();
    }
});

var LineRendererComponent = Component.extend({
    init: function(color) {
        this._super();
        this.shader = false;
        if (color instanceof Color) this.color = new UniformColor(color); else this.color = new UniformColor(new Color(.5, .5, .5, 1));
        this.faces = [];
        this.vertices = [];
        this.buffer = false;
        this.updateBuffer = false;
        this.depthTest = false;
    },
    type: function() {
        return "LineRendererComponent";
    },
    excluded: function() {
        return this._super().concat([ "buffer", "updateBuffer" ]);
    },
    initialize: function(context) {
        this.shader = this.node.scene.engine.assetsManager.addShaderSource("Transparent");
        this.node.scene.engine.assetsManager.load();
        var white = new Texture(context);
        white.clearImage(context, [ 255, 255, 255, 255 ]);
        this.samplers = [ new Sampler("diffuse0", white) ];
    },
    build: function(context) {
        if (this.vertices.length == 0 || this.faces.length == 0) return false;
        this.buffer = new RenderBuffer(context, this.faces, context.gl.DYNAMIC_DRAW);
        this.buffer.add("position", this.vertices, 3);
    },
    clear: function(context) {
        this.faces = [];
        this.vertices = [];
        for (var i in this.buffer.buffers) {
            context.gl.deleteBuffer(this.buffer.buffers[i]);
        }
        this.buffer = false;
    },
    addLine: function(a, b) {
        var base = this.vertices.length / 3;
        var line = {
            vertexOffset: base
        };
        this.vertices.push(a[0], a[1], a[2], b[0], b[1], b[2]);
        this.faces.push(base, base + 1);
        return line;
    },
    updateLine: function(line, a, b) {
        if (!this.buffer || !this.buffer.buffers.position) return;
        var setWithOffset = function(buffer, offset, vertex) {
            buffer[offset * 3 + 0] = vertex[0];
            buffer[offset * 3 + 1] = vertex[1];
            buffer[offset * 3 + 2] = vertex[2];
        };
        setWithOffset(this.vertices, line.vertexOffset + 0, a);
        setWithOffset(this.vertices, line.vertexOffset + 1, b);
        this.updateBuffer = true;
    },
    addTriangle: function(a, b, c) {
        this.addLine(a, b);
        this.addLine(b, c);
        this.addLine(c, a);
    },
    addBox: function(box) {
        if (!(box instanceof BoundingBox)) throw "LineRendererComponent.addBox expects box to be of type BoundingBox";
        this.addLine(box.min, [ box.min[0], box.min[1], box.max[2] ]);
        this.addLine(box.min, [ box.min[0], box.max[1], box.min[2] ]);
        this.addLine(box.min, [ box.max[0], box.min[1], box.min[2] ]);
        this.addLine(box.max, [ box.max[0], box.min[1], box.max[2] ]);
        this.addLine(box.max, [ box.max[0], box.max[1], box.min[2] ]);
        this.addLine(box.max, [ box.min[0], box.max[1], box.max[2] ]);
        this.addLine([ box.min[0], box.max[1], box.min[2] ], [ box.min[0], box.max[1], box.max[2] ]);
        this.addLine([ box.min[0], box.max[1], box.max[2] ], [ box.min[0], box.min[1], box.max[2] ]);
        this.addLine([ box.min[0], box.min[1], box.max[2] ], [ box.max[0], box.min[1], box.max[2] ]);
        this.addLine([ box.max[0], box.min[1], box.max[2] ], [ box.max[0], box.min[1], box.min[2] ]);
        this.addLine([ box.max[0], box.min[1], box.min[2] ], [ box.max[0], box.max[1], box.min[2] ]);
        this.addLine([ box.max[0], box.max[1], box.min[2] ], [ box.min[0], box.max[1], box.min[2] ]);
    },
    addGrid: function(center, count, scale) {
        var half = [ count[0] / 2, count[1] / 2 ];
        if (!scale) scale = [ 1, 1 ];
        for (var i = -half[0]; i <= half[0]; i++) {
            this.addLine([ i * scale[0] + center[0], center[1], -half[1] * scale[1] + center[2] ], [ i * scale[0] + center[0], center[1], half[1] * scale[1] + center[2] ]);
        }
        for (i = -half[1]; i <= half[1]; i++) {
            this.addLine([ -half[0] * scale[0] + center[0], center[1], i * scale[1] + center[2] ], [ half[0] * scale[0] + center[0], center[1], i * scale[1] + center[2] ]);
        }
    },
    onStart: function(context) {
        this.initialize(context);
        this.build(context);
    },
    onPostRender: function(context, camera) {
        if (!this.enabled || this.buffer === false) return;
        if (this.updateBuffer) {
            this.build(context);
        }
        var uniforms = {
            modelview: new UniformMat4(context.modelview.top()),
            projection: new UniformMat4(context.projection.top()),
            diffuse: this.color
        };
        this.shader.use(uniforms);
        this.shader.bindSamplers(this.samplers);
        this.shader.requirements.apply(this.buffer);
        var gl = context.gl;
        if (this.depthTest) {
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LESS);
            gl.depthMask(true);
        }
        var locations = [];
        for (var bufferName in this.buffer.buffers) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer.buffers[bufferName]);
            var bufferLocation = gl.getAttribLocation(this.shader.program, bufferName);
            if (bufferLocation == -1) continue;
            gl.enableVertexAttribArray(bufferLocation);
            locations.push(bufferLocation);
            gl.vertexAttribPointer(bufferLocation, this.buffer.buffers[bufferName].itemSize, gl.FLOAT, false, 0, 0);
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffer.facesBuffer);
        gl.drawElements(gl.LINES, this.buffer.facesBuffer.numItems, gl.UNSIGNED_SHORT, 0);
        for (var i in locations) gl.disableVertexAttribArray(locations[i]);
        if (this.depthTest) {
            gl.disable(gl.DEPTH_TEST);
        }
    }
});

var Billboard = Component.extend({
    init: function(cameraToLookAt, smoothRotation, rotationSpeed) {
        this._super();
        this.cameraToLookAt = cameraToLookAt;
        this.smoothRotation = smoothRotation === true;
        this.rotationSpeed = 4;
        if (rotationSpeed) this.rotationSpeed = rotationSpeed;
        this.cacheMat4 = [ mat4.create() ];
        this.cacheQuat = [ quat.create(), quat.create() ];
        this.cacheVec3 = [ vec3.create(), vec3.create() ];
    },
    type: function() {
        return "Billboard";
    },
    onUpdate: function(engine) {
        if (!this.enabled) return;
        if (!(this.cameraToLookAt instanceof Camera)) throw "Billboard.cameraToLookAt is not an instance of Camera";
        var delta = engine.fps.getDelta() / 1e3;
        var invViewMatrix = mat4.invert(this.cacheMat4[0], this.cameraToLookAt.viewMatrix);
        var rotation = quat.fromMat4(this.cacheQuat[0], invViewMatrix);
        if (this.smoothRotation) {
            var localRotation = quat.fromMat4(this.cacheQuat[1], this.node.transform.relative);
            quat.slerp(rotation, localRotation, rotation, this.rotationSpeed * delta);
        }
        quat.normalize(rotation, rotation);
        var localPosition = mat4.translation(this.cacheVec3[0], this.node.transform.relative);
        var localScale = mat4.getScale(this.cacheVec3[1], this.node.transform.relative);
        mat4.fromRotationTranslationScale(this.node.transform.relative, rotation, localPosition, localScale);
    }
});

var VerticalBillboard = Billboard.extend({
    init: function(cameraToLookAt, smoothRotation, rotationSpeed) {
        this._super(cameraToLookAt, smoothRotation, rotationSpeed);
    },
    type: function() {
        return "VerticalBillboard";
    },
    onUpdate: function(engine) {
        if (!(this.cameraToLookAt instanceof Camera)) throw "VerticalBillboard.cameraToLookAt is not an instance of Camera";
        var delta = engine.fps.getDelta() / 1e3;
        var invViewMatrix = mat4.invert(this.cacheMat4[0], this.cameraToLookAt.viewMatrix);
        var rotation = quat.fromMat4(this.cacheQuat[0], invViewMatrix);
        quat.multiply(rotation, rotation, quat.euler(this.cacheQuat[1], 0, 180, 0));
        if (this.smoothRotation) {
            rotation[0] = 0;
            rotation[2] = 0;
            quat.normalize(rotation, rotation);
            var localRotation = quat.fromMat4(this.cacheQuat[1], this.node.transform.relative);
            quat.slerp(rotation, localRotation, rotation, this.rotationSpeed * delta);
        }
        quat.normalize(rotation, rotation);
        var localPosition = mat4.translation(this.cacheVec3[0], this.node.transform.relative);
        var localScale = mat4.getScale(this.cacheVec3[1], this.node.transform.relative);
        mat4.fromRotationTranslationScale(this.node.transform.relative, rotation, localPosition, localScale);
    }
});

var Collider = Component.extend({
    init: function() {
        this._super();
    },
    type: function() {
        return "Collider";
    },
    onStart: function(context, engine) {
        this.getScene().dynamicSpace.addCollider(this);
    },
    onEnd: function(context, engine) {
        this.getScene().dynamicSpace.removeCollider(this);
    },
    rayTest: function(ray, result, collideInvisible) {
        return false;
    }
});

var MeshCollider = Collider.extend({
    init: function() {
        this._super();
    },
    type: function() {
        return "MeshCollider";
    },
    rayTest: function(ray, result, collideInvisible) {
        if (!this.enabled) return false;
        var meshRendererComponent = this.node.getComponent(MeshRendererComponent);
        if (!meshRendererComponent) return false;
        var renderers = meshRendererComponent.meshRenderers;
        var a = vec3.create();
        var b = vec3.create();
        var c = vec3.create();
        var hit = false;
        for (var i in renderers) {
            if (!collideInvisible && !renderers[i].visible) continue;
            if (ray.intersectBoundingVolume(renderers[i].globalBoundingBox)) {
                var localRay = ray.clone();
                var invMat = mat4.invert(mat4.create(), renderers[i].matrix);
                localRay.transform(invMat);
                var faces = renderers[i].submesh.faces;
                var positions = renderers[i].submesh.positions;
                if (result) {
                    var collider = this;
                    result.addCallback = function(item) {
                        vec3.transformMat4(item.point, item.point, renderers[i].matrix);
                        item.submesh = renderers[i].submesh;
                        item.collider = collider;
                        item.node = collider.node;
                    };
                }
                for (var v = 0; v < faces.length; v += 3) {
                    a[0] = positions[faces[v] * 3];
                    a[1] = positions[faces[v] * 3 + 1];
                    a[2] = positions[faces[v] * 3 + 2];
                    b[0] = positions[faces[v + 1] * 3];
                    b[1] = positions[faces[v + 1] * 3 + 1];
                    b[2] = positions[faces[v + 1] * 3 + 2];
                    c[0] = positions[faces[v + 2] * 3];
                    c[1] = positions[faces[v + 2] * 3 + 1];
                    c[2] = positions[faces[v + 2] * 3 + 2];
                    if (localRay.intersectTriangle(a, b, c, result)) {
                        if (!result) return true;
                        hit = true;
                        break;
                    }
                }
                if (result) result.addCallback = false; else if (hit) return true;
            }
        }
        return hit;
    }
});

var LargeMeshCollider = Collider.extend({
    init: function(mesh) {
        this._super();
        this.tree = false;
        this.meshes = [];
        this.invMat = mat4.create();
    },
    type: function() {
        return "LargeMeshCollider";
    },
    excluded: function() {
        return this._super().concat([ "tree", "meshes" ]);
    },
    isComplete: function() {
        return this.tree !== false && this.meshes.length == 0;
    },
    onAdd: function(node) {
        this._super();
    },
    rayTest: function(ray, result, collideInvisible) {
        if (!this.enabled || !this.isComplete()) return false;
        var localRay = ray.clone();
        mat4.invert(this.invMat, this.node.transform.absolute);
        localRay.transform(this.invMat);
        var collision = this.tree.getNearestRayCollision(localRay, ray);
        if (collision.t == Infinity || collision.t == -Infinity) return false;
        if (result && collision) {
            var p = localRay.getPointOnRay(collision.t);
            vec3.transformMat4(p, p, this.node.transform.absolute);
            result.hits.push({
                point: p,
                collider: this,
                submesh: collision.submesh,
                node: collision.node,
                normal: collision.normal
            });
        }
        return collision !== false;
    }
});

var Light = Component.extend({
    init: function() {
        this._super();
        this.direction = vec3.fromValues(0, -1, 0);
        this.color = new Color();
        this.intensity = 1;
        this.shadowIntensity = .4;
        this.shadowBlurKernelSize = 5;
        this.shadowCasting = false;
        this.shadowMask = 4294967295;
    },
    type: function() {
        return "Light";
    },
    setLightDirection: function(direction) {
        vec3.copy(this.direction, direction);
        vec3.normalize(this.direction, this.direction);
    },
    onAddScene: function(node) {
        node.scene.lights.push(this);
    },
    onRemoveScene: function(node) {
        var lights = node.scene.lights;
        for (var i = 0; i < lights.length; i++) {
            if (lights[i] == this) {
                lights.splice(i, 1);
                i--;
            }
        }
    }
});

var Transform = Component.extend({
    init: function(relative) {
        this._super();
        if (relative) {
            this.relative = relative;
        } else {
            this.relative = mat4.identity(mat4.create());
        }
        this.absolute = mat4.copy(mat4.create(), this.relative);
    },
    onAdd: function(node) {
        node.transform = this;
    },
    type: function() {
        return "Transform";
    },
    excluded: function() {
        return this._super().concat([ "absolute" ]);
    },
    calculateRelativeFromAbsolute: function(referenceMatrix) {
        if (!referenceMatrix) {
            mat4.copy(this.relative, this.absolute);
            return;
        }
        var referenceInverse = mat4.invert(mat4.create(), referenceMatrix);
        mat4.multiply(this.relative, this.absolute, referenceInverse);
    },
    getPosition: function(out) {
        if (!out) out = vec3.create();
        return mat4.translation(out, this.absolute);
    },
    setPosition: function(position) {
        mat4.fromRotationTranslation(this.relative, quat.fromMat4(quat.create(), this.relative), position);
    },
    getRotation: function(out) {
        if (!out) out = quat.create();
        return quat.fromMat4(out, this.absolute);
    },
    translate: function(offset) {
        this.relative = mat4.translate(this.relative, this.relative, offset);
    },
    rotate: function(angle, axis) {
        this.relative = mat4.rotate(this.relative, this.relative, angle, axis);
    },
    scale: function(scale) {
        this.relative = mat4.scale(this.relative, this.relative, scale);
    },
    clone: function() {
        var t = new Transform();
        t.relative = mat4.clone(this.relative);
        t.absolute = mat4.clone(this.absolute);
        return t;
    }
});

var Resource = Component.extend({
    init: function() {
        this._super();
        this.descriptor = false;
    },
    excluded: function() {
        return this._super().concat([ "resource" ]);
    },
    type: function() {
        return "ResourceComponent";
    }
});

var TextureResource = Resource.extend({
    init: function() {
        this._super();
        this.descriptor = new TextureDescriptor();
        this.texture = false;
        this.engine = false;
    },
    excluded: function() {
        return this._super().concat([ "texture", "engine" ]);
    },
    type: function() {
        return "TextureResource";
    },
    load: function(callback) {
        var me = this;
        this.texture = this.engine.assetsManager.texturesManager.addDescriptor(this.descriptor);
        this.engine.assetsManager.load(function() {
            me.onLoaded();
            if (callback) callback(me.engine.context, me.engine);
        });
    },
    onStart: function(context, engine) {
        this.engine = engine;
        this.load();
    },
    onLoaded: function() {}
});

var ModelResource = Resource.extend({
    init: function() {
        this._super();
        this.descriptor = new ModelDescriptor();
        this.model = false;
    },
    type: function() {
        return "ModelResource";
    },
    excluded: function() {
        return this._super().concat([ "model", "engine" ]);
    },
    load: function(callback) {
        if (!this.descriptor.source) return;
        var me = this;
        this.model = this.engine.assetsManager.modelsManager.addDescriptor(this.descriptor);
        this.engine.assetsManager.load(function() {
            me.node.addNode(me.model);
            me.onLoaded();
            if (callback) callback(me.engine.context, me.engine);
        });
    },
    onStart: function(context, engine) {
        this.engine = engine;
        this.load();
    },
    onLoaded: function() {}
});

var MaterialResource = Resource.extend({
    init: function() {
        this._super();
        this.descriptor = new MaterialSourceDescriptor();
        this.material = false;
        this.engine = false;
    },
    excluded: function() {
        return this._super().concat([ "material", "engine" ]);
    },
    type: function() {
        return "MaterialResource";
    },
    load: function(callback) {
        var me = this;
        this.texture = this.engine.assetsManager.materialSourcesManager.addDescriptor(this.descriptor);
        this.engine.assetsManager.load(function() {
            me.onLoaded();
            if (callback) callback(me.engine.context, me.engine);
        });
    },
    onStart: function(context, engine) {
        this.engine = engine;
        this.load();
    },
    onLoaded: function() {}
});

var Descriptor = Serializable.extend({
    init: function() {
        this._super();
        this.source = "";
        this.parentDescriptor = false;
    },
    included: function() {
        return true;
    },
    excluded: function() {
        return this._super().concat([ "parentDescriptor" ]);
    },
    type: function() {
        return "Descriptor";
    },
    equals: function(other) {
        if (this.type() != other.type()) return false;
        if (this.getFullPath() != other.getFullPath()) return false;
        if (this.parentDescriptor && other.parentDescriptor) {
            if (!this.parentDescriptor.equals(other.parentDescriptor)) return false;
        } else if (this.parentDescriptor != other.parentDescriptor) return false;
        return true;
    },
    getCurrentRelativeDirectory: function() {
        if (this.source.length == 0) return "";
        return this.source.substring(0, this.source.lastIndexOf("/") + 1);
    },
    getCurrentDirectory: function() {
        var path = "";
        if (this.parentDescriptor) path = this.parentDescriptor.getCurrentDirectory();
        return path + this.getCurrentRelativeDirectory();
    },
    getParentDirectory: function() {
        if (this.parentDescriptor) return this.parentDescriptor.getCurrentDirectory();
        return "";
    },
    getFullPath: function() {
        var path = this.getParentDirectory() + this.source;
        return path;
    }
});

var TextDescriptor = Descriptor.extend({
    init: function(source) {
        this._super();
        this.source = source;
    },
    type: function() {
        return "TextDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        return this.source == other.source;
    }
});

var FontDescriptor = Descriptor.extend({
    init: function(fontTexturePaths, fontDataPath, materialSourceDescriptor) {
        this._super();
        this.fontTexturePaths = fontTexturePaths;
        this.fontDataPath = fontDataPath;
        this.materialSourceDescriptor = materialSourceDescriptor;
    },
    type: function() {
        return "FontDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        if (this.fontTexturePaths.length != other.fontTexturePaths) return false;
        for (var i in this.fontTexturePaths) {
            if (this.fontTexturePaths[i] != other.fontTexturePaths[i]) return false;
        }
        if (this.fontDataPath != other.fontDataPath) return false;
        if (this.materialSourceDescriptor && other.materialSourceDescriptor) {
            if (!this.materialSourceDescriptor.equals(other.materialSourceDescriptor)) return false;
        } else if (this.materialSourceDescriptor != other.materialSourceDescriptor) return false;
        return true;
    },
    getFullTexturePaths: function() {
        var parentDirectory = this.getParentDirectory();
        console.log("TEXTURE PARENT: ", parentDirectory);
        var texturePaths = [];
        for (var i in this.fontTexturePaths) {
            texturePaths.push(parentDirectory + this.fontTexturePaths[i]);
        }
        console.log(texturePaths);
        return texturePaths;
    },
    getFullDataPath: function() {
        return this.getParentDirectory() + this.fontDataPath;
    }
});

var FontSourceDescriptor = Descriptor.extend({
    init: function(source) {
        this._super();
        this.source = source;
    },
    type: function() {
        return "FontSourceDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        return this.source == other.source;
    }
});

var FontSource = Descriptor.extend({
    init: function(sourceDescriptor) {
        this._super();
        this.sourceDescriptor = sourceDescriptor;
        this.font = false;
    },
    type: function() {
        return "FontSource";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        if (this.sourceDescriptor && other.sourceDescriptor) {
            if (!this.ourceDescriptor.equals(other.sourceDescriptor)) return false;
        } else if (this.sourceDescriptor != other.sourceDescriptor) return false;
        return true;
    }
});

var ModelDescriptor = Descriptor.extend({
    init: function(source, noCollisionTree) {
        this._super();
        this.source = source;
        this.noCollisionTree = noCollisionTree;
        this.texturesFromPath = true;
    },
    type: function() {
        return "ModelDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        return this.source == other.source && this.noCollisionTree == other.noCollisionTree && this.texturesFromPath == other.texturesFromPath;
    }
});

var ShaderDescriptor = Descriptor.extend({
    init: function(vertexOrUnifiedSource, fragmentSource) {
        this._super();
        if (!fragmentSource) {
            this.vertexSource = vertexOrUnifiedSource + ".vert";
            this.fragmentSource = vertexOrUnifiedSource + ".frag";
        } else {
            this.vertexSource = vertexOrUnifiedSource;
            this.fragmentSource = fragmentSource;
        }
    },
    type: function() {
        return "ShaderDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        return this.vertexSource == other.vertexSource && this.fragmentSource == other.fragmentSource;
    },
    getVertexShaderPath: function() {
        var path = this.getParentDirectory() + this.vertexSource;
        return path;
    },
    getFragmentShaderPath: function() {
        var path = this.getParentDirectory() + this.fragmentSource;
        return path;
    }
});

var MaterialDescriptor = Descriptor.extend({
    init: function(shaderDescriptor, uniforms, textureDescriptors) {
        this._super();
        if (!textureDescriptors) textureDescriptors = [];
        if (!uniforms) uniforms = {};
        this.shaderDescriptor = shaderDescriptor;
        this.uniforms = uniforms;
        this.textureDescriptors = textureDescriptors;
        this.materialResourceDescriptor = false;
        this.requirements = {};
    },
    type: function() {
        return "MaterialDescriptor";
    },
    equals: function(other) {
        return false;
    }
});

var MaterialSource = Descriptor.extend({
    init: function(sourceDescriptor) {
        this._super();
        this.material = false;
        this.sourceDescriptor = sourceDescriptor;
    },
    type: function() {
        return "MaterialSource";
    },
    equals: function(other) {
        return false;
    }
});

var MaterialSourceDescriptor = Descriptor.extend({
    init: function(source) {
        this._super();
        this.source = source;
    },
    type: function() {
        return "MaterialSourceDescriptor";
    },
    equals: function(other) {
        return this.source == other.source;
    }
});

var TextureDescriptor = Descriptor.extend({
    init: function(source, width, height) {
        this._super();
        this.source = source;
        this.width = width;
        this.height = height;
    },
    type: function() {
        return "TextureDescriptor";
    },
    equals: function(other) {
        if (!this._super(other)) return false;
        return this.source == other.source && this.width == other.width && height == other.height;
    }
});

var EmptyNode = Serializable.extend({
    init: function(name) {
        this._super();
        this.name = name ? name : "Empty Node";
        this.subnodes = [];
        this.components = [];
        this.scene = false;
        this.parent = false;
        this.layer = 1;
        this.tags = [];
    },
    excluded: function() {
        return [ "parent", "scene" ];
    },
    type: function() {
        return "EmptyNode";
    },
    addNode: function(node) {
        this.subnodes.push(node);
        var me = this;
        node.parent = this;
        node.onEachChild(function(n) {
            n.scene = me.scene;
        });
        if (node.scene) {
            node.onEachChildComponent(function(c) {
                c.onAddScene(me);
                c.node.onAddComponent(c);
            });
        }
        node.onAdd(this);
        if (me.scene.engine) {
            node.onEachChildComponent(function(c) {
                if (!c.started) {
                    if (me.scene.starting || me.scene.started === false) {
                        me.scene.startingQueue.push(c);
                    } else {
                        c.onLoad(me.scene.engine.assetsManager, me.scene.engine);
                        c.start(me.scene.engine.context, me.scene.engine);
                        c.started = true;
                    }
                }
            });
        }
        return node;
    },
    removeNode: function(node) {
        var me = this;
        if (me.scene.engine) node.onEachChildComponent(function(c) {
            if (c.started) c.onEnd(me.scene.engine.context, me.scene.engine);
            c.started = false;
        });
        node.onRemove(this);
        if (node.scene) node.onEachChildComponent(function(c) {
            c.onRemoveScene(me);
            c.node.onRemoveComponent(c);
        });
        node.onEachChild(function(n) {
            n.scene = false;
        });
        node.parent = false;
        for (var i in this.subnodes) {
            if (this.subnodes[i] == node) {
                this.subnodes.splice(i, 1);
                break;
            }
        }
        return node;
    },
    removeSubnodes: function() {
        var nodes = this.subnodes.slice(0);
        for (var n in nodes) {
            this.removeNode(nodes[n]);
        }
    },
    addComponent: function(component) {
        if (!component.type()) throw "Unable to add a component that doesn't define it's type by returning it from type() method";
        this.components.push(component);
        component.node = this;
        component.onAdd(this);
        if (this.scene) {
            component.onAddScene(this);
            this.onAddComponent(component);
        }
        if (this.scene.engine && !component.started) {
            component.start(this.scene.engine.context, this.scene.engine);
            component.started = true;
        }
        return component;
    },
    removeComponent: function(component) {
        for (var c in this.components) {
            if (this.components[c] === component) {
                this.components.splice(c, 1);
                break;
            }
        }
        if (this.scene.engine && component.started) {
            component.onEnd(this.scene.engine.context, this.scene.engine);
            component.started = false;
        }
        if (this.scene) {
            component.onRemoveScene(this);
            this.onRemoveComponent(component);
        }
        component.onRemove(this);
        component.node = false;
        return component;
    },
    removeComponentsByType: function(componentType) {
        var removed = [];
        for (var i = 0; i < this.components.length; i++) {
            if (this.components[i] instanceof componentType) {
                removed.push(this.components[i]);
                this.components.splice(i, 1);
                i--;
            }
        }
        for (var i in removed) {
            if (this.scene.engine && removed[i].started) {
                removed[i].onEnd(this.scene.engine.context, this.scene.engine);
                removed[i].started = false;
            }
            if (this.scene) {
                removed[i].onRemoveScene(this);
                this.onRemoveComponent(removed[i]);
            }
            removed[i].onRemove(this);
            removed[i].node = false;
        }
        return removed;
    },
    getComponent: function(componentType) {
        for (var c in this.components) {
            if (this.components[c] instanceof componentType) return this.components[c];
        }
        return false;
    },
    getComponents: function(componentType) {
        var a = [];
        for (var c in this.components) {
            if (this.components[c] instanceof componentType) a.push(this.components[c]);
        }
        if (a.length == 0) return false;
        return a;
    },
    calculateRelativeFromAbsolute: function() {
        if (!this.parent.transform) return;
        this.transform.calculateRelativeFromAbsolute(this.parent.transform.absolute);
    },
    instantiate: function() {
        var instance = new EmptyNode(this.name + " (instance)");
        instance.layer = this.layer;
        instance.tags = this.tags.slice(0);
        for (var n in this.subnodes) {
            instance.addNode(this.subnodes[n].instantiate());
        }
        for (var c in this.components) {
            instance.addComponent(this.components[c].instantiate());
        }
        return instance;
    },
    enable: function(onlyThisNode) {
        if (onlyThisNode) this.onEachComponent(function(c) {
            c.enable();
        }); else this.onEachChildComponent(function(c) {
            c.enable();
        });
    },
    disable: function(onlyThisNode) {
        if (onlyThisNode) this.onEachComponent(function(c) {
            c.disable();
        }); else this.onEachChildComponent(function(c) {
            c.disable();
        });
    },
    onAdd: function(parent) {},
    onRemove: function(parent) {},
    onAddComponent: function(component) {
        this.scene.components.push(component);
        if (component.onUpdate != Component.prototype.onUpdate) this.scene.updatedComponents.push(component);
        if (component.onPreRender != Component.prototype.onPreRender) this.scene.preRenderedComponents.push(component);
        if (component.onPostRender != Component.prototype.onPostRender) this.scene.postRenderedComponents.push(component);
    },
    onRemoveComponent: function(component) {
        function removeIfExists(list, component) {
            var index = list.indexOf(component);
            if (index != -1) {
                list.splice(index, 1);
                return;
            }
        }
        removeIfExists(this.scene.components, component);
        if (component.onUpdate != Component.prototype.onUpdate) removeIfExists(this.scene.updatedComponents, component);
        if (component.onPreRender != Component.prototype.onPreRender) removeIfExists(this.scene.preRenderedComponents, component);
        if (component.onPostRender != Component.prototype.onPostRender) removeIfExists(this.scene.postRenderedComponents, component);
    },
    onEachChild: function(callback) {
        callback(this);
        for (var node in this.subnodes) this.subnodes[node].onEachChild(callback);
    },
    onEachChildExclusive: function(callback) {
        for (var node in this.subnodes) {
            callback(this.subnodes[node]);
            this.subnodes[node].onEachChild(callback);
        }
    },
    onEachComponent: function(callback) {
        for (var c in this.components) {
            callback(this.components[c]);
        }
    },
    onEachChildComponent: function(callback) {
        this.onEachChild(function(child) {
            child.onEachComponent(callback);
        });
    },
    onEachChildComponentExclusive: function(callback) {
        this.onEachChildExclusive(function(child) {
            child.onEachComponent(callback);
        });
    },
    getChildComponentsOfType: function(type) {
        var result = [];
        this.onEachChildComponent(function(c) {
            if (c instanceof type) result.push(c);
        });
        return result;
    },
    find: function(path) {
        var parts = path.split("/");
        if (parts.length == 0) return false;
        var node = this;
        if (parts[0] === "") {
            if (!this.scene) return false;
            node = this.scene.root;
            parts.shift();
        }
        for (var i in parts) {
            node = node.findChildWithName(parts[i]);
            if (node === false) return false;
        }
        return node;
    },
    findChildWithName: function(name) {
        for (var i in this.subnodes) {
            if (this.subnodes[i].name === name) return this.subnodes[i];
        }
        return false;
    }
});

var Node = EmptyNode.extend({
    init: function(name) {
        this._super(name);
        this.name = name ? name : "Node";
        this.transform = this.addComponent(new Transform());
    },
    excluded: function() {
        return this._super().concat([ "transform" ]);
    },
    type: function() {
        return "Node";
    },
    getBoundingBox: function(excludeInvisible) {
        var bb = new BoundingBox();
        this.onEachChildComponent(function(c) {
            if (c instanceof MeshRendererComponent) bb.encapsulateBox(c.getBoundingBox(excludeInvisible));
        });
        return bb;
    },
    getBoundingSphere: function(excludeInvisible) {
        var bb = new BoundingSphere();
        this.onEachChildComponent(function(c) {
            if (c instanceof MeshRendererComponent) bb.encapsulateSphere(c.getBoundingSphere(excludeInvisible));
        });
        return bb;
    },
    instantiate: function() {
        var instance = new Node(this.name + " (instance)");
        instance.removeComponentsByType(Transform);
        instance.layer = this.layer;
        instance.tags = this.tags.slice(0);
        for (var n in this.subnodes) {
            instance.addNode(this.subnodes[n].instantiate());
        }
        for (var c in this.components) {
            instance.addComponent(this.components[c].instantiate());
        }
        instance.transform = instance.getComponent(Transform);
        return instance;
    },
    updateChildTransforms: function() {
        var index, c;
        var absolute = this.transform.absolute;
        var subnodes = this.subnodes;
        for (index in subnodes) {
            var subnode = subnodes[index];
            if (!subnode.transform) continue;
            mat4.multiply(subnode.transform.absolute, absolute, subnode.transform.relative);
            subnode.updateChildTransforms();
        }
        for (c in this.components) {
            this.components[c].onUpdateTransform(absolute);
        }
    },
    setAbsolutePosition: function(position) {
        if (!this.parent || !this.parent.transform) {
            this.transform.calculateRelativeFromAbsolute();
            return;
        }
        mat4.fromRotationTranslationScale(this.transform.absolute, quat.fromMat4(quat.create(), this.transform.absolute), position, mat4.getScale(vec3.create(), this.transform.absolute));
        this.transform.calculateRelativeFromAbsolute(this.parent.transform.absolute);
    }
});

var Scene = Serializable.extend({
    init: function() {
        this.root = new Node();
        this.root.scene = this;
        this.dynamicSpace = new DynamicSpace();
        this.cameras = [];
        this.lights = [];
        this.engine = false;
        this.starting = false;
        this.started = false;
        this.startingQueue = [];
        this.components = [];
        this.preRenderedComponents = [];
        this.postRenderedComponents = [];
        this.updatedComponents = [];
    },
    fields: function() {
        return [ "root" ];
    },
    start: function(context) {
        if (this.started || this.starting) return;
        this.starting = true;
        var me = this;
        this.root.onEachChildComponent(function(component) {
            if (!component.enabled) return;
            if (component.started) return;
            component.onLoad(me.engine.assetsManager, me.engine);
        });
        var internalStart = function() {
            me.root.updateChildTransforms();
            me.root.onEachChildComponent(function(component) {
                if (!component.enabled) return;
                if (component.started) return;
                me.startingQueue.push(component);
            });
            var timer = null;
            timer = function() {
                var delay = 50;
                var maximumTime = new Date().getTime() + delay;
                while (new Date().getTime() < maximumTime) {
                    if (me.startingQueue.length === 0) {
                        me.started = true;
                        me.starting = false;
                        if (typeof me.engine.sceneStarted === "function") {
                            me.engine.sceneStarted();
                        }
                        return;
                    }
                    var c = me.startingQueue.shift();
                    if (c.started) continue;
                    c.start(context, me.engine);
                    c.started = true;
                }
                setTimeout(timer, 10);
            };
            timer();
        };
        internalStart();
    },
    end: function(context, engine) {
        if (!this.started) return;
        this.root.updateChildTransforms();
        this.root.onEachChildComponent(function(component) {
            if (!component.enabled) return;
            if (!component.started) return;
            component.onEnd(context, engine);
            component.started = false;
        });
        this.started = false;
    },
    render: function(context) {
        if (!this.started) return;
        var camera = false;
        for (var cameraIndex in this.cameras) {
            camera = this.cameras[cameraIndex];
            camera.startRender(context);
            for (var i = 0; i < this.preRenderedComponents.length; i++) {
                var component = this.preRenderedComponents[i];
                if (component.node.layer & camera.layerMask) {
                    context.modelview.push();
                    context.modelview.multiply(component.node.transform.absolute);
                    component.onPostRender(context, camera);
                    context.modelview.pop();
                }
            }
            camera.render(context, this);
            for (i = 0; i < this.postRenderedComponents.length; i++) {
                var component = this.postRenderedComponents[i];
                if (component.node.layer & camera.layerMask) {
                    context.modelview.push();
                    context.modelview.multiply(component.node.transform.absolute);
                    component.onPostRender(context, camera);
                    context.modelview.pop();
                }
            }
            camera.endRender(context);
        }
    },
    update: function(engine) {
        if (!this.started) return;
        var passes = 1;
        for (var pass = 0; pass < passes; pass++) {
            for (var i = 0; i < this.updatedComponents.length; ++i) {
                var component = this.updatedComponents[i];
                if (!component.enabled) continue;
                if (pass < component.updatePasses && component.started) {
                    component.onUpdate(engine, pass);
                }
                if (passes < component.updatePasses) passes = component.updatePasses;
            }
        }
        this.root.updateChildTransforms();
    },
    getMaterials: function() {
        var result = [];
        this.root.onEachChildComponent(function(c) {
            if (c instanceof MeshComponent) {
                for (var i in c.mesh.materials) result.push(c.mesh.materials[i]);
            }
        });
        return result;
    }
});

var DefaultScene = Scene.extend({
    init: function() {
        this._super();
        this.root.name = "Root";
        this.cameraNode = new Node("Camera");
        this.cameraComponent = this.cameraNode.addComponent(new PerspectiveCamera());
        this.cameraComponent.aspect = false;
        this.camera = this.cameraComponent.camera;
        this.root.addNode(this.cameraNode);
        this.lightNode = new Node("Light");
        this.light = new Light();
        this.light.color = new Color(1, 1, .98, 1);
        this.light.intensity = 1.15;
        this.light.setLightDirection(vec3.fromValues(.9, 1, .9));
        this.lightNode.addComponent(this.light);
        this.root.addNode(this.lightNode);
    }
});

var FPS = Class.extend({
    init: function() {
        this.frametime = 0;
        this.lastMeasurement = new Date().getTime();
        this.averageMultiplier = .95;
        this.delta = 0;
    },
    measure: function() {
        var current = new Date().getTime();
        if (current - this.lastMeasurement > 0) {
            this.frametime = this.frametime * this.averageMultiplier + this.delta * (1 - this.averageMultiplier);
            this.delta = current - this.lastMeasurement;
        }
        this.lastMeasurement = current;
    },
    getAverage: function() {
        if (this.frametime <= 0) return 0;
        return 1e3 / this.frametime;
    },
    getDelta: function() {
        return this.delta;
    }
});

var Engine = Class.extend({
    init: function(canvas, options, scene) {
        function extend() {
            for (var i = 1; i < arguments.length; i++) for (var key in arguments[i]) if (arguments[i].hasOwnProperty(key)) arguments[0][key] = arguments[i][key];
            return arguments[0];
        }
        if (!options) options = {};
        this.options = extend({
            shadersPath: "",
            requestedFPS: 30,
            debug: false,
            antialias: false,
            transparencyMode: "default",
            context: new RenderingContext(canvas)
        }, options);
        this.validateOptions();
        this.context = this.options.context;
        if (!scene) scene = new DefaultScene();
        this.scene = scene;
        this.scene.engine = this;
        this.fps = new FPS();
        this.running = false;
        this.assetsManager = new AssetsManager(this.context, this.options.shadersPath);
        this.WhiteTexture = new Texture(this.context);
        this.WhiteTexture.name = "WhiteTexture";
        this.WhiteTexture.mipmapped = false;
        this.WhiteTexture.clearImage(this.context, [ 255, 255, 255, 255 ]);
        this.WhiteTextureSampler = new Sampler("tex0", this.WhiteTexture);
        if (this.options.debug) {
            var me = this;
            this.context.canvas.bind("keydown", function(e) {
                if (e.which == "P".charCodeAt(0)) me.togglePause();
                if (e.which == "L".charCodeAt(0)) me.debug();
                if (e.which == "M".charCodeAt(0)) me.debugScene();
            });
        }
    },
    run: function() {
        if (this.running !== false) return;
        this.running = true;
        var now;
        var then = Date.now();
        var interval = 1e3 / this.options.requestedFPS;
        var delta;
        var scope = this;
        var requestAnimFrame = function() {
            return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(f) {
                window.setTimeout(f, 1e3 / 60);
            };
        }();
        function draw() {
            if (scope.running) requestAnimFrame(draw);
            now = Date.now();
            delta = now - then;
            if (delta > interval) {
                then = now - delta % interval;
                scope.frame();
            }
        }
        this.scene.start(this.context, this);
        requestAnimFrame(draw);
    },
    sceneStarted: function() {},
    stop: function() {
        this.pause();
        if (this.scene.started) this.scene.end(this.context);
    },
    pause: function() {
        this.running = false;
    },
    togglePause: function() {
        if (this.running === false) this.run(); else this.pause();
    },
    frame: function() {
        this.context.engine = this;
        this.scene.update(this);
        this.scene.render(this.context);
        this.fps.measure();
    },
    validateOptions: function() {
        switch (this.options.transparencyMode) {
          case "sorted":
          case "blended":
          case "stochastic":
            break;

          case "default":
          default:
            this.options.transparencyMode = "blended";
            break;
        }
    },
    debug: function() {
        var materials = {};
        var shaders = {};
        this.scene.root.onEachChildComponent(function(c) {
            if (c instanceof MeshComponent) {
                for (var i in c.mesh.submeshes) {
                    var material = c.mesh.getMaterial(c.mesh.submeshes[i].materialIndex);
                    if (!material) continue;
                    if (!materials[material.name]) materials[material.name] = {
                        count: 0
                    };
                    materials[material.name]["material"] = material;
                    materials[material.name]["count"]++;
                }
            }
        });
        console.log("Materials: ");
        for (var m in materials) {
            console.log(materials[m].material.name, materials[m]);
        }
    }
});