// Generated at Tue Dec 31 2019 09:55:13 GMT+0200 (EET)
var BuiltInShaders = {
	"default": {
		"shaders/default/DebugPackedDepthTexture.frag": "// DebugPackedDepthTexture\nprecision highp float;\n\n#define USE_VSM\n\nuniform mat4 modelview;\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec2 uv0;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\nfloat unpackHalf(vec2 c) {\n\treturn c.x + (c.y / 255.0);\n}\n\nvoid main(void) {\n\tvec4 texel = texture2D(diffuse0, uv0);\n\n#ifdef USE_VSM\n\tgl_FragColor = vec4(0.0, unpackHalf(texel.xy), unpackHalf(texel.zw), 1.0);\n#else\n\tfloat depth = unpack(texel);\n\tgl_FragColor = vec4(depth, depth, depth, 1.0);\n#endif\n}\n",
		"shaders/default/DebugPackedDepthTexture.vert": "// DebugPackedDepthTexture\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec2 uv0;\n\nvoid main() {\n\tuv0=texcoord2d0;\n\tviewPosition = modelview * vec4(position, 1.0);\n\tviewNormal = normalize(mat3(modelview)*normal);\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/default/DepthRGBA.frag": "// Shader for rendering linear depth values into RGBA texture\nprecision highp float;\n\nuniform mat4 modelview;\n// uniform float linearDepthConstant;\n\n/** Packing Type:\n\t1 - packs depth value into RGBA\n\t2 - packs depth into RG and depth*depth into BA\n**/\nuniform int packingType;\n\nvarying vec4 viewPosition;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvec2 packHalf(float depth) {\n\tconst vec2 bias = vec2(1.0 / 255.0, 0.0);\n\tvec2 c = vec2(depth, fract(depth * 255.0));\n\treturn c - (c.yy * bias);\n}\n\nvoid main () {\n\tif (packingType==2) {\n\t\tgl_FragColor = vec4(packHalf(gl_FragCoord.z), packHalf(gl_FragCoord.z*gl_FragCoord.z));\n\t}\n\telse {\n\t\tgl_FragColor = pack(gl_FragCoord.z); // less precision, but works on most systems\n\t\t// float linearDepth = length(viewPosition) * linearDepthConstant;\n\t\t// gl_FragColor = pack(linearDepth);\n\t}\n}\n",
		"shaders/default/DepthRGBA.vert": "// Shader for rendering linear depth values into RGBA texture\nattribute vec3 position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 viewPosition;\n\nvoid main() {\n\tviewPosition=modelview*vec4(position, 1.0);\n\tgl_Position=projection*viewPosition;\n}\n",
		"shaders/default/GaussianBlur.frag": "// Shader for rendering gaussian blurred image (horizontal)\nprecision highp float;\n\n#define MAX_BLUR_KERNEL_SIZE 10\n\nuniform float screenWidth;\nuniform float screenHeight;\nuniform int orientation; // 0 - horizontal, 1 - vertical\nuniform int kernelSize; // Recommended values: 3, 5, 7, 10 (10 is currently the maximum)\nuniform sampler2D tex0;\n\nvarying vec2 uv0;\n\nvoid main () {\n\tfloat halfSize = float(kernelSize)*0.5;\n\tvec2 texelSize = vec2(1.0/screenWidth, 1.0/screenHeight);\n\tvec4 color = vec4(0.0);\n\n\tif (orientation==1) {\n\t\t// vertical pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(0.0, offset * texelSize.y));\n\t\t}\n\t}\n\telse {\n\t\t// horizontal pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(offset * texelSize.x, 0.0));\n\t\t}\n\t}\n\tgl_FragColor = color / float(kernelSize);\n\t// gl_FragColor = texture2D(tex0, uv0);\n}\n",
		"shaders/default/GaussianBlur.vert": "// Shader for rendering gaussian blurred image (horizontal)\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float screenWidth;\nuniform float screenHeight;\n\nvarying vec2 uv0;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\t\n\t// Resizes the rendered unit-quad to screen size\n\tvec4 viewPosition=modelview*vec4(position.x*screenWidth, position.y*screenHeight, position.z, 1.0);\n\tgl_Position=projection*viewPosition;\n}\n",
		"shaders/default/OITAccum.frag": "/**\n * Based on the following ideas:\n *\n *   - Weighted Blended Order-Independent Transparency\n *     http://jcgt.org/published/0002/02/09/\n *\n *   - Stochastic Transparency\n *     http://www.nvidia.com/object/nvidia_research_pub_016.html\n *\n *   - Simplex noise (C) Ashima Arts\n *     https://github.com/ashima/webgl-noise\n */\n\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nuniform int render_mode;\n\nuniform float zNear;\nuniform float zFar;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p,s;\n\tp.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\ts = vec4(lessThan(p, vec4(0.0)));\n\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\treturn p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t\t-0.447213595499958); // -1 + 4 * G4\n\n\t// First corner\n\tvec4 i = floor(v + dot(v, vec4(F4)) );\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n\t// Other corners\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t// i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\t// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\t// x0 = x0 - 0.0 + 0.0 * C.xxxx\n\t// x1 = x0 - i1 + 1.0 * C.xxxx\n\t// x2 = x0 - i2 + 2.0 * C.xxxx\n\t// x3 = x0 - i3 + 3.0 * C.xxxx\n\t// x4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\t// Permutations\n\ti = mod289(i);\n\tfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n\tvec4 j1 = permute( permute( permute( permute (\n\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n\t// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt(dot(p4,p4));\n\n\t// Mix contributions from the five corners\n\tvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\tvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\treturn 49.0 *\n\t\t( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n\t\t+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat oit_weight(float z, vec4 color) {\n\treturn max(min(1.0, max(max(color.r, color.g), color.b) * color.a), color.a) * clamp(0.03 / (1e-5 + pow(z / 200.0, 4.0)), 1e-2, 3e3);\n}\n\nvec4 lighting() {\n\t/* TODO: proper lighting for transparent surfaces */\n\tvec4 textureColor = texture2D(diffuse0, fragTexcoord2d0);\n\tvec4 color = diffuse * textureColor;\n\treturn color;\n}\n\nvoid main(void) {\n\tvec4 color = lighting();\n\n\t// Weighted Blended Order-Independent Transparency color pass\n\tif (render_mode == 0) {\n\t\tfloat linDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * -fragPosition.z - 1.0) * (zFar - zNear));\n\t\tfloat weight = oit_weight(linDepth, color);\n\t\tgl_FragColor = vec4(color.rgb * color.a, color.a) * weight;\n\t}\n\n\t// Alpha reveal amount pass\n\telse if (render_mode == 1) {\n\t\tgl_FragColor = vec4(color.a); // total amount revealed (blending: 0; 1-src.a)\n\t}\n\n\t// Alpha mapping pass\n\telse if (render_mode == 2) {\n\t\tif (color.a < 0.99)\n\t\t\tdiscard;\n\t\tgl_FragColor = color;\n\t}\n\n\t// Stochastic transparency pass\n\telse if (render_mode == 3) {\n\t\tfloat random = snoise(fragPosition*150.0);\n\t\tif (random > color.a)\n\t\t\tdiscard;\n\t\tgl_FragColor = vec4(color.rgb * color.a, 1.0);\n\t}\n}\n",
		"shaders/default/OITAccum.vert": "/** Order independent transparency - vertex program */\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragNormal = mat3(modelview) * normal;\n\tfragPosition = modelview * vec4(position, 1.0);\n\tfragTexcoord2d0 = texcoord2d0;\n\tgl_Position = projection * fragPosition;\n}\n",
		"shaders/default/OITRender.frag": "/**\n * Weighted Blended Order-Independent Transparency - Compositing program\n * Based on http://jcgt.org/published/0002/02/09/\n */\n\nprecision highp float;\n\nvarying vec2 uv;\n\nuniform vec2 ViewportSize;\nuniform int render_mode;\n\nuniform sampler2D src;\nuniform sampler2D oitAccum;\nuniform sampler2D oitWeight;\n\nvoid addRelevantSample(vec2 coords, float weight, inout vec4 accum) {\n\tvec4 sample = texture2D(oitAccum, coords);\n\tif (sample.a < 1.0)\n\t\treturn;\n\tfloat a = texture2D(oitWeight, coords).a;\n\tif (a>0.99)\n\t\treturn;\n\taccum += sample * weight * a;\n}\n\nvec4 avgColor(sampler2D s, vec2 coords) {\n\tvec2 step = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\n\tvec2 kernel[8];\n\tkernel[0] = vec2(-step.x, step.y);\n\tkernel[1] = vec2(0.0, step.y);\n\tkernel[2] = vec2(step.x, step.y);\n\tkernel[3] = vec2(step.x, 0.0);\n\tkernel[4] = vec2(-step.x, 0.0);\n\tkernel[5] = vec2(-step.x, -step.y);\n\tkernel[6] = vec2(0.0, -step.y);\n\tkernel[7] = vec2(step.x, -step.y);\n\n\tvec4 sum = vec4(0.0);\n\tfloat weight = 1.0 / (2.0 + 1.0);\n\tfloat kernelSize = 1.0;\n\n\taddRelevantSample(coords, weight, sum);\n\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\tkernelSize = 2.0;\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\treturn sum;\n}\n\nvoid main(void) {\n\t// Blending: ONE_MINUS_SRC_ALPHA, SRC_ALPHA\n\n\tvec4 solidColor = texture2D(src, uv);\n\tfloat reveal = texture2D(oitWeight, uv).a;\n\tvec4 transparentColor;\n\n\t// Blended order transparency\n\tif (render_mode == 0) {\n\t\ttransparentColor = texture2D(oitAccum, uv);\n\n\t\tvec4 composite = vec4(transparentColor.rgb / max(transparentColor.a, 1e-5), reveal);\n\t\tgl_FragColor = (1.0-composite.a) * composite +  composite.a * solidColor;\n\t}\n\n\t// Stochastic transparency\n\telse if (render_mode == 1) {\n\t\ttransparentColor = avgColor(oitAccum, uv);\n\t\tgl_FragColor = (1.0 - reveal) * transparentColor + reveal * solidColor;\n\t}\n}\n",
		"shaders/default/OITRender.vert": "/** Order independent transparency - vertex program */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/ScreenQuad.frag": "// Shader for rendering a screen aligned quad for image space effects\n\nprecision highp float;\n\nvarying vec2 uv;\nuniform sampler2D tex0;\n\nvoid main () {\n\tgl_FragColor = texture2D(tex0, uv);\n}\n",
		"shaders/default/ScreenQuad.vert": "// Shader for rendering a screen aligned quad for image space effects\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/attributes.frag": "// Attributes shader\nprecision mediump float; \n\nuniform float texCoord2d0Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d1Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d2Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d3Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float positionMultiplier;\t\t\t\t// Position output multiplier between 0 and 1\nuniform float tangentMultiplier;\t\t\t\t// Tangent output multiplier between 0 and 1\nuniform float bitangentMultiplier;\t\t\t// BiTangent output multiplier between 0 and 1\nuniform float normalMultiplier;\t\t\t\t\t// Normal output multiplier between 0 and 1\nuniform float barycentricMultiplier;\t\t// Barycentric output multiplier between 0 and 1\n\nvarying vec2 fragTexcoord2d0;\nvarying vec2 fragTexcoord2d1;\nvarying vec2 fragTexcoord2d2;\nvarying vec2 fragTexcoord2d3;\nvarying vec4 fragPosition;\nvarying vec4 fragTangent;\nvarying vec4 fragBitangent;\nvarying vec4 fragNormal;\nvarying vec3 fragBarycentric;\n\nvoid main(void) {\n\tgl_FragColor = \n\t\tvec4(fragTexcoord2d0, 0.0, 1.0)*texCoord2d0Multiplier+\n\t\tvec4(fragTexcoord2d1, 0.0, 1.0)*texCoord2d1Multiplier+\n\t\tvec4(fragTexcoord2d2, 0.0, 1.0)*texCoord2d2Multiplier+\n\t\tvec4(fragTexcoord2d3, 0.0, 1.0)*texCoord2d3Multiplier+\n\t\tvec4(fragPosition.rgb, 1.0)*positionMultiplier+\n\t\tvec4(fragTangent.rgb, 1.0)*tangentMultiplier+\n\t\tvec4(fragBitangent.rgb, 1.0)*bitangentMultiplier+\n\t\tvec4(fragNormal.rgb, 1.0)*normalMultiplier+\n\t\tvec4(fragBarycentric, 1.0)*barycentricMultiplier;\n}",
		"shaders/default/attributes.vert": "// Attributes shader\nattribute vec3 position; \nattribute vec3 tangent; \nattribute vec3 bitangent; \nattribute vec3 normal; \nattribute vec3 barycentric; \nattribute vec2 texcoord2d0; \nattribute vec2 texcoord2d1;\nattribute vec2 texcoord2d2; \nattribute vec2 texcoord2d3; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec2 fragTexcoord2d0;\nvarying vec2 fragTexcoord2d1;\nvarying vec2 fragTexcoord2d2;\nvarying vec2 fragTexcoord2d3;\nvarying vec4 fragPosition;\nvarying vec4 fragTangent;\nvarying vec4 fragBitangent;\nvarying vec4 fragNormal;\nvarying vec3 fragBarycentric;\n\nvoid main() {\n\tfragNormal=projection*modelview*vec4(normal, 1.0); \n\tfragPosition=projection*modelview*vec4(position, 1.0); \n\tfragTangent=projection*modelview*vec4(tangent, 1.0); \n\tfragBitangent=projection*modelview*vec4(bitangent, 1.0); \n  fragTexcoord2d0=texcoord2d0;\n  fragTexcoord2d1=texcoord2d1;\n  fragTexcoord2d2=texcoord2d2;\n  fragTexcoord2d3=texcoord2d3;\n  fragBarycentric=barycentric;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/default/debug.frag": "// Fallback shader\nprecision mediump float; \n\nuniform vec4 color;\n\nvoid main(void) { \n\tgl_FragColor = color;\n}",
		"shaders/default/debug.vert": "// Debug shader\nattribute vec3 position; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragPosition;\n\nvoid main() {\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n\tgl_Position=fragPosition;\n}\n",
		"shaders/default/deferred_background.frag": "precision highp float;\n\nuniform vec4 color;\n\nvarying vec2 uv;\n\nvoid main () {\n\tgl_FragColor = color;\n}\n",
		"shaders/default/deferred_background.vert": "attribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/deferred_gbuffer.frag": "#extension GL_EXT_draw_buffers : require\n\nprecision highp float;\n\nuniform mat4 view;\nuniform mat4 viewInverse;\n\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\nuniform float lightContribution;\nuniform int useNormalmap;\nuniform int useReflection;\nuniform int receiveShadows;\n\nuniform float materialBlend;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform samplerCube env0;\nuniform sampler2D mask;\n\nvarying float depth;\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\n\nvarying mat3 tbn;\n\nvec3 reflection() {\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\n\tvec4 color = textureCube(env0, lookup);\n\treturn color.rgb;\n}\n\nvoid main() {\n\tvec4 textureColor = texture2D(diffuse0, uv0);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tvec3 N = viewNormal;\n\tif (useNormalmap == 1) {\n\t\tvec4 encodedNormal = texture2D(normal0, uv0);\n\t\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\t\tN = normalize(tbn * localCoords);\n\t\tN = normalize(mat3(view) * N);\n\t}\n\n\tif (useReflection == 1) {\n\t\tvec3 refl = reflection();\n\t\tfloat maskValue = texture2D(mask, uv0).r;\n\t\tcolor.rgb = mix(refl, color.rgb, maskValue * materialBlend);\n\t}\n\n\tgl_FragData[0] = vec4(color.rgb, specularStrength);\n\tgl_FragData[1] = vec4(N, depth);\n\tgl_FragData[2] = vec4(worldPosition.xyz, float(specularPower)/255.0);\n\tgl_FragData[3] = vec4(lightContribution, receiveShadows, depth, 1.0);\n}\n",
		"shaders/default/deferred_gbuffer.vert": "attribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\nattribute vec3 tangent;\nattribute vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nvarying float depth;\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\n\nvarying mat3 tbn;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/default/deferred_light_ambient.frag": "precision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec4 lightColor;\n\nvarying vec2 uv;\n\nvoid main () {\n\tvec4 data0 = texture2D(gb0, uv);\n\tvec3 color = data0.rgb * lightColor.rgb;\n\tgl_FragColor = vec4(color, 1.0);\n}\n\n",
		"shaders/default/deferred_light_ambient.vert": "attribute vec3 position;\nattribute vec2 texcoord2d0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/deferred_light_directional.frag": "precision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec3 cameraPosition;\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nuniform mat4 view;\nuniform mat4 lightView;\nuniform mat4 lightProjection;\nuniform float shadowBias;\n\nuniform int useShadows;\nuniform int useSoftShadows;\nuniform int shadowOnly;\n\nvarying vec2 uv;\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap(vec4 worldPosition) {\n\tvec4 shadowPosition = lightProjection * lightView * worldPosition;\n\tvec2 shadowUV = shadowPosition.xy / shadowPosition.w;\n\tshadowUV = shadowUV * 0.5 + 0.5;\n\tvec4 shadowTexel = texture2D(shadow0, shadowUV);\n\n\treturn VSM(shadowTexel.xy, shadowPosition.z);\n\t// return step(shadowPosition.z - shadowBias, shadowTexel.r);\n}\n\nvoid main () {\n\tvec4 data2 = texture2D(gb2, uv); // position, specularPower/255\n\tvec4 data3 = texture2D(gb3, uv); // material parameters: (lightContribution, receiveShadows, unused, unused)\n\tvec4 P = vec4(data2.xyz, 1.0);\n\n\tfloat shadow = 1.0;\n\n\tif (useShadows == 1 && data3.g > 0.0) {\n\t\tif (useSoftShadows == 1)\n\t\t\tshadow = texture2D(shadow0, uv).r;\n\t\telse\n\t\t\tshadow = shadowmap(P);\n\t}\n\n\tif (shadowOnly == 1) {\n\t\tgl_FragColor = vec4(shadow, shadow, shadow, 1.0);\n\t\treturn;\n\t}\n\n\tvec4 data0 = texture2D(gb0, uv); // color, specularIntensity\n\n\tvec4 data1 = texture2D(gb1, uv); // normal, depth\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec4 viewPosition = view * P;\n\tvec3 L = normalize(mat3(view) * lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 lighting = diffuseColor + specularColor;\n\n\tvec3 final = shadow * mix(C, lighting, data3.r);\n\tgl_FragColor = vec4(final, 1.0);\n}\n",
		"shaders/default/deferred_light_directional.vert": "attribute vec3 position;\nattribute vec2 texcoord2d0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/deferred_light_omni.frag": "precision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\n\nuniform vec4 lightColor;\nuniform vec3 lightPosition;\nuniform float lightIntensity;\nuniform float lightRadius;\n\nuniform mat4 view;\nuniform vec3 cameraPosition;\n\nvarying vec4 screenPosition;\n\nvoid main() {\n\tvec2 uv = screenPosition.xy;\n\tuv /= screenPosition.w;\n\tuv = 0.5 * (vec2(uv.x, uv.y) + 1.0);\n\n\tvec4 data0 = texture2D(gb0, uv); // color.rgb, specularIntensity\n\tvec4 data1 = texture2D(gb1, uv); // normal.xyz, depth\n\tvec4 data2 = texture2D(gb2, uv); // position.xyz, specularPower/255\n\t// vec4 data3 = texture2D(gb3, uv); // unused\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tvec3 P = data2.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec3 lightVector = lightPosition - P;\n\tfloat attenuation = clamp(1.0 - length(lightVector)/lightRadius, 0.0, 1.0);\n\tlightVector = normalize(lightVector);\n\n\tvec4 viewPosition = view * vec4(P, 1.0);\n\tvec3 L = normalize(mat3(view) * lightVector);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 final = attenuation * (diffuseColor + specularColor);\n\n\tgl_FragColor = vec4(final, 1.0);\n}\n",
		"shaders/default/deferred_light_omni.vert": "attribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 screenPosition;\n\nvoid main() {\n\tscreenPosition = projection * view * model * vec4(position, 1.0);\n\tgl_Position = screenPosition;\n}\n",
		"shaders/default/deferred_shadow_directional.frag": "/** Directional light shadow-map */\n#extension GL_OES_standard_derivatives : require\n\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 textureColor = texture2D(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat dx = dFdx(depth);\n\tfloat dy = dFdy(depth);\n\tgl_FragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}\n",
		"shaders/default/deferred_shadow_directional.vert": "/** Directional light shadow-map */\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/default/depth.frag": "// Shader for rendering linear depth values into a floating point texture\nprecision mediump float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 textureColor = texture2D(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tgl_FragColor = vec4(depth, depth, depth, depth);\n}\n",
		"shaders/default/depth.vert": "// Shader for rendering linear depth values into a floating point texture\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\tuv = texcoord2d0;\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/default/diffuse.frag": "// Diffuse shader\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 textureColor = texture2D(diffuse0, uv0);\n\tvec3 N = normalize(viewNormal);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture2D(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tgl_FragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/default/diffuse.vert": "// Diffuse shader\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvoid main() {\n\n\tuv0 = texcoord2d0; // TODO: In the future this will probably need to use texture offset and scale uniforms\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/default/fallback.frag": "// Fallback shader\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
		"shaders/default/fallback.vert": "// Fallback shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n  fragNormal=modelview*vec4(normal, 1.0);\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n  fragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/default/font.frag": "// Diffuse shader\nprecision mediump float; \n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform int page;\t\t\t\t\t\t// The font page texture\n\nuniform sampler2D page0;\t\t\nuniform sampler2D page1;\nuniform sampler2D page2;\nuniform sampler2D page3;\nuniform sampler2D page4;\nuniform sampler2D page5;\nuniform sampler2D page6;\nuniform sampler2D page7;\n\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tvec4 c;\n\tif(page==0) c = texture2D(page0, fragTexcoord2d0);\n\tif(page==1) c = texture2D(page1, fragTexcoord2d0);\n\tif(page==2) c = texture2D(page2, fragTexcoord2d0);\n\tif(page==3) c = texture2D(page3, fragTexcoord2d0);\n\tif(page==4) c = texture2D(page4, fragTexcoord2d0);\n\tif(page==5) c = texture2D(page5, fragTexcoord2d0);\n\tif(page==6) c = texture2D(page6, fragTexcoord2d0);\n\tif(page==7) c = texture2D(page7, fragTexcoord2d0);\n\tgl_FragColor=vec4(diffuse.r*c.r, diffuse.g*c.g, diffuse.b*c.b, c.a);\n}",
		"shaders/default/font.vert": "// Font shader\nattribute vec3 position; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/default/forward_shadow.frag": "/** Directional light shadow-map */\nprecision highp float;\n\nuniform int hasFloat;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nvarying float depth;\nvarying vec2 uv;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n\tvec4 textureColor = texture2D(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\n\tif (hasFloat == 1) {\n\t\tgl_FragColor = vec4(d, d, d, 1.0);\n\t}\n\telse {\n\t\tgl_FragColor = pack(d);\n\t}\n\n}\n",
		"shaders/default/forward_shadow.vert": "/** Directional light shadow-map */\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/default/forward_shadow_vsm.frag": "/** Directional light shadow-map */\n#extension GL_OES_standard_derivatives : require\n\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nvarying float depth;\nvarying vec2 uv;\n\nvoid main() {\n\tvec4 textureColor = texture2D(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\tfloat dx = dFdx(d);\n\tfloat dy = dFdy(d);\n\n\tgl_FragColor = vec4(d, pow(d, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}\n",
		"shaders/default/normalmapped.frag": "// Normal mapped diffuse shader\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 encodedNormal = texture2D(normal0, uv0);\n\t// vec3 localCoords = 2.0 * encodedNormal.rgb - vec3(1.0);\n\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\tvec3 normalDirection = normalize(tbn * localCoords);\n\tvec3 N = normalize(mat3(view) * normalDirection);\n\n\tvec4 textureColor = texture2D(diffuse0, uv0);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture2D(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tgl_FragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/default/normalmapped.vert": "// Normal mapped diffuse shader\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\nattribute vec3 tangent;\nattribute vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\nuniform vec3 lightDirection;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nhighp mat3 transpose(in highp mat3 m) {\n\thighp vec3 i0 = m[0];\n\thighp vec3 i1 = m[1];\n\thighp vec3 i2 = m[2];\n\thighp mat3 outMatrix = mat3(\n\t\tvec3(i0.x, i1.x, i2.x),\n\t\tvec3(i0.y, i1.y, i2.y),\n\t\tvec3(i0.z, i1.z, i2.z)\n\t);\n\treturn outMatrix;\n}\n\nvoid main() {\n\tuv0 = texcoord2d0; // TODO: In the future this will probably need to use texture offset and scale uniforms\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = normalize(mat3(modelview) * normal);\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/default/positionbuffer.frag": "//Normal buffer\nprecision highp float;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform mat4 modelview;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n    float linDepth = (-viewPosition.z - zNear) / (zFar - zNear);\n    gl_FragColor = pack(linDepth);\n}",
		"shaders/default/positionbuffer.vert": "//Normal buffer\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvoid main() {\n    worldPosition = model * vec4(position, 1.0);\n    viewPosition = view * worldPosition;\n    worldNormal = normalize(mat3(model)*normal);\n    viewNormal = mat3(modelview) * normal;\n    \n    gl_Position = projection * viewPosition;\n}",
		"shaders/default/postprocess_blur.frag": "/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nvarying highp vec2 blurCoords[5];\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture2D(src, blurCoords[0]) * 0.204164;\n\tsum += texture2D(src, blurCoords[1]) * 0.304005;\n\tsum += texture2D(src, blurCoords[2]) * 0.304005;\n\tsum += texture2D(src, blurCoords[3]) * 0.093913;\n\tsum += texture2D(src, blurCoords[4]) * 0.093913;\n\tgl_FragColor = sum;\n}\n",
		"shaders/default/postprocess_blur.vert": "/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform vec2 ViewportSize;\nuniform vec2 BlurSize;\n\nvarying vec2 blurCoords[5];\n\nvoid main() {\n\tvec2 offset = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y) * BlurSize;\n\n\tblurCoords[0] = uv0;\n\tblurCoords[1] = uv0 + offset * 1.407333;\n\tblurCoords[2] = uv0 - offset * 1.407333;\n\tblurCoords[3] = uv0 + offset * 3.294215;\n\tblurCoords[4] = uv0 - offset * 3.294215;\n\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/postprocess_fxaa.frag": "/**\n * FXAA post-process\n *\n * Based on webgl-meincraft FXAA implementation.\n * https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n */\n\n/*\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Basic FXAA implementation based on the code on geeks3d.com with the\n * modification that the texture2DLod stuff was removed since it's\n * unsupported by WebGL.\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nuniform vec2 ViewportSize;\nuniform float reduce_min;\nuniform float reduce_mul;\nuniform float span_max;\n\nvarying vec2 uv;\n\nvec4 fxaa(sampler2D tex, vec2 texCoord) {\n\tvec4 color;\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec3 rgbNW = texture2D(tex, texCoord + vec2(-1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbNE = texture2D(tex, texCoord + vec2(1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbSW = texture2D(tex, texCoord + vec2(-1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbSE = texture2D(tex, texCoord + vec2(1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbM = texture2D(tex, texCoord).xyz;\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM = dot(rgbM, luma);\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * reduce_mul), reduce_min);\n\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(span_max, span_max), max(vec2(-span_max, -span_max), dir * rcpDirMin)) * inverseVP;\n\n\tvec3 rgbA = 0.5 * (\n\t\ttexture2D(tex, texCoord + dir * (1.0 / 3.0 - 0.5)).xyz +\n\t\ttexture2D(tex, texCoord + dir * (2.0 / 3.0 - 0.5)).xyz);\n\tvec3 rgbB = rgbA * 0.5 + 0.25 * (\n\t\ttexture2D(tex, texCoord + dir * -0.5).xyz +\n\t\ttexture2D(tex, texCoord + dir * 0.5).xyz);\n\n\tfloat lumaB = dot(rgbB, luma);\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\t\tcolor = vec4(rgbA, 1.0);\n\telse\n\t\tcolor = vec4(rgbB, 1.0);\n\treturn color;\n}\n\nvoid main () {\n\tgl_FragColor = fxaa(src, uv);\n}\n",
		"shaders/default/postprocess_fxaa.vert": "/** FXAA post-process effect vertex shader */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/postprocess_ssao.frag": "/*\n * Screen space ambient occlusion post process\n *\n * SSAO GLSL shader v1.2\n * assembled by Martins Upitis (martinsh) (devlog-martinsh.blogspot.com)\n * original technique is made by Arkano22 (www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n *\n * Changelog:\n * 1.2 - added fog calculation to mask AO. Minor fixes.\n * 1.1 - added spiral sampling method from here:\n * (http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere)\n */\n\nprecision highp float;\n\n#define PI 3.14159265\n\nuniform sampler2D depth0;\nuniform sampler2D oitWeight;\nuniform sampler2D src;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoOnly;\nuniform float gdisplace; // Gauss bell center, default: 0.3\nuniform float radius; // AO radius, default: 2.0\nuniform float brightness; // AO brightness, default: 1.0\nuniform float luminanceInfluence; // how much luminance affects occlusion, default: 0.7\n\nconst int samples = 16;\n// const int samples = 8;\n\nfloat aoclamp = 0.25; // depth clamp - reduces haloing at screen edges\nbool noise = true; // use noise instead of pattern for sample dithering\nfloat noiseamount = 0.0002; // dithering amount\nfloat diffarea = 0.4; // self-shadowing reduction\n\nvec2 rand(vec2 coord) {\n\tfloat noiseX = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.25)+(fract(coord.t*(ViewportSize.y/2.0))*0.75))*2.0-1.0;\n\tfloat noiseY = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.75)+(fract(coord.t*(ViewportSize.y/2.0))*0.25))*2.0-1.0;\n\tif (noise) {\n\t\tnoiseX = clamp(fract(sin(dot(coord, vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t\tnoiseY = clamp(fract(sin(dot(coord, vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t}\n\treturn vec2(noiseX, noiseY) * noiseamount;\n}\n\nfloat readDepth(in vec2 coord) {\n\treturn texture2D(depth0, coord).r;\n}\n\nfloat compareDepths(in float depth1, in float depth2, inout int far) {\n\tfloat garea = 2.0; // gauss bell width\n\tfloat diff = (depth1 - depth2)*100.0; // depth difference (0-100)\n\t// reduce left bell width to avoid self-shadowing\n\tif (diff<gdisplace) {\n\t\tgarea = diffarea;\n\t}\n\telse {\n\t\tfar = 1;\n\t}\n\n\tfloat gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));\n\treturn gauss;\n}\n\nfloat calAO(vec2 uv, float depth, float dw, float dh) {\n\tfloat dd = (1.0-depth) * radius;\n\n\tfloat temp = 0.0;\n\tfloat temp2 = 0.0;\n\tfloat coordw = uv.x + dw*dd;\n\tfloat coordh = uv.y + dh*dd;\n\tfloat coordw2 = uv.x - dw*dd;\n\tfloat coordh2 = uv.y - dh*dd;\n\n\tvec2 coord = vec2(coordw , coordh);\n\tvec2 coord2 = vec2(coordw2, coordh2);\n\n\tint far = 0;\n\ttemp = compareDepths(depth, readDepth(coord), far);\n\t//DEPTH EXTRAPOLATION:\n\tif (far > 0) {\n\t\ttemp2 = compareDepths(readDepth(coord2), depth, far);\n\t\ttemp += (1.0-temp)*temp2;\n\t}\n\n\treturn temp;\n}\n\nvoid main() {\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec2 texCoord = gl_FragCoord.xy * inverseVP;\n\n\tvec2 noise = rand(texCoord);\n\tfloat depth = readDepth(texCoord);\n\tfloat reveal = texture2D(oitWeight, texCoord).a;\n\n\tfloat w = inverseVP.x/clamp(depth, aoclamp,1.0)+(noise.x*(1.0-noise.x));\n\tfloat h = inverseVP.y/clamp(depth, aoclamp,1.0)+(noise.y*(1.0-noise.y));\n\n\tfloat pw;\n\tfloat ph;\n\n\tfloat ao;\n\n\tfloat dl = PI*(3.0-sqrt(5.0));\n\tfloat dz = 1.0/float(samples);\n\tfloat l = 0.0;\n\tfloat z = 1.0 - dz/2.0;\n\n\tfor (int i = 0; i <= samples; i++) {\n\t\tfloat r = sqrt(1.0-z);\n\t\tpw = cos(l)*r;\n\t\tph = sin(l)*r;\n\t\tao += calAO(texCoord, depth, pw*w, ph*h);\n\t\tz = z - dz;\n\t\tl = l + dl;\n\t}\n\n\tao /= float(samples) * brightness;\n\tao = 1.0 - ao * reveal;\n\n\tvec3 color = texture2D(src, texCoord).rgb;\n\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\tfloat lum = dot(color.rgb, lumcoeff);\n\tvec3 luminance = vec3(lum, lum, lum);\n\tvec3 final = vec3(color*mix(vec3(ao),vec3(1.0), luminance * luminanceInfluence));\n\n\tif (ssaoOnly == 1) {\n\t\tfinal = vec3(mix(vec3(ao),vec3(1.0),luminance * luminanceInfluence));\n\t}\n\n\tgl_FragColor = vec4(final, 1.0);\n}\n",
		"shaders/default/postprocess_ssao.vert": "/*\n * Screen space ambient occlusion post process\n */\nattribute vec3 position;\n\nvoid main() {\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/default/reflective.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/default/reflective.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/default/reflective_masked.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\nuniform sampler2D mask;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tfloat maskValue = texture2D(mask, uv0).r;\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), maskValue * materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, maskValue * materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/default/reflective_masked.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/default/shadow_blur.frag": "/**\n * Shadow blur\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying highp vec2 blurCoords[14];\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture2D(src, blurCoords[ 0])*0.0044299121055113265;\n\tsum += texture2D(src, blurCoords[ 1])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[ 2])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[ 3])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[ 4])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[ 5])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 6])*0.147308056121;\n\tsum += texture2D(src, uv            )*0.159576912161;\n\tsum += texture2D(src, blurCoords[ 7])*0.147308056121;\n\tsum += texture2D(src, blurCoords[ 8])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 9])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[10])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[11])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[12])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[13])*0.0044299121055113265;\n\tgl_FragColor = sum;\n}\n",
		"shaders/default/shadow_blurh.vert": "/**\n * Shadow blur - horizontal\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(-0.028, 0.0) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(-0.024, 0.0) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(-0.020, 0.0) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(-0.016, 0.0) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(-0.012, 0.0) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(-0.008, 0.0) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(-0.004, 0.0) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2( 0.004, 0.0) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2( 0.008, 0.0) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2( 0.012, 0.0) * blurSize;\n\tblurCoords[10] = uv0 + vec2( 0.016, 0.0) * blurSize;\n\tblurCoords[11] = uv0 + vec2( 0.020, 0.0) * blurSize;\n\tblurCoords[12] = uv0 + vec2( 0.024, 0.0) * blurSize;\n\tblurCoords[13] = uv0 + vec2( 0.028, 0.0) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/shadow_blurv.vert": "/**\n * Shadow blur - vertical\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(0.0, -0.028) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(0.0, -0.024) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(0.0, -0.020) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(0.0, -0.016) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(0.0, -0.012) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(0.0, -0.008) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(0.0, -0.004) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2(0.0,  0.004) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2(0.0,  0.008) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2(0.0,  0.012) * blurSize;\n\tblurCoords[10] = uv0 + vec2(0.0,  0.016) * blurSize;\n\tblurCoords[11] = uv0 + vec2(0.0,  0.020) * blurSize;\n\tblurCoords[12] = uv0 + vec2(0.0,  0.024) * blurSize;\n\tblurCoords[13] = uv0 + vec2(0.0,  0.028) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/default/ssao.frag": "precision highp float;\n\nuniform sampler2D position0;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform float ssaoGDisplace;\nuniform float ssaoRadius;\nuniform float ssaoDivider;\n\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\n\nfloat unpack(vec4 c) {\n    const vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n    return dot(c, bitShifts);\n}\n\nfloat getDepth(vec2 coord) {\n    float d = unpack(texture2D(position0, coord.xy));\n    if (d == 0.0)\n        d = 1.0;\n    return d;\n}\n\nfloat doAmbientOcclusion(vec2 coord, vec2 coord2, float d) {\n    float diff = getDepth(coord + coord2) - d;\n    float gDisplace = -0.0002 - (0.00002 * max(min(ssaoGDisplace, 10.0), 0.0));\n    //float gDisplace = -0.00032;\n    return (diff < gDisplace) ? pow(EULER, -2.0 * (diff - gDisplace) * (diff - gDisplace) * 10000.0 / 0.16) : 0.0;\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    vec2 c = gl_FragCoord.xy * inverseVP;\n    \n    float ao = 0.0;\n\n    float dz = 1.0 / 8.0;\n    float z = 1.0 - dz / 2.0;\n    float l = 0.0;\n\n    float depth = getDepth(c);\n\n    for (int i = 0; i <= 8; i++) {\n        float r = sqrt(1.0 - z);\n\n        vec2 p = vec2(cos(l) * r, sin(l) * r);\n        ao += doAmbientOcclusion(c, p * ssaoRadius * inverseVP.x * (1.0 - depth), depth);\n        z = z - dz;\n        l = l + DL;\n    }\n\n    ao /= 8.0 + max(min(ssaoDivider, 1.0), -1.0);\n    //ao /= 8.5;\n    \n    ao = max(0.0, ao * 2.0 - 1.0);\n    ao = 1.0 - ao;\n    gl_FragColor = vec4(ao, ao, ao, 1.0);\n    //gl_FragColor = vec4(depth, depth, depth, 1.0);\n    //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}",
		"shaders/default/ssao.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/default/ssaoblur.frag": "precision highp float;\n\nuniform sampler2D ao0;\nuniform sampler2D src;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoBlurSize;\nuniform int ssaoOnly;\n\nfloat random(vec2 co) {\n    //co = mod(co, 128.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    const int MAXIMUM_BLUR = 32;\n    float result = 0.0;\n    vec2 hlim = vec2(float(-ssaoBlurSize) * 0.5 + 0.5);\n    for (int i = 0; i < MAXIMUM_BLUR; i++) {\n        if (i >= ssaoBlurSize)\n            break;\n        for (int j = 0; j < MAXIMUM_BLUR; j++) {\n            if (j >= ssaoBlurSize)\n                break;\n            vec2 offset = (hlim + vec2(float(i), float(j))) * inverseVP;\n            result += texture2D(ao0, gl_FragCoord.xy * inverseVP + offset).r;\n        }\n    }\n    result = result / float(ssaoBlurSize * ssaoBlurSize);\n\n    if (ssaoOnly == 1) {\n        gl_FragColor = vec4(vec3(result), 1.0);\n    }\n    else {\n        gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * result, 1.0);\n    }\n    //gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * texture2D(ao0, gl_FragCoord.xy * inverseVP/* / 2.0 + 0.5*/).xyz, 1.0);\n}",
		"shaders/default/ssaoblur.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/default/terrain.frag": "// Terrain shader for the forward renderer\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\r\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\tvec4 color = lighting(shadow);\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n\r\n\t// gl_FragColor = vec4(bc, 1.0); // for debug\r\n}\r\n",
		"shaders/default/terrain.vert": "// Terrain shader for the forward renderer\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\nattribute vec3 barycentric;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nuniform sampler2D height;\r\n\r\nuniform float verticalScale;\r\nuniform vec2 uvOffset;\r\nuniform vec2 uvScale;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat snap(float f, float step) {\r\n\treturn step * floor(f / step);\r\n}\r\n\r\nvoid main() {\r\n\tbc = barycentric;\r\n\tuv0 = texcoord2d0 * uvScale + uvOffset;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\r\n\t// worldPosition.x = snap(worldPosition.x, worldPosition.y);\r\n\t// worldPosition.z = snap(worldPosition.z, worldPosition.y);\r\n\r\n\tfloat height = texture2D(height, uv0).r;\r\n\tworldPosition.y = height * verticalScale;\r\n\t// worldPosition.y = 0.0;\r\n\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/default/test.frag": "// Test fragment shader drawing in blue \n\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(0.1, 0.5, 0.8, 1.0); \n}",
		"shaders/default/test.vert": "// Test pass-through shader that doesn't transform vertex\nattribute vec3 position; \nattribute vec3 normal; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\n\nvoid main(void) { \n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=projection*modelview*vec4(position, 1.0);\n\tgl_Position = fragPosition; \n}\n",
		"shaders/default/transparent.frag": "// Unlit transparency shader\nprecision mediump float; \n\nuniform vec4 diffuse;\n\nuniform sampler2D diffuse0;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tgl_FragColor = diffuse*texture2D(diffuse0, fragTexcoord2d0);\n}",
		"shaders/default/transparent.vert": "// Unlit transparency shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=modelview*vec4(position, 1.0);\n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=projection*fragPosition;\n}\n",
		"shaders/default/wireframe.frag": "// Test fragment shader drawing in blue \nprecision mediump float; \n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, \n\t\t\tpow(1.0-fragBarycentric.r, 32.0)+pow(1.0-fragBarycentric.g, 32.0)+pow(1.0-fragBarycentric.b, 32.0));\n}",
		"shaders/default/wireframe.vert": "// Diffuse shader\nattribute vec3 position; \nattribute vec3 barycentric; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\tgl_Position=projection*modelview*vec4(position, 1.0); \n\tfragBarycentric = barycentric;\n}"
	},
	"webgl2": {
		"shaders/webgl2/DebugPackedDepthTexture.frag": "#version 300 es\n\nprecision highp float;\n\n#define USE_VSM\n\nuniform mat4 modelview;\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec2 uv0;\n\nout vec4 fragColor;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\nfloat unpackHalf(vec2 c) {\n\treturn c.x + (c.y / 255.0);\n}\n\nvoid main(void) {\n\tvec4 texel = texture(diffuse0, uv0);\n\n#ifdef USE_VSM\n\tfragColor = vec4(0.0, unpackHalf(texel.xy), unpackHalf(texel.zw), 1.0);\n#else\n\tfloat depth = unpack(texel);\n\tfragColor = vec4(depth, depth, depth, 1.0);\n#endif\n}\n",
		"shaders/webgl2/DebugPackedDepthTexture.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 viewPosition;\nout vec3 viewNormal;\nout vec2 uv0;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tviewPosition = modelview * vec4(position, 1.0);\n\tviewNormal = normalize(mat3(modelview)*normal);\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/DepthRGBA.frag": "#version 300 es\n\n// Shader for rendering linear depth values into RGBA texture\nprecision highp float;\n\nuniform mat4 modelview;\n// uniform float linearDepthConstant;\n\n/** Packing Type:\n\t1 - packs depth value into RGBA\n\t2 - packs depth into RG and depth*depth into BA\n**/\nuniform int packingType;\n\nin vec4 viewPosition;\nout vec4 fragColor;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvec2 packHalf(float depth) {\n\tconst vec2 bias = vec2(1.0 / 255.0, 0.0);\n\tvec2 c = vec2(depth, fract(depth * 255.0));\n\treturn c - (c.yy * bias);\n}\n\nvoid main () {\n\tif (packingType==2) {\n\t\tfragColor = vec4(packHalf(gl_FragCoord.z), packHalf(gl_FragCoord.z*gl_FragCoord.z));\n\t}\n\telse {\n\t\tfragColor = pack(gl_FragCoord.z); // less precision, but works on most systems\n\t\t// float linearDepth = length(viewPosition) * linearDepthConstant;\n\t\t// fragColor = pack(linearDepth);\n\t}\n}\n",
		"shaders/webgl2/DepthRGBA.vert": "#version 300 es\n\n// Shader for rendering linear depth values into RGBA texture\nin vec3 position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 viewPosition;\n\nvoid main() {\n\tviewPosition = modelview * vec4(position, 1.0);\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/GaussianBlur.frag": "// Shader for rendering gaussian blurred image (horizontal)\nprecision highp float;\n\n#define MAX_BLUR_KERNEL_SIZE 10\n\nuniform float screenWidth;\nuniform float screenHeight;\nuniform int orientation; // 0 - horizontal, 1 - vertical\nuniform int kernelSize; // Recommended values: 3, 5, 7, 10 (10 is currently the maximum)\nuniform sampler2D tex0;\n\nvarying vec2 uv0;\n\nvoid main () {\n\tfloat halfSize = float(kernelSize)*0.5;\n\tvec2 texelSize = vec2(1.0/screenWidth, 1.0/screenHeight);\n\tvec4 color = vec4(0.0);\n\n\tif (orientation==1) {\n\t\t// vertical pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(0.0, offset * texelSize.y));\n\t\t}\n\t}\n\telse {\n\t\t// horizontal pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(offset * texelSize.x, 0.0));\n\t\t}\n\t}\n\tgl_FragColor = color / float(kernelSize);\n\t// gl_FragColor = texture2D(tex0, uv0);\n}\n",
		"shaders/webgl2/GaussianBlur.vert": "// Shader for rendering gaussian blurred image (horizontal)\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float screenWidth;\nuniform float screenHeight;\n\nvarying vec2 uv0;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\t\n\t// Resizes the rendered unit-quad to screen size\n\tvec4 viewPosition=modelview*vec4(position.x*screenWidth, position.y*screenHeight, position.z, 1.0);\n\tgl_Position=projection*viewPosition;\n}\n",
		"shaders/webgl2/OITAccum.frag": "#version 300 es\n\n/**\n * Based on the following ideas:\n *\n *   - Weighted Blended Order-Independent Transparency\n *     http://jcgt.org/published/0002/02/09/\n *\n *   - Stochastic Transparency\n *     http://www.nvidia.com/object/nvidia_research_pub_016.html\n *\n *   - Simplex noise (C) Ashima Arts\n *     https://github.com/ashima/webgl-noise\n */\n\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nuniform int render_mode;\n\nuniform mat4 viewInverse;\nuniform float zNear;\nuniform float zFar;\nuniform int useReflection;\nuniform float reflectivity;\n\nuniform samplerCube env0;\n\nin vec3 fragNormal;\nin vec4 fragPosition;\nin vec2 fragTexcoord2d0;\nin vec3 worldNormal;\nout vec4 fragColor;\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p,s;\n\tp.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\ts = vec4(lessThan(p, vec4(0.0)));\n\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\treturn p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t\t-0.447213595499958); // -1 + 4 * G4\n\n\t// First corner\n\tvec4 i = floor(v + dot(v, vec4(F4)) );\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n\t// Other corners\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t// i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\t// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\t// x0 = x0 - 0.0 + 0.0 * C.xxxx\n\t// x1 = x0 - i1 + 1.0 * C.xxxx\n\t// x2 = x0 - i2 + 2.0 * C.xxxx\n\t// x3 = x0 - i3 + 3.0 * C.xxxx\n\t// x4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\t// Permutations\n\ti = mod289(i);\n\tfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n\tvec4 j1 = permute( permute( permute( permute (\n\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n\t// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt(dot(p4,p4));\n\n\t// Mix contributions from the five corners\n\tvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\tvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\treturn 49.0 *\n\t\t( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n\t\t+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat oit_weight(float z, vec4 color) {\n\treturn max(min(1.0, max(max(color.r, color.g), color.b) * color.a), color.a) * clamp(0.03 / (1e-5 + pow(z / 200.0, 4.0)), 1e-2, 3e3);\n}\n\nvec3 reflection() {\n\tvec3 eyeDirection = normalize(-fragPosition.xyz);\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\n\tvec4 color = texture(env0, lookup);\n\treturn color.rgb;\n}\n\nvec4 lighting() {\n\t/* TODO: proper lighting for transparent surfaces */\n\tvec4 textureColor = texture(diffuse0, fragTexcoord2d0);\n\tvec4 color = diffuse * textureColor;\n\treturn color;\n}\n\nvoid main(void) {\n\tvec4 color = lighting();\n\n\tif (useReflection == 1) {\n\t\tvec3 refl = reflection();\n\t\tcolor.rgb = mix(refl, color.rgb, clamp(1.0 - reflectivity, 0.0, 1.0));\n\t}\n\n\t// Weighted Blended Order-Independent Transparency color pass\n\tif (render_mode == 0) {\n\t\tfloat linDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * -fragPosition.z - 1.0) * (zFar - zNear));\n\t\tfloat weight = oit_weight(linDepth, color);\n\t\tfragColor = vec4(color.rgb * color.a, color.a) * weight;\n\t}\n\n\t// Alpha reveal amount pass\n\telse if (render_mode == 1) {\n\t\tfragColor = vec4(color.a); // total amount revealed (blending: 0; 1-src.a)\n\t}\n\n\t// Alpha mapping pass\n\telse if (render_mode == 2) {\n\t\tif (color.a < 0.99)\n\t\t\tdiscard;\n\t\tfragColor = color;\n\t}\n\n\t// Stochastic transparency pass\n\telse if (render_mode == 3) {\n\t\tfloat random = snoise(fragPosition*150.0);\n\t\tif (random > color.a)\n\t\t\tdiscard;\n\t\tfragColor = vec4(color.rgb * color.a, 1.0);\n\t}\n}\n",
		"shaders/webgl2/OITAccum.vert": "#version 300 es\n\n/** Order independent transparency - vertex program */\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec3 fragNormal;\nout vec4 fragPosition;\nout vec2 fragTexcoord2d0;\nout vec3 worldNormal;\n\nvoid main() {\n\tfragNormal = mat3(modelview) * normal;\n\tfragPosition = modelview * vec4(position, 1.0);\n\tfragTexcoord2d0 = texcoord2d0;\n\tworldNormal = normalize(mat3(model) * normal);\n\tgl_Position = projection * fragPosition;\n}\n",
		"shaders/webgl2/OITRender.frag": "#version 300 es\n\n/**\n * Weighted Blended Order-Independent Transparency - Compositing program\n * Based on http://jcgt.org/published/0002/02/09/\n */\n\nprecision highp float;\n\nin vec2 uv;\n\nuniform vec2 ViewportSize;\nuniform int render_mode;\n\nuniform sampler2D src;\nuniform sampler2D oitAccum;\nuniform sampler2D oitWeight;\n\nout vec4 fragColor;\n\n\nvoid addRelevantSample(vec2 coords, float weight, inout vec4 accum) {\n\tvec4 texel = texture(oitAccum, coords);\n\tif (texel.a < 1.0)\n\t\treturn;\n\tfloat a = texture(oitWeight, coords).a;\n\tif (a>0.99)\n\t\treturn;\n\taccum += texel * weight * a;\n}\n\nvec4 avgColor(sampler2D s, vec2 coords) {\n\tvec2 step = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\n\tvec2 kernel[8];\n\tkernel[0] = vec2(-step.x, step.y);\n\tkernel[1] = vec2(0.0, step.y);\n\tkernel[2] = vec2(step.x, step.y);\n\tkernel[3] = vec2(step.x, 0.0);\n\tkernel[4] = vec2(-step.x, 0.0);\n\tkernel[5] = vec2(-step.x, -step.y);\n\tkernel[6] = vec2(0.0, -step.y);\n\tkernel[7] = vec2(step.x, -step.y);\n\n\tvec4 sum = vec4(0.0);\n\tfloat weight = 1.0 / (2.0 + 1.0);\n\tfloat kernelSize = 1.0;\n\n\taddRelevantSample(coords, weight, sum);\n\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\tkernelSize = 2.0;\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\treturn sum;\n}\n\nvoid main(void) {\n\t// Blending: ONE_MINUS_SRC_ALPHA, SRC_ALPHA\n\n\tvec4 solidColor = texture(src, uv);\n\tfloat reveal = texture(oitWeight, uv).a;\n\tvec4 transparentColor;\n\n\t// Blended order transparency\n\tif (render_mode == 0) {\n\t\ttransparentColor = texture(oitAccum, uv);\n\n\t\tvec4 composite = vec4(transparentColor.rgb / max(transparentColor.a, 1e-5), reveal);\n\t\tfragColor = (1.0-composite.a) * composite +  composite.a * solidColor;\n\t}\n\n\t// Stochastic transparency\n\telse if (render_mode == 1) {\n\t\ttransparentColor = avgColor(oitAccum, uv);\n\t\tfragColor = (1.0 - reveal) * transparentColor + reveal * solidColor;\n\t}\n}\n",
		"shaders/webgl2/OITRender.vert": "#version 300 es\n\n/** Order independent transparency - vertex program */\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/ScreenQuad.frag": "// Shader for rendering a screen aligned quad for image space effects\n\nprecision highp float;\n\nvarying vec2 uv;\nuniform sampler2D tex0;\n\nvoid main () {\n\tgl_FragColor = texture2D(tex0, uv);\n}\n",
		"shaders/webgl2/ScreenQuad.vert": "// Shader for rendering a screen aligned quad for image space effects\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/attributes.frag": "#version 300 es\n\n// Attributes shader\nprecision mediump float;\n\nuniform float texCoord2d0Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d1Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d2Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d3Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float positionMultiplier;\t\t\t\t// Position output multiplier between 0 and 1\nuniform float tangentMultiplier;\t\t\t\t// Tangent output multiplier between 0 and 1\nuniform float bitangentMultiplier;\t\t\t// BiTangent output multiplier between 0 and 1\nuniform float normalMultiplier;\t\t\t\t\t// Normal output multiplier between 0 and 1\nuniform float barycentricMultiplier;\t\t// Barycentric output multiplier between 0 and 1\n\nin vec2 fragTexcoord2d0;\nin vec2 fragTexcoord2d1;\nin vec2 fragTexcoord2d2;\nin vec2 fragTexcoord2d3;\nin vec4 fragPosition;\nin vec4 fragTangent;\nin vec4 fragBitangent;\nin vec4 fragNormal;\nin vec3 fragBarycentric;\n\nout vec4 fragColor;\n\nvoid main(void) {\n\tfragColor =\n\t\tvec4(fragTexcoord2d0, 0.0, 1.0) * texCoord2d0Multiplier +\n\t\tvec4(fragTexcoord2d1, 0.0, 1.0) * texCoord2d1Multiplier +\n\t\tvec4(fragTexcoord2d2, 0.0, 1.0) * texCoord2d2Multiplier +\n\t\tvec4(fragTexcoord2d3, 0.0, 1.0) * texCoord2d3Multiplier +\n\t\tvec4(fragPosition.rgb, 1.0) * positionMultiplier +\n\t\tvec4(fragTangent.rgb, 1.0) * tangentMultiplier +\n\t\tvec4(fragBitangent.rgb, 1.0) * bitangentMultiplier +\n\t\tvec4(fragNormal.rgb, 1.0) * normalMultiplier +\n\t\tvec4(fragBarycentric, 1.0) * barycentricMultiplier;\n}\n",
		"shaders/webgl2/attributes.vert": "#version 300 es\n\n// Attributes shader\nin vec3 position;\nin vec3 tangent;\nin vec3 bitangent;\nin vec3 normal;\nin vec3 barycentric;\nin vec2 texcoord2d0;\nin vec2 texcoord2d1;\nin vec2 texcoord2d2;\nin vec2 texcoord2d3;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec2 fragTexcoord2d0;\nout vec2 fragTexcoord2d1;\nout vec2 fragTexcoord2d2;\nout vec2 fragTexcoord2d3;\nout vec4 fragPosition;\nout vec4 fragTangent;\nout vec4 fragBitangent;\nout vec4 fragNormal;\nout vec3 fragBarycentric;\n\nvoid main() {\n\tfragNormal = projection * modelview * vec4(normal, 1.0);\n\tfragPosition = projection * modelview * vec4(position, 1.0);\n\tfragTangent = projection * modelview * vec4(tangent, 1.0);\n\tfragBitangent = projection * modelview * vec4(bitangent, 1.0);\n\tfragTexcoord2d0 = texcoord2d0;\n\tfragTexcoord2d1 = texcoord2d1;\n\tfragTexcoord2d2 = texcoord2d2;\n\tfragTexcoord2d3 = texcoord2d3;\n\tfragBarycentric = barycentric;\n\tgl_Position = fragPosition;\n}\n",
		"shaders/webgl2/debug.frag": "#version 300 es\n\n// Fallback shader\nprecision mediump float;\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main(void) {\n\tfragColor = color;\n}\n",
		"shaders/webgl2/debug.vert": "#version 300 es\n\n// Debug shader\nin vec3 position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 fragPosition;\n\nvoid main() {\n\tfragPosition = projection * modelview * vec4(position, 1.0);\n\tgl_Position = fragPosition;\n}\n",
		"shaders/webgl2/deferred_background.frag": "#version 300 es\n\nprecision highp float;\n\nuniform vec4 color;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main () {\n\tfragColor = color;\n}\n",
		"shaders/webgl2/deferred_background.vert": "#version 300 es\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_gbuffer.frag": "#version 300 es\n\nprecision highp float;\n\nuniform mat4 view;\nuniform mat4 viewInverse;\n\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\nuniform float lightContribution;\nuniform float reflectivity;\nuniform int useNormalmap;\nuniform int useReflection;\nuniform int receiveShadows;\n\nuniform float materialBlend;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform samplerCube env0;\nuniform sampler2D mask;\n\nin float depth;\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\nin vec4 viewPosition;\nin vec3 viewNormal;\n\nin mat3 tbn;\n\nlayout(location = 0) out vec4 gbuf_color;\nlayout(location = 1) out vec4 gbuf_normal;\nlayout(location = 2) out vec4 gbuf_position;\nlayout(location = 3) out vec4 gbuf_params;\n\nvec3 reflection() {\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\n\tvec4 color = texture(env0, lookup);\n\treturn color.rgb;\n}\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv0);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tvec3 N = viewNormal;\n\tif (useNormalmap == 1) {\n\t\tvec4 encodedNormal = texture(normal0, uv0);\n\t\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\t\tN = normalize(tbn * localCoords);\n\t\tN = normalize(mat3(view) * N);\n\t}\n\n\tif (useReflection == 1) {\n\t\tvec3 refl = reflection();\n\t\tfloat maskValue = texture(mask, uv0).r;\n\t\tcolor.rgb = mix(refl, color.rgb, maskValue * materialBlend);\n\t}\n\n\tgbuf_color = vec4(color.rgb, specularStrength);\n\tgbuf_normal = vec4(N, depth);\n\tgbuf_position = vec4(worldPosition.xyz, float(specularPower)/255.0);\n\tgbuf_params = vec4(lightContribution, receiveShadows, reflectivity, 1.0);\n}\n",
		"shaders/webgl2/deferred_gbuffer.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\nin vec3 tangent;\nin vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nout float depth;\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\nout vec4 viewPosition;\nout vec3 viewNormal;\n\nout mat3 tbn;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/deferred_light_ambient.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec4 lightColor;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main () {\n\tvec4 data0 = texture(gb0, uv);\n\tvec3 color = data0.rgb * lightColor.rgb;\n\tfragColor = vec4(color, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_ambient.vert": "#version 300 es\n\nin vec3 position;\nin vec2 texcoord2d0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_directional.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec3 cameraPosition;\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nuniform mat4 view;\nuniform mat4 lightView;\nuniform mat4 lightProjection;\nuniform float shadowBias;\n\nuniform int useShadows;\nuniform int useSoftShadows;\nuniform int shadowOnly;\n\nin vec2 uv;\nout vec4 fragColor;\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap(vec4 worldPosition) {\n\tvec4 shadowPosition = lightProjection * lightView * worldPosition;\n\tvec2 shadowUV = shadowPosition.xy / shadowPosition.w;\n\tshadowUV = shadowUV * 0.5 + 0.5;\n\tvec4 shadowTexel = texture(shadow0, shadowUV);\n\n\treturn VSM(shadowTexel.xy, shadowPosition.z);\n\t// return step(shadowPosition.z - shadowBias, shadowTexel.r);\n}\n\nvoid main () {\n\tvec4 data2 = texture(gb2, uv); // position, specularPower/255\n\tvec4 data3 = texture(gb3, uv); // material parameters: (lightContribution, receiveShadows, reflectivity, unused)\n\tvec4 P = vec4(data2.xyz, 1.0);\n\n\tfloat shadow = 1.0;\n\n\tif (useShadows == 1 && data3.g > 0.0) {\n\t\tif (useSoftShadows == 1)\n\t\t\tshadow = texture(shadow0, uv).r;\n\t\telse\n\t\t\tshadow = shadowmap(P);\n\t}\n\n\tif (shadowOnly == 1) {\n\t\tfragColor = vec4(shadow, shadow, shadow, 1.0);\n\t\treturn;\n\t}\n\n\tvec4 data0 = texture(gb0, uv); // color, specularIntensity\n\n\tvec4 data1 = texture(gb1, uv); // normal, depth\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec4 viewPosition = view * P;\n\tvec3 L = normalize(mat3(view) * lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 lighting = diffuseColor + specularColor;\n\n\tvec3 final = shadow * mix(C, lighting, data3.r);\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_directional.vert": "#version 300 es\n\nin vec3 position;\nin vec2 texcoord2d0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_omni.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\n\nuniform vec4 lightColor;\nuniform vec3 lightPosition;\nuniform float lightIntensity;\nuniform float lightRadius;\n\nuniform mat4 view;\nuniform vec3 cameraPosition;\n\nin vec4 screenPosition;\nout vec4 fragColor;\n\nvoid main() {\n\tvec2 uv = screenPosition.xy;\n\tuv /= screenPosition.w;\n\tuv = 0.5 * (vec2(uv.x, uv.y) + 1.0);\n\n\tvec4 data0 = texture(gb0, uv); // color.rgb, specularIntensity\n\tvec4 data1 = texture(gb1, uv); // normal.xyz, depth\n\tvec4 data2 = texture(gb2, uv); // position.xyz, specularPower/255\n\t// vec4 data3 = texture(gb3, uv); // unused\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tvec3 P = data2.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec3 lightVector = lightPosition - P;\n\tfloat attenuation = clamp(1.0 - length(lightVector)/lightRadius, 0.0, 1.0);\n\tlightVector = normalize(lightVector);\n\n\tvec4 viewPosition = view * vec4(P, 1.0);\n\tvec3 L = normalize(mat3(view) * lightVector);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 final = attenuation * (diffuseColor + specularColor);\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_omni.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 screenPosition;\n\nvoid main() {\n\tscreenPosition = projection * view * model * vec4(position, 1.0);\n\tgl_Position = screenPosition;\n}\n",
		"shaders/webgl2/deferred_shadow_directional.frag": "#version 300 es\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat dx = dFdx(depth);\n\tfloat dy = dFdy(depth);\n\tfragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_shadow_directional.vert": "#version 300 es\n/** Directional light shadow-map */\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/webgl2/depth.frag": "#version 300 es\n\n// Shader for rendering linear depth values into a floating point texture\nprecision mediump float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfragColor = vec4(depth, depth, depth, depth);\n}\n",
		"shaders/webgl2/depth.vert": "#version 300 es\n\n// Shader for rendering linear depth values into a floating point texture\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\tuv = texcoord2d0;\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/diffuse.frag": "#version 300 es\n\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\nout vec4 fragColor;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 textureColor = texture(diffuse0, uv0);\n\tvec3 N = normalize(viewNormal);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tfragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/webgl2/diffuse.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\n\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\nout vec4 viewPosition;\nout vec3 viewNormal;\nout vec4 shadowPosition;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/fallback.frag": "// Fallback shader\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
		"shaders/webgl2/fallback.vert": "// Fallback shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n  fragNormal=modelview*vec4(normal, 1.0);\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n  fragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/webgl2/font.frag": "// Diffuse shader\nprecision mediump float; \n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform int page;\t\t\t\t\t\t// The font page texture\n\nuniform sampler2D page0;\t\t\nuniform sampler2D page1;\nuniform sampler2D page2;\nuniform sampler2D page3;\nuniform sampler2D page4;\nuniform sampler2D page5;\nuniform sampler2D page6;\nuniform sampler2D page7;\n\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tvec4 c;\n\tif(page==0) c = texture2D(page0, fragTexcoord2d0);\n\tif(page==1) c = texture2D(page1, fragTexcoord2d0);\n\tif(page==2) c = texture2D(page2, fragTexcoord2d0);\n\tif(page==3) c = texture2D(page3, fragTexcoord2d0);\n\tif(page==4) c = texture2D(page4, fragTexcoord2d0);\n\tif(page==5) c = texture2D(page5, fragTexcoord2d0);\n\tif(page==6) c = texture2D(page6, fragTexcoord2d0);\n\tif(page==7) c = texture2D(page7, fragTexcoord2d0);\n\tgl_FragColor=vec4(diffuse.r*c.r, diffuse.g*c.g, diffuse.b*c.b, c.a);\n}",
		"shaders/webgl2/font.vert": "// Font shader\nattribute vec3 position; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/webgl2/forward_shadow.frag": "#version 300 es\n\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform int hasFloat;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\n\tif (hasFloat == 1) {\n\t\tfragColor = vec4(d, d, d, 1.0);\n\t}\n\telse {\n\t\tfragColor = pack(d);\n\t}\n\n}\n",
		"shaders/webgl2/forward_shadow.vert": "#version 300 es\n\n/** Directional light shadow-map */\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/webgl2/forward_shadow_vsm.frag": "#version 300 es\n\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\tfloat dx = dFdx(d);\n\tfloat dy = dFdy(d);\n\n\tfragColor = vec4(d, pow(d, 2.0) + 0.25*(dx * dx + dy * dy), 0.0, 1.0);\n}\n",
		"shaders/webgl2/normalmapped.frag": "// Normal mapped diffuse shader\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 encodedNormal = texture2D(normal0, uv0);\n\t// vec3 localCoords = 2.0 * encodedNormal.rgb - vec3(1.0);\n\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\tvec3 normalDirection = normalize(tbn * localCoords);\n\tvec3 N = normalize(mat3(view) * normalDirection);\n\n\tvec4 textureColor = texture2D(diffuse0, uv0);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture2D(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tgl_FragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/webgl2/normalmapped.vert": "// Normal mapped diffuse shader\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\nattribute vec3 tangent;\nattribute vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\nuniform vec3 lightDirection;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nhighp mat3 transpose(in highp mat3 m) {\n\thighp vec3 i0 = m[0];\n\thighp vec3 i1 = m[1];\n\thighp vec3 i2 = m[2];\n\thighp mat3 outMatrix = mat3(\n\t\tvec3(i0.x, i1.x, i2.x),\n\t\tvec3(i0.y, i1.y, i2.y),\n\t\tvec3(i0.z, i1.z, i2.z)\n\t);\n\treturn outMatrix;\n}\n\nvoid main() {\n\tuv0 = texcoord2d0; // TODO: In the future this will probably need to use texture offset and scale uniforms\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = normalize(mat3(modelview) * normal);\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/positionbuffer.frag": "//Normal buffer\nprecision highp float;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform mat4 modelview;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n\tfloat linDepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\tgl_FragColor = pack(linDepth);\n}\n",
		"shaders/webgl2/positionbuffer.vert": "//Normal buffer\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvoid main() {\n    worldPosition = model * vec4(position, 1.0);\n    viewPosition = view * worldPosition;\n    worldNormal = normalize(mat3(model)*normal);\n    viewNormal = mat3(modelview) * normal;\n    \n    gl_Position = projection * viewPosition;\n}",
		"shaders/webgl2/postprocess_blur.frag": "#version 300 es\n\n/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nin highp vec2 blurCoords[5];\nout vec4 fragColor;\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture(src, blurCoords[0]) * 0.204164;\n\tsum += texture(src, blurCoords[1]) * 0.304005;\n\tsum += texture(src, blurCoords[2]) * 0.304005;\n\tsum += texture(src, blurCoords[3]) * 0.093913;\n\tsum += texture(src, blurCoords[4]) * 0.093913;\n\tfragColor = sum;\n}\n",
		"shaders/webgl2/postprocess_blur.vert": "#version 300 es\n\n/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nin vec3 position;\nin vec2 uv0;\n\nuniform vec2 ViewportSize;\nuniform vec2 BlurSize;\n\nout vec2 blurCoords[5];\n\nvoid main() {\n\tvec2 offset = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y) * BlurSize;\n\n\tblurCoords[0] = uv0;\n\tblurCoords[1] = uv0 + offset * 1.407333;\n\tblurCoords[2] = uv0 - offset * 1.407333;\n\tblurCoords[3] = uv0 + offset * 3.294215;\n\tblurCoords[4] = uv0 - offset * 3.294215;\n\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/postprocess_fxaa.frag": "#version 300 es\n\n/**\n * FXAA post-process\n *\n * Based on webgl-meincraft FXAA implementation.\n * https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n */\n\n/*\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Basic FXAA implementation based on the code on geeks3d.com with the\n * modification that the texture2DLod stuff was removed since it's\n * unsupported by WebGL.\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nuniform vec2 ViewportSize;\nuniform float reduce_min;\nuniform float reduce_mul;\nuniform float span_max;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvec4 fxaa(sampler2D tex, vec2 texCoord) {\n\tvec4 color;\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec3 rgbNW = texture(tex, texCoord + vec2(-1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbNE = texture(tex, texCoord + vec2(1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbSW = texture(tex, texCoord + vec2(-1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbSE = texture(tex, texCoord + vec2(1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbM = texture(tex, texCoord).xyz;\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM = dot(rgbM, luma);\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * reduce_mul), reduce_min);\n\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(span_max, span_max), max(vec2(-span_max, -span_max), dir * rcpDirMin)) * inverseVP;\n\n\tvec3 rgbA = 0.5 * (\n\t\ttexture(tex, texCoord + dir * (1.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(tex, texCoord + dir * (2.0 / 3.0 - 0.5)).xyz);\n\tvec3 rgbB = rgbA * 0.5 + 0.25 * (\n\t\ttexture(tex, texCoord + dir * -0.5).xyz +\n\t\ttexture(tex, texCoord + dir * 0.5).xyz);\n\n\tfloat lumaB = dot(rgbB, luma);\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\t\tcolor = vec4(rgbA, 1.0);\n\telse\n\t\tcolor = vec4(rgbB, 1.0);\n\treturn color;\n}\n\nvoid main () {\n\tfragColor = fxaa(src, uv);\n}\n",
		"shaders/webgl2/postprocess_fxaa.vert": "#version 300 es\n\n/** FXAA post-process effect vertex shader */\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/postprocess_ssao.frag": "#version 300 es\n\n/*\n * Screen space ambient occlusion post process\n *\n * SSAO GLSL shader v1.2\n * assembled by Martins Upitis (martinsh) (devlog-martinsh.blogspot.com)\n * original technique is made by Arkano22 (www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n *\n * Changelog:\n * 1.2 - added fog calculation to mask AO. Minor fixes.\n * 1.1 - added spiral sampling method from here:\n * (http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere)\n */\n\nprecision highp float;\n\n#define PI 3.14159265\n\nuniform sampler2D depth0;\nuniform sampler2D oitWeight;\nuniform sampler2D src;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoOnly;\nuniform float gdisplace; // Gauss bell center, default: 0.3\nuniform float radius; // AO radius, default: 2.0\nuniform float brightness; // AO brightness, default: 1.0\nuniform float luminanceInfluence; // how much luminance affects occlusion, default: 0.7\n\nout vec4 fragColor;\n\nconst int samples = 16;\n// const int samples = 8;\n\nfloat aoclamp = 0.25; // depth clamp - reduces haloing at screen edges\nbool noise = true; // use noise instead of pattern for sample dithering\nfloat noiseamount = 0.0002; // dithering amount\nfloat diffarea = 0.4; // self-shadowing reduction\n\nvec2 rand(vec2 coord) {\n\tfloat noiseX = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.25)+(fract(coord.t*(ViewportSize.y/2.0))*0.75))*2.0-1.0;\n\tfloat noiseY = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.75)+(fract(coord.t*(ViewportSize.y/2.0))*0.25))*2.0-1.0;\n\tif (noise) {\n\t\tnoiseX = clamp(fract(sin(dot(coord, vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t\tnoiseY = clamp(fract(sin(dot(coord, vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t}\n\treturn vec2(noiseX, noiseY) * noiseamount;\n}\n\nfloat readDepth(in vec2 coord) {\n\treturn texture(depth0, coord).r;\n}\n\nfloat compareDepths(in float depth1, in float depth2, inout int far) {\n\tfloat garea = 2.0; // gauss bell width\n\tfloat diff = (depth1 - depth2)*100.0; // depth difference (0-100)\n\t// reduce left bell width to avoid self-shadowing\n\tif (diff<gdisplace) {\n\t\tgarea = diffarea;\n\t}\n\telse {\n\t\tfar = 1;\n\t}\n\n\tfloat gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));\n\treturn gauss;\n}\n\nfloat calAO(vec2 uv, float depth, float dw, float dh) {\n\tfloat dd = (1.0-depth) * radius;\n\n\tfloat temp = 0.0;\n\tfloat temp2 = 0.0;\n\tfloat coordw = uv.x + dw*dd;\n\tfloat coordh = uv.y + dh*dd;\n\tfloat coordw2 = uv.x - dw*dd;\n\tfloat coordh2 = uv.y - dh*dd;\n\n\tvec2 coord = vec2(coordw , coordh);\n\tvec2 coord2 = vec2(coordw2, coordh2);\n\n\tint far = 0;\n\ttemp = compareDepths(depth, readDepth(coord), far);\n\t//DEPTH EXTRAPOLATION:\n\tif (far > 0) {\n\t\ttemp2 = compareDepths(readDepth(coord2), depth, far);\n\t\ttemp += (1.0-temp)*temp2;\n\t}\n\n\treturn temp;\n}\n\nvoid main() {\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec2 texCoord = gl_FragCoord.xy * inverseVP;\n\n\tvec2 noise = rand(texCoord);\n\tfloat depth = readDepth(texCoord);\n\tfloat reveal = texture(oitWeight, texCoord).a;\n\n\tfloat w = inverseVP.x/clamp(depth, aoclamp,1.0)+(noise.x*(1.0-noise.x));\n\tfloat h = inverseVP.y/clamp(depth, aoclamp,1.0)+(noise.y*(1.0-noise.y));\n\n\tfloat pw;\n\tfloat ph;\n\n\tfloat ao;\n\n\tfloat dl = PI*(3.0-sqrt(5.0));\n\tfloat dz = 1.0/float(samples);\n\tfloat l = 0.0;\n\tfloat z = 1.0 - dz/2.0;\n\n\tfor (int i = 0; i <= samples; i++) {\n\t\tfloat r = sqrt(1.0-z);\n\t\tpw = cos(l)*r;\n\t\tph = sin(l)*r;\n\t\tao += calAO(texCoord, depth, pw*w, ph*h);\n\t\tz = z - dz;\n\t\tl = l + dl;\n\t}\n\n\tao /= float(samples) * brightness;\n\tao = 1.0 - ao * reveal;\n\n\tvec3 color = texture(src, texCoord).rgb;\n\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\tfloat lum = dot(color.rgb, lumcoeff);\n\tvec3 luminance = vec3(lum, lum, lum);\n\tvec3 final = vec3(color*mix(vec3(ao),vec3(1.0), luminance * luminanceInfluence));\n\n\tif (ssaoOnly == 1) {\n\t\tfinal = vec3(mix(vec3(ao),vec3(1.0),luminance * luminanceInfluence));\n\t}\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/postprocess_ssao.vert": "#version 300 es\n\n/*\n * Screen space ambient occlusion post process\n */\nin vec3 position;\n\nvoid main() {\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/reflective.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/webgl2/reflective.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/reflective_masked.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\nuniform sampler2D mask;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tfloat maskValue = texture2D(mask, uv0).r;\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), maskValue * materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, maskValue * materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/webgl2/reflective_masked.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/shadow_blur.frag": "/**\n * Shadow blur\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying highp vec2 blurCoords[14];\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture2D(src, blurCoords[ 0])*0.0044299121055113265;\n\tsum += texture2D(src, blurCoords[ 1])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[ 2])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[ 3])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[ 4])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[ 5])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 6])*0.147308056121;\n\tsum += texture2D(src, uv            )*0.159576912161;\n\tsum += texture2D(src, blurCoords[ 7])*0.147308056121;\n\tsum += texture2D(src, blurCoords[ 8])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 9])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[10])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[11])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[12])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[13])*0.0044299121055113265;\n\tgl_FragColor = sum;\n}\n",
		"shaders/webgl2/shadow_blurh.vert": "/**\n * Shadow blur - horizontal\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(-0.028, 0.0) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(-0.024, 0.0) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(-0.020, 0.0) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(-0.016, 0.0) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(-0.012, 0.0) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(-0.008, 0.0) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(-0.004, 0.0) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2( 0.004, 0.0) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2( 0.008, 0.0) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2( 0.012, 0.0) * blurSize;\n\tblurCoords[10] = uv0 + vec2( 0.016, 0.0) * blurSize;\n\tblurCoords[11] = uv0 + vec2( 0.020, 0.0) * blurSize;\n\tblurCoords[12] = uv0 + vec2( 0.024, 0.0) * blurSize;\n\tblurCoords[13] = uv0 + vec2( 0.028, 0.0) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/shadow_blurv.vert": "/**\n * Shadow blur - vertical\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(0.0, -0.028) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(0.0, -0.024) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(0.0, -0.020) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(0.0, -0.016) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(0.0, -0.012) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(0.0, -0.008) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(0.0, -0.004) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2(0.0,  0.004) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2(0.0,  0.008) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2(0.0,  0.012) * blurSize;\n\tblurCoords[10] = uv0 + vec2(0.0,  0.016) * blurSize;\n\tblurCoords[11] = uv0 + vec2(0.0,  0.020) * blurSize;\n\tblurCoords[12] = uv0 + vec2(0.0,  0.024) * blurSize;\n\tblurCoords[13] = uv0 + vec2(0.0,  0.028) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/ssao.frag": "precision highp float;\n\nuniform sampler2D position0;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform float ssaoGDisplace;\nuniform float ssaoRadius;\nuniform float ssaoDivider;\n\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\n\nfloat unpack(vec4 c) {\n    const vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n    return dot(c, bitShifts);\n}\n\nfloat getDepth(vec2 coord) {\n    float d = unpack(texture2D(position0, coord.xy));\n    if (d == 0.0)\n        d = 1.0;\n    return d;\n}\n\nfloat doAmbientOcclusion(vec2 coord, vec2 coord2, float d) {\n    float diff = getDepth(coord + coord2) - d;\n    float gDisplace = -0.0002 - (0.00002 * max(min(ssaoGDisplace, 10.0), 0.0));\n    //float gDisplace = -0.00032;\n    return (diff < gDisplace) ? pow(EULER, -2.0 * (diff - gDisplace) * (diff - gDisplace) * 10000.0 / 0.16) : 0.0;\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    vec2 c = gl_FragCoord.xy * inverseVP;\n    \n    float ao = 0.0;\n\n    float dz = 1.0 / 8.0;\n    float z = 1.0 - dz / 2.0;\n    float l = 0.0;\n\n    float depth = getDepth(c);\n\n    for (int i = 0; i <= 8; i++) {\n        float r = sqrt(1.0 - z);\n\n        vec2 p = vec2(cos(l) * r, sin(l) * r);\n        ao += doAmbientOcclusion(c, p * ssaoRadius * inverseVP.x * (1.0 - depth), depth);\n        z = z - dz;\n        l = l + DL;\n    }\n\n    ao /= 8.0 + max(min(ssaoDivider, 1.0), -1.0);\n    //ao /= 8.5;\n    \n    ao = max(0.0, ao * 2.0 - 1.0);\n    ao = 1.0 - ao;\n    gl_FragColor = vec4(ao, ao, ao, 1.0);\n    //gl_FragColor = vec4(depth, depth, depth, 1.0);\n    //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}",
		"shaders/webgl2/ssao.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/webgl2/ssaoblur.frag": "precision highp float;\n\nuniform sampler2D ao0;\nuniform sampler2D src;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoBlurSize;\nuniform int ssaoOnly;\n\nfloat random(vec2 co) {\n    //co = mod(co, 128.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    const int MAXIMUM_BLUR = 32;\n    float result = 0.0;\n    vec2 hlim = vec2(float(-ssaoBlurSize) * 0.5 + 0.5);\n    for (int i = 0; i < MAXIMUM_BLUR; i++) {\n        if (i >= ssaoBlurSize)\n            break;\n        for (int j = 0; j < MAXIMUM_BLUR; j++) {\n            if (j >= ssaoBlurSize)\n                break;\n            vec2 offset = (hlim + vec2(float(i), float(j))) * inverseVP;\n            result += texture2D(ao0, gl_FragCoord.xy * inverseVP + offset).r;\n        }\n    }\n    result = result / float(ssaoBlurSize * ssaoBlurSize);\n\n    if (ssaoOnly == 1) {\n        gl_FragColor = vec4(vec3(result), 1.0);\n    }\n    else {\n        gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * result, 1.0);\n    }\n    //gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * texture2D(ao0, gl_FragCoord.xy * inverseVP/* / 2.0 + 0.5*/).xyz, 1.0);\n}",
		"shaders/webgl2/ssaoblur.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/webgl2/terrain.frag": "// Terrain shader for the forward renderer\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\r\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\tvec4 color = lighting(shadow);\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n\r\n\t// gl_FragColor = vec4(bc, 1.0); // for debug\r\n}\r\n",
		"shaders/webgl2/terrain.vert": "// Terrain shader for the forward renderer\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\nattribute vec3 barycentric;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nuniform sampler2D height;\r\n\r\nuniform float verticalScale;\r\nuniform vec2 uvOffset;\r\nuniform vec2 uvScale;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat snap(float f, float step) {\r\n\treturn step * floor(f / step);\r\n}\r\n\r\nvoid main() {\r\n\tbc = barycentric;\r\n\tuv0 = texcoord2d0 * uvScale + uvOffset;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\r\n\t// worldPosition.x = snap(worldPosition.x, worldPosition.y);\r\n\t// worldPosition.z = snap(worldPosition.z, worldPosition.y);\r\n\r\n\tfloat height = texture2D(height, uv0).r;\r\n\tworldPosition.y = height * verticalScale;\r\n\t// worldPosition.y = 0.0;\r\n\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/test.frag": "// Test fragment shader drawing in blue \n\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(0.1, 0.5, 0.8, 1.0); \n}",
		"shaders/webgl2/test.vert": "// Test pass-through shader that doesn't transform vertex\nattribute vec3 position; \nattribute vec3 normal; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\n\nvoid main(void) { \n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=projection*modelview*vec4(position, 1.0);\n\tgl_Position = fragPosition; \n}\n",
		"shaders/webgl2/transparent.frag": "// Unlit transparency shader\nprecision mediump float; \n\nuniform vec4 diffuse;\n\nuniform sampler2D diffuse0;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tgl_FragColor = diffuse*texture2D(diffuse0, fragTexcoord2d0);\n}",
		"shaders/webgl2/transparent.vert": "// Unlit transparency shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=modelview*vec4(position, 1.0);\n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=projection*fragPosition;\n}\n",
		"shaders/webgl2/wireframe.frag": "// Test fragment shader drawing in blue \nprecision mediump float; \n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, \n\t\t\tpow(1.0-fragBarycentric.r, 32.0)+pow(1.0-fragBarycentric.g, 32.0)+pow(1.0-fragBarycentric.b, 32.0));\n}",
		"shaders/webgl2/wireframe.vert": "// Diffuse shader\nattribute vec3 position; \nattribute vec3 barycentric; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\tgl_Position=projection*modelview*vec4(position, 1.0); \n\tfragBarycentric = barycentric;\n}"
	}
};