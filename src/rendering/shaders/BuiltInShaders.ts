// Generated at 2023-10-17T13:11:25.943Z
var BuiltInShaders = {
	"webgl2": {
		"shaders/direct_directional.frag": "#version 300 es\n\nprecision highp float;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\nlayout(location = 0) out vec4 fragColor;\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n    float clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n    return clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n    return x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n    float oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n    float a = NdotH * roughness;\n    float k = roughness / (oneMinusNdotHSq + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n    float a2 = roughness * roughness;\n    float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    float v = 0.5 / (lambdaV + lambdaL);\n    return v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n    // not using mix to keep the vec3 and float versions identical\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n    float f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n    return F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n              float NoH, float LoH, float specularIntensity) {\n    float D = D_GGX(roughness, NoH);\n    float V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n    vec3 F = fresnel(f0, LoH);\n\n    return (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n    //return specular;\n}\n\nvec3 acesApprox(vec3 v) {\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid main(void) {\n    vec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n    float metallic = metallic * metallicRoughness.b;\n    float perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n    vec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n    vec3 B = cross(N, T) * worldTangent.w;\n\n    mat3 TBN = mat3(T, -B, N);\n    N = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n\tvec3 V = normalize(cameraPosition - worldPosition.xyz);\n    float NdotV = max(dot(N, V), 1e-4);\n\n    vec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n    vec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n    vec3 R = reflect(-V, N);\n\n    outputColor.rgb = dirLight(normalize(lightDirection), lightColor * lightIntensity * 10.4, roughness, NdotV, N, V, R, F0, diffuseColor);\n    outputColor.rgb = acesApprox(outputColor.rgb);\n\n\tfragColor = outputColor;\n}\n",
		"shaders/direct_ibl.frag": "#version 300 es\n\nprecision highp float;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\nuniform vec4 emissive;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\n#ifdef EMISSIVE_TEXTURE\nuniform sampler2D emissive0;\n\n#ifdef EMISSIVE_UV_TRANSFORM\nuniform mat3 emissiveUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\nlayout(location = 0) out vec4 fragColor;\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n    float clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n    return clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 emissiveUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef EMISSIVE_UV_TRANSFORM\n\tuv = emissiveUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n    vec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n    float metallic = metallic * metallicRoughness.b;\n    float perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n    vec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n    vec3 B = cross(N, T) * worldTangent.w;\n\n    mat3 TBN = mat3(T, -B, N);\n    N = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n#ifdef EMISSIVE_TEXTURE\n\tvec4 emissive = emissive;\n    emissive.rgb *= texture(emissive0, emissiveUV()).rgb;\n#endif\n\n\tfragColor = outputColor;\n}\n",
		"shaders/pbr.frag": "#version 300 es\n\nprecision highp float;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\nuniform vec4 emissive;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\n#ifdef EMISSIVE_TEXTURE\nuniform sampler2D emissive0;\n\n#ifdef EMISSIVE_UV_TRANSFORM\nuniform mat3 emissiveUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\n// TODO: Optionally limit number of buffers\nlayout(location = 0) out vec4 fragColor;\nlayout(location = 1) out vec4 fragNormalMetallic;\nlayout(location = 2) out vec4 fragPositionRoughness;\nlayout(location = 3) out vec4 fragEmissiveOcclusion;\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n\tfloat clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n\treturn clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 emissiveUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef EMISSIVE_UV_TRANSFORM\n\tuv = emissiveUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n\tvec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#if ALPHAMODE == ALPHAMODE_OPAQUE\n\toutputColor.a = 1.0;\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n\tfloat metallic = metallic * metallicRoughness.b;\n\tfloat perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n\tvec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n\tvec3 B = cross(N, T) * worldTangent.w;\n\n\tmat3 TBN = mat3(T, -B, N);\n\tN = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n#ifdef EMISSIVE_TEXTURE\n\tvec4 emissive = emissive;\n\temissive.rgb *= texture(emissive0, emissiveUV()).rgb;\n#endif\n\n\tfragColor = outputColor;\n\tfragNormalMetallic = vec4(N, metallic);\n\tfragPositionRoughness = vec4(worldPosition.xyz, roughness);\n\tfragEmissiveOcclusion = vec4(emissive.rgb, occlusion);\n\n#if ALPHAMODE == ALPHAMODE_MASK\n    if (outputColor.a < alphaCutoff) {\n        discard;\n    }\n    outputColor.a = 1.0;\n#endif\n}\n",
		"shaders/pbr.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n#ifdef VERTEX_TANGENTS\nin vec4 tangent4d;\n#endif\n\nuniform mat4 model;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\n#ifdef VERTEX_TANGENTS\nout vec4 worldTangent;\n#endif\nout vec4 viewPosition;\nout vec3 viewNormal;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n#ifdef VERTEX_TANGENTS\n\tworldTangent = vec4(normalize(mat3(model) * tangent4d.xyz), tangent4d.w);\n#endif\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/pbr_ambient.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D color;\nuniform sampler2D normalMetallic;\nuniform sampler2D positionRoughness;\nuniform sampler2D emissiveOcclusion;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform vec4 lightColor;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float REFLECTANCE = 0.5;\n\nconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\nvec3 EnvBRDFApprox(vec3 f0, float perceptualRoughness, float NoV) {\n    vec4 r = perceptualRoughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * AB.x + AB.y;\n}\n\nvoid main(void) {\n    vec4 outputColor = texture(color, uv);\n\n    vec4 nM = texture(normalMetallic, uv);\n    vec3 N = nM.xyz;\n    float metallic = nM.w;\n\n    vec4 pR = texture(positionRoughness, uv);\n    vec3 position = pR.xyz;\n    float roughness = pR.w;\n\n    vec4 eO = texture(emissiveOcclusion, uv);\n    float occlusion = eO.w;\n\n    vec3 V = normalize(cameraPosition - position);\n    float NdotV = max(dot(N, V), 1e-4);\n\n    vec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n    vec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n    vec3 diffuseAmbient = EnvBRDFApprox(diffuseColor, 1.0, NdotV);\n    vec3 specularAmbient = EnvBRDFApprox(F0, roughness, NdotV);\n\n    outputColor.rgb = (diffuseAmbient + specularAmbient) * lightColor.rgb * occlusion;\n\n    fragColor = outputColor;\n}\n",
		"shaders/pbr_directional.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D color;\nuniform sampler2D normalMetallic;\nuniform sampler2D positionRoughness;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n\treturn x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n\tfloat oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n\tfloat a = NdotH * roughness;\n\tfloat k = roughness / (oneMinusNdotHSq + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n\tfloat a2 = roughness * roughness;\n\tfloat lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n\tfloat lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n\tfloat v = 0.5 / (lambdaV + lambdaL);\n\treturn v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n\t// not using mix to keep the vec3 and float versions identical\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n\tfloat f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n\treturn F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n\t\t\tfloat NoH, float LoH, float specularIntensity) {\n\tfloat D = D_GGX(roughness, NoH);\n\tfloat V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n\tvec3 F = fresnel(f0, LoH);\n\n\treturn (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n\tfloat f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n\tfloat lightScatter = F_Schlick(1.0, f90, NoL);\n\tfloat viewScatter = F_Schlick(1.0, f90, NoV);\n\treturn lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n\t//return specular;\n}\n\nvoid main(void) {\n\tvec4 outputColor = texture(color, uv);\n\n\tvec4 nM = texture(normalMetallic, uv);\n\tvec3 N = nM.xyz;\n\tfloat metallic = nM.w;\n\n\tvec4 pR = texture(positionRoughness, uv);\n\tvec3 position = pR.xyz;\n\tfloat roughness = pR.w;\n\n\tvec3 V = normalize(cameraPosition - position);\n\tfloat NdotV = max(dot(N, V), 1e-4);\n\n\tvec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n\tvec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n\tvec3 R = reflect(-V, N);\n\n\toutputColor.rgb = dirLight(normalize(lightDirection), lightColor * lightIntensity * 10.4, roughness, NdotV, N, V, R, F0, diffuseColor);\n\n\tfragColor = outputColor;\n}\n",
		"shaders/pbr_emissive.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D emissiveOcclusion;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main(void) {\n    vec4 eO = texture(emissiveOcclusion, uv);\n\n    fragColor = vec4(eO.rgb, 1.0);\n}\n",
		"shaders/pbr_ibl.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D color;\nuniform sampler2D normalMetallic;\nuniform sampler2D positionRoughness;\n\nuniform samplerCube light0;\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n\treturn x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n\tfloat oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n\tfloat a = NdotH * roughness;\n\tfloat k = roughness / (oneMinusNdotHSq + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n\tfloat a2 = roughness * roughness;\n\tfloat lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n\tfloat lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n\tfloat v = 0.5 / (lambdaV + lambdaL);\n\treturn v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n\t// not using mix to keep the vec3 and float versions identical\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n\tfloat f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n\treturn F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n\t\t\tfloat NoH, float LoH, float specularIntensity) {\n\tfloat D = D_GGX(roughness, NoH);\n\tfloat V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n\tvec3 F = fresnel(f0, LoH);\n\n\treturn (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n\tfloat f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n\tfloat lightScatter = F_Schlick(1.0, f90, NoL);\n\tfloat viewScatter = F_Schlick(1.0, f90, NoV);\n\treturn lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n\t//return specular;\n}\n\nfloat clampedDot(vec3 x, vec3 y) {\n    return clamp(dot(x, y), 0.0, 1.0);\n}\n\nvec3 getIBLRadianceGGX(vec3 n, vec3 v, float roughness, vec3 F0, float specularWeight) {\n    float NdotV = clampedDot(n, v);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    //vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec2 f_ab = brdfSamplePoint;\n    vec4 specularSample = texture(light0, -reflection);\n\n    vec3 specularLight = specularSample.rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = k_S * f_ab.x + f_ab.y;\n\n    return specularWeight * specularLight * FssEss;\n}\n\nvec3 getIBLRadianceLambertian(vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 F0, float specularWeight) {\n    float NdotV = clampedDot(n, v);\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    //vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec2 f_ab = brdfSamplePoint * 0.1;\n\n    vec3 irradiance = texture(light0, n).rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y; // <--- GGX / specular light contribution (scale it down if the specularWeight is low)\n\n    // Multiple scattering, from Fdez-Aguera\n    float Ems = (1.0 - (f_ab.x + f_ab.y));\n    vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n    vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n    vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms); // we use +FmsEms as indicated by the formula in the blog post (might be a typo in the implementation)\n\n    return (FmsEms + k_D) * irradiance;\n}\n\nvec3 ibLight(vec3 normal, vec3 view, float roughness, vec3 diffuseColor, vec3 F0, float specularWeight) {\n    vec3 diffuse = getIBLRadianceLambertian(normal, view, roughness, diffuseColor, F0, specularWeight);\n    vec3 specular = getIBLRadianceGGX(normal, view, roughness, F0, specularWeight);\n\n    return /**diffuse + */specular;\n}\n\nvoid main(void) {\n\tvec4 outputColor = texture(color, uv);\n\n\tvec4 nM = texture(normalMetallic, uv);\n\tvec3 N = nM.xyz;\n\tfloat metallic = nM.w;\n\n\tvec4 pR = texture(positionRoughness, uv);\n\tvec3 position = pR.xyz;\n\tfloat roughness = pR.w;\n\n\tvec3 V = normalize(cameraPosition - position);\n\tfloat NdotV = max(dot(N, V), 1e-4);\n\n\tvec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n\tvec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n\tvec3 R = reflect(-V, N);\n\n    outputColor.rgb = ibLight(N, V, roughness, diffuseColor, F0, 1.0);\n\n\tfragColor = outputColor;\n}\n",
		"shaders/quad.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D tex0;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = texture(tex0, uv);\n}\n",
		"shaders/skybox.frag": "#version 300 es\n\nprecision highp float;\n\nuniform samplerCube diffuse0;\n\nin vec3 uvw;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = texture(diffuse0, uvw);\n    //fragColor = vec4(uvw, 1.0);\n}\n",
		"shaders/tonemap.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D src;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nfloat luminance(vec3 v) {\n    return dot(v, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 changeLuminance(vec3 cIn, float lOut) {\n    float lIn = luminance(cIn);\n    return cIn * (lOut / lIn);\n}\n\nvec3 reinhardLuminance(vec3 color) {\n    float lOld = luminance(color);\n    float lNew = lOld / (1.0f + lOld);\n    return changeLuminance(color, lNew);\n}\n\nvec3 reinhardExtendedLuminance(vec3 color, float maxWhiteL) {\n    float lOld = luminance(color);\n    float numerator = lOld * (1.0f + (lOld / (maxWhiteL * maxWhiteL)));\n    float lNew = numerator / (1.0f + lOld);\n    return changeLuminance(color, lNew);\n}\n\nvec3 reinhardJodie(vec3 v) {\n    float l = luminance(v);\n    vec3 tv = v / (1.0f + v);\n    return mix(v / (1.0f + l), tv, tv);\n}\n\nvec3 acesApprox(vec3 v) {\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid main(void) {\n    vec4 outputColor = texture(src, uv);\n\n    fragColor = vec4(acesApprox(outputColor.rgb), 1.0);\n}\n",
		"shaders/uv.vert": "#version 300 es\n\nuniform Camera_block_0 {\n    mat4 modelview;\n    mat4 projection;\n    mat4 view;\n    mat4 viewInverse;\n    float zNear;\n    float zFar;\n    vec3 cameraPosition;\n};\n\nin vec3 position;\nin vec2 texcoord2d0;\n\nout vec2 uv;\nout vec3 uvw;\n\nvoid main() {\n    mat4 inverseProjection = inverse(projection);\n    vec3 unprojected = (inverseProjection * vec4(position, 1.0)).xyz;\n\n    uvw = mat3(viewInverse) * unprojected;\n    uvw.xyz *= -1.0;\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n"
	}
};
globalThis.BuiltInShaders = BuiltInShaders;