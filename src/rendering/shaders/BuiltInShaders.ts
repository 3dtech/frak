// Generated at 2023-09-04T12:23:30.826Z
var BuiltInShaders = {
	"webgl2": {
		"shaders/webgl2/attributes.frag": "#version 300 es\n\n// Attributes shader\nprecision mediump float;\n\nuniform float texCoord2d0Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d1Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d2Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float texCoord2d3Multiplier;\t\t// Texture coordinates output multiplier between 0 and 1\nuniform float positionMultiplier;\t\t\t\t// Position output multiplier between 0 and 1\nuniform float tangentMultiplier;\t\t\t\t// Tangent output multiplier between 0 and 1\nuniform float bitangentMultiplier;\t\t\t// BiTangent output multiplier between 0 and 1\nuniform float normalMultiplier;\t\t\t\t\t// Normal output multiplier between 0 and 1\nuniform float barycentricMultiplier;\t\t// Barycentric output multiplier between 0 and 1\n\nin vec2 fragTexcoord2d0;\nin vec2 fragTexcoord2d1;\nin vec2 fragTexcoord2d2;\nin vec2 fragTexcoord2d3;\nin vec4 fragPosition;\nin vec4 fragTangent;\nin vec4 fragBitangent;\nin vec4 fragNormal;\nin vec3 fragBarycentric;\n\nout vec4 fragColor;\n\nvoid main(void) {\n\tfragColor =\n\t\tvec4(fragTexcoord2d0, 0.0, 1.0) * texCoord2d0Multiplier +\n\t\tvec4(fragTexcoord2d1, 0.0, 1.0) * texCoord2d1Multiplier +\n\t\tvec4(fragTexcoord2d2, 0.0, 1.0) * texCoord2d2Multiplier +\n\t\tvec4(fragTexcoord2d3, 0.0, 1.0) * texCoord2d3Multiplier +\n\t\tvec4(fragPosition.rgb, 1.0) * positionMultiplier +\n\t\tvec4(fragTangent.rgb, 1.0) * tangentMultiplier +\n\t\tvec4(fragBitangent.rgb, 1.0) * bitangentMultiplier +\n\t\tvec4(fragNormal.rgb, 1.0) * normalMultiplier +\n\t\tvec4(fragBarycentric, 1.0) * barycentricMultiplier;\n}\n",
		"shaders/webgl2/attributes.vert": "#version 300 es\n\n// Attributes shader\nin vec3 position;\nin vec3 tangent;\nin vec3 bitangent;\nin vec3 normal;\nin vec3 barycentric;\nin vec2 texcoord2d0;\nin vec2 texcoord2d1;\nin vec2 texcoord2d2;\nin vec2 texcoord2d3;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec2 fragTexcoord2d0;\nout vec2 fragTexcoord2d1;\nout vec2 fragTexcoord2d2;\nout vec2 fragTexcoord2d3;\nout vec4 fragPosition;\nout vec4 fragTangent;\nout vec4 fragBitangent;\nout vec4 fragNormal;\nout vec3 fragBarycentric;\n\nvoid main() {\n\tfragNormal = projection * modelview * vec4(normal, 1.0);\n\tfragPosition = projection * modelview * vec4(position, 1.0);\n\tfragTangent = projection * modelview * vec4(tangent, 1.0);\n\tfragBitangent = projection * modelview * vec4(bitangent, 1.0);\n\tfragTexcoord2d0 = texcoord2d0;\n\tfragTexcoord2d1 = texcoord2d1;\n\tfragTexcoord2d2 = texcoord2d2;\n\tfragTexcoord2d3 = texcoord2d3;\n\tfragBarycentric = barycentric;\n\tgl_Position = fragPosition;\n}\n",
		"shaders/webgl2/debug.frag": "#version 300 es\n\n// Fallback shader\nprecision mediump float;\n\nuniform vec4 color;\n\nout vec4 fragColor;\n\nvoid main(void) {\n\tfragColor = color;\n}\n",
		"shaders/webgl2/debug.vert": "#version 300 es\n\n// Debug shader\nin vec3 position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 fragPosition;\n\nvoid main() {\n\tfragPosition = projection * modelview * vec4(position, 1.0);\n\tgl_Position = fragPosition;\n}\n",
		"shaders/webgl2/DebugPackedDepthTexture.frag": "#version 300 es\n\nprecision highp float;\n\n#define USE_VSM\n\nuniform mat4 modelview;\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec2 uv0;\n\nout vec4 fragColor;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\nfloat unpackHalf(vec2 c) {\n\treturn c.x + (c.y / 255.0);\n}\n\nvoid main(void) {\n\tvec4 texel = texture(diffuse0, uv0);\n\n#ifdef USE_VSM\n\tfragColor = vec4(0.0, unpackHalf(texel.xy), unpackHalf(texel.zw), 1.0);\n#else\n\tfloat depth = unpack(texel);\n\tfragColor = vec4(depth, depth, depth, 1.0);\n#endif\n}\n",
		"shaders/webgl2/DebugPackedDepthTexture.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 viewPosition;\nout vec3 viewNormal;\nout vec2 uv0;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tviewPosition = modelview * vec4(position, 1.0);\n\tviewNormal = normalize(mat3(modelview)*normal);\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/deferred_background.frag": "#version 300 es\n\nprecision highp float;\n\nuniform vec4 color;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main () {\n\tfragColor = color;\n}\n",
		"shaders/webgl2/deferred_background.vert": "#version 300 es\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_gbuffer.frag": "#version 300 es\n\nprecision highp float;\n\nuniform mat4 view;\nuniform mat4 viewInverse;\n\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\nuniform float lightContribution;\nuniform float reflectivity;\nuniform int useNormalmap;\nuniform int useReflection;\nuniform int receiveShadows;\n\nuniform float materialBlend;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform samplerCube env0;\nuniform sampler2D mask;\n\nin float depth;\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\nin vec4 viewPosition;\nin vec3 viewNormal;\n\nin mat3 tbn;\n\nlayout(location = 0) out vec4 gbuf_color;\nlayout(location = 1) out vec4 gbuf_normal;\nlayout(location = 2) out vec4 gbuf_position;\nlayout(location = 3) out vec4 gbuf_params;\n\nvec3 reflection() {\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\n\tvec4 color = texture(env0, lookup);\n\treturn color.rgb;\n}\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv0);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tvec3 N = viewNormal;\n\tif (useNormalmap == 1) {\n\t\tvec4 encodedNormal = texture(normal0, uv0);\n\t\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\t\tN = normalize(tbn * localCoords);\n\t\tN = normalize(mat3(view) * N);\n\t}\n\n\tif (useReflection == 1) {\n\t\tvec3 refl = reflection();\n\t\tfloat maskValue = texture(mask, uv0).r;\n\t\tcolor.rgb = mix(refl, color.rgb, maskValue * materialBlend);\n\t}\n\n\tgbuf_color = vec4(color.rgb, specularStrength);\n\tgbuf_normal = vec4(N, depth);\n\tgbuf_position = vec4(worldPosition.xyz, float(specularPower)/255.0);\n\tgbuf_params = vec4(lightContribution, receiveShadows, reflectivity, 1.0);\n}\n",
		"shaders/webgl2/deferred_gbuffer.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\nin vec3 tangent;\nin vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nout float depth;\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\nout vec4 viewPosition;\nout vec3 viewNormal;\n\nout mat3 tbn;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/deferred_light_ambient.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec4 lightColor;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main () {\n\tvec4 data0 = texture(gb0, uv);\n\tvec3 color = data0.rgb * lightColor.rgb;\n\tfragColor = vec4(color, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_ambient.vert": "#version 300 es\n\nin vec3 position;\nin vec2 texcoord2d0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_directional.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\nuniform sampler2D shadow0;\n\nuniform vec3 cameraPosition;\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nuniform mat4 view;\nuniform mat4 lightView;\nuniform mat4 lightProjection;\nuniform float shadowBias;\n\nuniform int useShadows;\nuniform int useSoftShadows;\nuniform int shadowOnly;\n\nin vec2 uv;\nout vec4 fragColor;\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap(vec4 worldPosition) {\n\tvec4 shadowPosition = lightProjection * lightView * worldPosition;\n\tvec2 shadowUV = shadowPosition.xy / shadowPosition.w;\n\tshadowUV = shadowUV * 0.5 + 0.5;\n\tvec4 shadowTexel = texture(shadow0, shadowUV);\n\n\treturn VSM(shadowTexel.xy, shadowPosition.z);\n\t// return step(shadowPosition.z - shadowBias, shadowTexel.r);\n}\n\nvoid main () {\n\tvec4 data2 = texture(gb2, uv); // position, specularPower/255\n\tvec4 data3 = texture(gb3, uv); // material parameters: (lightContribution, receiveShadows, reflectivity, unused)\n\tvec4 P = vec4(data2.xyz, 1.0);\n\n\tfloat shadow = 1.0;\n\n\tif (useShadows == 1 && data3.g > 0.0) {\n\t\tif (useSoftShadows == 1)\n\t\t\tshadow = texture(shadow0, uv).r;\n\t\telse\n\t\t\tshadow = shadowmap(P);\n\t}\n\n\tif (shadowOnly == 1) {\n\t\tfragColor = vec4(shadow, shadow, shadow, 1.0);\n\t\treturn;\n\t}\n\n\tvec4 data0 = texture(gb0, uv); // color, specularIntensity\n\n\tvec4 data1 = texture(gb1, uv); // normal, depth\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec4 viewPosition = view * P;\n\tvec3 L = normalize(mat3(view) * lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 lighting = diffuseColor + specularColor;\n\n\tvec3 final = shadow * mix(C, lighting, data3.r);\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_directional.vert": "#version 300 es\n\nin vec3 position;\nin vec2 texcoord2d0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_omni.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D gb0;\nuniform sampler2D gb1;\nuniform sampler2D gb2;\nuniform sampler2D gb3;\n\nuniform vec4 lightColor;\nuniform vec3 lightPosition;\nuniform float lightIntensity;\nuniform float lightRadius;\n\nuniform mat4 view;\nuniform vec3 cameraPosition;\n\nin vec4 screenPosition;\nout vec4 fragColor;\n\nvoid main() {\n\tvec2 uv = screenPosition.xy;\n\tuv /= screenPosition.w;\n\tuv = 0.5 * (vec2(uv.x, uv.y) + 1.0);\n\n\tvec4 data0 = texture(gb0, uv); // color.rgb, specularIntensity\n\tvec4 data1 = texture(gb1, uv); // normal.xyz, depth\n\tvec4 data2 = texture(gb2, uv); // position.xyz, specularPower/255\n\t// vec4 data3 = texture(gb3, uv); // unused\n\n\tvec3 C = data0.xyz;\n\tvec3 N = data1.xyz;\n\tvec3 P = data2.xyz;\n\tfloat specularIntensity = data0.w;\n\tfloat specularPower = 255.0*data2.w;\n\n\tvec3 lightVector = lightPosition - P;\n\tfloat attenuation = clamp(1.0 - length(lightVector)/lightRadius, 0.0, 1.0);\n\tlightVector = normalize(lightVector);\n\n\tvec4 viewPosition = view * vec4(P, 1.0);\n\tvec3 L = normalize(mat3(view) * lightVector);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0);\n\tfloat specularLight = pow(clamp(dot(N, H), 0.0, 1.0), float(specularPower));\n\tvec3 diffuseColor = C * lightColor.rgb * diffuseLight * lightIntensity;\n\tvec3 specularColor = lightColor.rgb * specularLight * specularIntensity;\n\n\tvec3 final = attenuation * (diffuseColor + specularColor);\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/deferred_light_omni.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 screenPosition;\n\nvoid main() {\n\tscreenPosition = projection * view * model * vec4(position, 1.0);\n\tgl_Position = screenPosition;\n}\n",
		"shaders/webgl2/deferred_shadow_directional.frag": "#version 300 es\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat dx = dFdx(depth);\n\tfloat dy = dFdy(depth);\n\tfragColor = vec4(depth, pow(depth, 2.0) + 0.25*(dx*dx + dy*dy), 0.0, 1.0);\n}\n",
		"shaders/webgl2/deferred_shadow_directional.vert": "#version 300 es\n/** Directional light shadow-map */\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/webgl2/depth.frag": "#version 300 es\n\n// Shader for rendering linear depth values into a floating point texture\nprecision mediump float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfragColor = vec4(depth, depth, depth, depth);\n}\n",
		"shaders/webgl2/depth.vert": "#version 300 es\n\n// Shader for rendering linear depth values into a floating point texture\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float zNear;\nuniform float zFar;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tdepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\tuv = texcoord2d0;\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/DepthRGBA.frag": "#version 300 es\n\n// Shader for rendering linear depth values into RGBA texture\nprecision highp float;\n\nuniform mat4 modelview;\n// uniform float linearDepthConstant;\n\n/** Packing Type:\n\t1 - packs depth value into RGBA\n\t2 - packs depth into RG and depth*depth into BA\n**/\nuniform int packingType;\n\nin vec4 viewPosition;\nout vec4 fragColor;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvec2 packHalf(float depth) {\n\tconst vec2 bias = vec2(1.0 / 255.0, 0.0);\n\tvec2 c = vec2(depth, fract(depth * 255.0));\n\treturn c - (c.yy * bias);\n}\n\nvoid main () {\n\tif (packingType==2) {\n\t\tfragColor = vec4(packHalf(gl_FragCoord.z), packHalf(gl_FragCoord.z*gl_FragCoord.z));\n\t}\n\telse {\n\t\tfragColor = pack(gl_FragCoord.z); // less precision, but works on most systems\n\t\t// float linearDepth = length(viewPosition) * linearDepthConstant;\n\t\t// fragColor = pack(linearDepth);\n\t}\n}\n",
		"shaders/webgl2/DepthRGBA.vert": "#version 300 es\n\n// Shader for rendering linear depth values into RGBA texture\nin vec3 position;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 viewPosition;\n\nvoid main() {\n\tviewPosition = modelview * vec4(position, 1.0);\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/diffuse.frag": "#version 300 es\n\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\nout vec4 fragColor;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 textureColor = texture(diffuse0, uv0);\n\tvec3 N = normalize(viewNormal);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tfragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/webgl2/diffuse.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\n\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\nout vec4 viewPosition;\nout vec3 viewNormal;\nout vec4 shadowPosition;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/fallback.frag": "// Fallback shader\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}",
		"shaders/webgl2/fallback.vert": "// Fallback shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n  fragNormal=modelview*vec4(normal, 1.0);\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n  fragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/webgl2/font.frag": "// Diffuse shader\nprecision mediump float; \n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform int page;\t\t\t\t\t\t// The font page texture\n\nuniform sampler2D page0;\t\t\nuniform sampler2D page1;\nuniform sampler2D page2;\nuniform sampler2D page3;\nuniform sampler2D page4;\nuniform sampler2D page5;\nuniform sampler2D page6;\nuniform sampler2D page7;\n\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tvec4 c;\n\tif(page==0) c = texture2D(page0, fragTexcoord2d0);\n\tif(page==1) c = texture2D(page1, fragTexcoord2d0);\n\tif(page==2) c = texture2D(page2, fragTexcoord2d0);\n\tif(page==3) c = texture2D(page3, fragTexcoord2d0);\n\tif(page==4) c = texture2D(page4, fragTexcoord2d0);\n\tif(page==5) c = texture2D(page5, fragTexcoord2d0);\n\tif(page==6) c = texture2D(page6, fragTexcoord2d0);\n\tif(page==7) c = texture2D(page7, fragTexcoord2d0);\n\tgl_FragColor=vec4(diffuse.r*c.r, diffuse.g*c.g, diffuse.b*c.b, c.a);\n}",
		"shaders/webgl2/font.vert": "// Font shader\nattribute vec3 position; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragPosition=projection*modelview*vec4(position, 1.0); \n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=fragPosition;\n}\n",
		"shaders/webgl2/forward_shadow.frag": "#version 300 es\n\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform int hasFloat;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\n\tif (hasFloat == 1) {\n\t\tfragColor = vec4(d, d, d, 1.0);\n\t}\n\telse {\n\t\tfragColor = pack(d);\n\t}\n\n}\n",
		"shaders/webgl2/forward_shadow.vert": "#version 300 es\n\n/** Directional light shadow-map */\nin vec3 position;\nin vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout float depth;\nout vec2 uv;\n\nvoid main() {\n\tvec4 viewPosition = modelview * vec4(position, 1.0);\n\tvec4 clipPosition = projection * viewPosition;\n\tdepth = clipPosition.z;\n\tuv = texcoord2d0;\n\tgl_Position = clipPosition;\n}\n",
		"shaders/webgl2/forward_shadow_vsm.frag": "#version 300 es\n\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nin float depth;\nin vec2 uv;\nout vec4 fragColor;\n\nvoid main() {\n\tvec4 textureColor = texture(diffuse0, uv);\n\tvec4 color = diffuse * textureColor;\n\tif (color.a < 0.99)\n\t\tdiscard;\n\n\tfloat d = (depth + 1.0) * 0.5;\n\tfloat dx = dFdx(d);\n\tfloat dy = dFdy(d);\n\n\tfragColor = vec4(d, pow(d, 2.0) + 0.25*(dx * dx + dy * dy), 0.0, 1.0);\n}\n",
		"shaders/webgl2/GaussianBlur.frag": "// Shader for rendering gaussian blurred image (horizontal)\nprecision highp float;\n\n#define MAX_BLUR_KERNEL_SIZE 10\n\nuniform float screenWidth;\nuniform float screenHeight;\nuniform int orientation; // 0 - horizontal, 1 - vertical\nuniform int kernelSize; // Recommended values: 3, 5, 7, 10 (10 is currently the maximum)\nuniform sampler2D tex0;\n\nvarying vec2 uv0;\n\nvoid main () {\n\tfloat halfSize = float(kernelSize)*0.5;\n\tvec2 texelSize = vec2(1.0/screenWidth, 1.0/screenHeight);\n\tvec4 color = vec4(0.0);\n\n\tif (orientation==1) {\n\t\t// vertical pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(0.0, offset * texelSize.y));\n\t\t}\n\t}\n\telse {\n\t\t// horizontal pass\n\t\tfor (int i=0; i<MAX_BLUR_KERNEL_SIZE; ++i) {\n\t\t\tif (i>=kernelSize)\n\t\t\t\tbreak;\n\t\t\tfloat offset = float(i)-halfSize;\n\t\t\tcolor += texture2D(tex0, uv0 + vec2(offset * texelSize.x, 0.0));\n\t\t}\n\t}\n\tgl_FragColor = color / float(kernelSize);\n\t// gl_FragColor = texture2D(tex0, uv0);\n}\n",
		"shaders/webgl2/GaussianBlur.vert": "// Shader for rendering gaussian blurred image (horizontal)\nattribute vec3 position;\nattribute vec2 texcoord2d0;\n\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform float screenWidth;\nuniform float screenHeight;\n\nvarying vec2 uv0;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\t\n\t// Resizes the rendered unit-quad to screen size\n\tvec4 viewPosition=modelview*vec4(position.x*screenWidth, position.y*screenHeight, position.z, 1.0);\n\tgl_Position=projection*viewPosition;\n}\n",
		"shaders/webgl2/lines.frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 fragColor;\nin vec4 fragPosition;\n\nout vec4 outColor;\n\nvoid main(void) {\n\toutColor = fragColor;\n}",
		"shaders/webgl2/lines.vert": "#version 300 es\n\nin vec3 position;\nin vec3 pointA;\nin vec3 pointB;\nin float width;\nin vec4 color;\n\nuniform vec2 viewport;\n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec4 fragColor;\nout vec4 fragPosition;\n\nvec4 clipNearPlane(vec4 a, vec4 b) {\n\tif (a.z > a.w && b.z <= b.w) {\n\t\tfloat dA = a.z - a.w;\n\t\tfloat dB = b.z - b.w;\n\t\tfloat t = dA / (dA - dB);\n\t\treturn a + (b - a) * t;\n\t}\n\treturn a;\n}\n\nvoid main() {\n\tvec4 pA = projection * modelview * vec4(pointA, 1.0);\n\tvec4 pB = projection * modelview * vec4(pointB, 1.0);\n\tpA = clipNearPlane(pA, pB);\n\tpB = clipNearPlane(pB, pA);\n\n\tvec2 screenA = viewport * (0.5 * pA.xy / pA.w + 0.5);\n\tvec2 screenB = viewport * (0.5 * pB.xy / pB.w + 0.5);\n\n\tvec2 xBasis = normalize(screenB - screenA);\n\tvec2 yBasis = vec2(-xBasis.y, xBasis.x);\n\n\tvec2 offsetA = screenA.xy + width * (position.x * xBasis + position.y * yBasis);\n\tvec2 offsetB = screenB.xy + width * (position.x * xBasis + position.y * yBasis);\n\n\tvec2 pt = mix(offsetA, offsetB, position.z);\n\tvec4 clip = mix(pA, pB, position.z);\n\n\tfragColor = color;\n\tfragPosition = vec4(clip.w * ((2.0 * pt) / viewport - 1.0), clip.z, clip.w);\n\tgl_Position = fragPosition;\n}\n",
		"shaders/webgl2/normalmapped.frag": "// Normal mapped diffuse shader\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform float specularStrength;\nuniform int specularPower;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform float shadowBias;\n\nuniform sampler2D diffuse0;\nuniform sampler2D normal0;\nuniform sampler2D shadow0;\n\nuniform int hasFloat;\nuniform int useVSM;\nuniform int useShadows;\nuniform int receiveShadows;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nfloat unpack(vec4 c) {\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\treturn dot(c, bitShifts);\n}\n\n/** Computes color and directional lighting */\nvec4 lighting(float shadow) {\n\tvec4 encodedNormal = texture2D(normal0, uv0);\n\t// vec3 localCoords = 2.0 * encodedNormal.rgb - vec3(1.0);\n\tvec3 localCoords = vec3(2.0 * encodedNormal.rg - vec2(1.0), encodedNormal.b);\n\tvec3 normalDirection = normalize(tbn * localCoords);\n\tvec3 N = normalize(mat3(view) * normalDirection);\n\n\tvec4 textureColor = texture2D(diffuse0, uv0);\n\tvec3 L = normalize(mat3(view)*lightDirection);\n\tvec3 V = normalize(-viewPosition.xyz);\n\tvec3 H = normalize(L + V);\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\n\tspecularLight = pow(specularLight, float(specularPower));\n\n\tvec4 ambientColor = ambient * textureColor;\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\n\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\n}\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap() {\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\n\tuv = uv * 0.5 + 0.5;\n\tvec4 shadowTexel = texture2D(shadow0, uv);\n\n\tfloat depth;\n\tif (hasFloat == 1)\n\t\tdepth = shadowTexel.r;\n\telse\n\t\tdepth = unpack(shadowTexel);\n\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\n\n\tif (useVSM == 1)\n\t\treturn VSM(shadowTexel.xy, lightDepth);\n\n\treturn step(lightDepth - shadowBias, depth);\n}\n\nvoid main(void) {\n\tfloat shadow = 1.0;\n\tif (useShadows > 0 && receiveShadows > 0) {\n\t\tshadow = shadowmap();\n\t}\n\n\tvec4 color = lighting(shadow);\n\tgl_FragColor = clamp(color, 0.0, 1.0);\n}\n",
		"shaders/webgl2/normalmapped.vert": "// Normal mapped diffuse shader\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 texcoord2d0;\nattribute vec3 tangent;\nattribute vec3 bitangent;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\nuniform vec3 lightDirection;\n\nvarying vec2 uv0;\nvarying vec4 worldPosition;\nvarying vec3 worldNormal;\nvarying vec4 viewPosition;\nvarying vec3 viewNormal;\nvarying vec4 shadowPosition;\n\nvarying mat3 tbn;\n\nhighp mat3 transpose(in highp mat3 m) {\n\thighp vec3 i0 = m[0];\n\thighp vec3 i1 = m[1];\n\thighp vec3 i2 = m[2];\n\thighp mat3 outMatrix = mat3(\n\t\tvec3(i0.x, i1.x, i2.x),\n\t\tvec3(i0.y, i1.y, i2.y),\n\t\tvec3(i0.z, i1.z, i2.z)\n\t);\n\treturn outMatrix;\n}\n\nvoid main() {\n\tuv0 = texcoord2d0; // TODO: In the future this will probably need to use texture offset and scale uniforms\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = normalize(mat3(modelview) * normal);\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\ttbn[0] = normalize(vec3(model * vec4(tangent, 0.0)));\n\ttbn[1] = normalize(vec3(model * vec4(bitangent, 0.0)));\n\ttbn[2] = worldNormal;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/OITAccum.frag": "#version 300 es\n\n/**\n * Based on the following ideas:\n *\n *   - Weighted Blended Order-Independent Transparency\n *     http://jcgt.org/published/0002/02/09/\n *\n *   - Stochastic Transparency\n *     http://www.nvidia.com/object/nvidia_research_pub_016.html\n *\n *   - Simplex noise (C) Ashima Arts\n *     https://github.com/ashima/webgl-noise\n */\n\nprecision highp float;\n\nuniform vec4 diffuse;\nuniform sampler2D diffuse0;\n\nuniform int render_mode;\n\nuniform mat4 viewInverse;\nuniform float zNear;\nuniform float zFar;\nuniform int useReflection;\nuniform float reflectivity;\n\nuniform samplerCube env0;\n\nin vec3 fragNormal;\nin vec4 fragPosition;\nin vec2 fragTexcoord2d0;\nin vec3 worldNormal;\nout vec4 fragColor;\n\nvec4 mod289(vec4 x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n\treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n\treturn mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r) {\n\treturn 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip) {\n\tconst vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n\tvec4 p,s;\n\tp.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n\tp.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n\ts = vec4(lessThan(p, vec4(0.0)));\n\tp.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\treturn p;\n}\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n\tconst vec4 C = vec4(\n\t\t0.138196601125011, // (5 - sqrt(5))/20 G4\n\t\t0.276393202250021, // 2 * G4\n\t\t0.414589803375032, // 3 * G4\n\t\t-0.447213595499958); // -1 + 4 * G4\n\n\t// First corner\n\tvec4 i = floor(v + dot(v, vec4(F4)) );\n\tvec4 x0 = v - i + dot(i, C.xxxx);\n\n\t// Other corners\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t// i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\t// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\t// x0 = x0 - 0.0 + 0.0 * C.xxxx\n\t// x1 = x0 - i1 + 1.0 * C.xxxx\n\t// x2 = x0 - i2 + 2.0 * C.xxxx\n\t// x3 = x0 - i3 + 3.0 * C.xxxx\n\t// x4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\t// Permutations\n\ti = mod289(i);\n\tfloat j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n\tvec4 j1 = permute( permute( permute( permute (\n\ti.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n\t+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n\t+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n\t+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n\t// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n\t// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\tvec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\tvec4 p0 = grad4(j0, ip);\n\tvec4 p1 = grad4(j1.x, ip);\n\tvec4 p2 = grad4(j1.y, ip);\n\tvec4 p3 = grad4(j1.z, ip);\n\tvec4 p4 = grad4(j1.w, ip);\n\n\t// Normalise gradients\n\tvec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tp4 *= taylorInvSqrt(dot(p4,p4));\n\n\t// Mix contributions from the five corners\n\tvec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n\tvec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4) ), 0.0);\n\tm0 = m0 * m0;\n\tm1 = m1 * m1;\n\treturn 49.0 *\n\t\t( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n\t\t+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n}\n\nfloat oit_weight(float z, vec4 color) {\n\treturn max(min(1.0, max(max(color.r, color.g), color.b) * color.a), color.a) * clamp(0.03 / (1e-5 + pow(z / 200.0, 4.0)), 1e-2, 3e3);\n}\n\nvec3 reflection() {\n\tvec3 eyeDirection = normalize(-fragPosition.xyz);\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\n\tvec4 color = texture(env0, lookup);\n\treturn color.rgb;\n}\n\nvec4 lighting() {\n\t/* TODO: proper lighting for transparent surfaces */\n\tvec4 textureColor = texture(diffuse0, fragTexcoord2d0);\n\tvec4 color = diffuse * textureColor;\n\treturn color;\n}\n\nvoid main(void) {\n\tvec4 color = lighting();\n\n\tif (useReflection == 1) {\n\t\tvec3 refl = reflection();\n\t\tcolor.rgb = mix(refl, color.rgb, clamp(1.0 - reflectivity, 0.0, 1.0));\n\t}\n\n\t// Weighted Blended Order-Independent Transparency color pass\n\tif (render_mode == 0) {\n\t\tfloat linDepth = 2.0 * zNear * zFar / (zFar + zNear - (2.0 * -fragPosition.z - 1.0) * (zFar - zNear));\n\t\tfloat weight = oit_weight(linDepth, color);\n\t\tfragColor = vec4(color.rgb * color.a, color.a) * weight;\n\t}\n\n\t// Alpha reveal amount pass\n\telse if (render_mode == 1) {\n\t\tfragColor = vec4(color.a); // total amount revealed (blending: 0; 1-src.a)\n\t}\n\n\t// Alpha mapping pass\n\telse if (render_mode == 2) {\n\t\tif (color.a < 0.99)\n\t\t\tdiscard;\n\t\tfragColor = color;\n\t}\n\n\t// Stochastic transparency pass\n\telse if (render_mode == 3) {\n\t\tfloat random = snoise(fragPosition*150.0);\n\t\tif (random > color.a)\n\t\t\tdiscard;\n\t\tfragColor = vec4(color.rgb * color.a, 1.0);\n\t}\n}\n",
		"shaders/webgl2/OITAccum.vert": "#version 300 es\n\n/** Order independent transparency - vertex program */\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nout vec3 fragNormal;\nout vec4 fragPosition;\nout vec2 fragTexcoord2d0;\nout vec3 worldNormal;\n\nvoid main() {\n\tfragNormal = mat3(modelview) * normal;\n\tfragPosition = modelview * vec4(position, 1.0);\n\tfragTexcoord2d0 = texcoord2d0;\n\tworldNormal = normalize(mat3(model) * normal);\n\tgl_Position = projection * fragPosition;\n}\n",
		"shaders/webgl2/OITRender.frag": "#version 300 es\n\n/**\n * Weighted Blended Order-Independent Transparency - Compositing program\n * Based on http://jcgt.org/published/0002/02/09/\n */\n\nprecision highp float;\n\nin vec2 uv;\n\nuniform vec2 ViewportSize;\nuniform int render_mode;\n\nuniform sampler2D src;\nuniform sampler2D oitAccum;\nuniform sampler2D oitWeight;\n\nout vec4 fragColor;\n\n\nvoid addRelevantSample(vec2 coords, float weight, inout vec4 accum) {\n\tvec4 texel = texture(oitAccum, coords);\n\tif (texel.a < 1.0)\n\t\treturn;\n\tfloat a = texture(oitWeight, coords).a;\n\tif (a>0.99)\n\t\treturn;\n\taccum += texel * weight * a;\n}\n\nvec4 avgColor(sampler2D s, vec2 coords) {\n\tvec2 step = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\n\tvec2 kernel[8];\n\tkernel[0] = vec2(-step.x, step.y);\n\tkernel[1] = vec2(0.0, step.y);\n\tkernel[2] = vec2(step.x, step.y);\n\tkernel[3] = vec2(step.x, 0.0);\n\tkernel[4] = vec2(-step.x, 0.0);\n\tkernel[5] = vec2(-step.x, -step.y);\n\tkernel[6] = vec2(0.0, -step.y);\n\tkernel[7] = vec2(step.x, -step.y);\n\n\tvec4 sum = vec4(0.0);\n\tfloat weight = 1.0 / (2.0 + 1.0);\n\tfloat kernelSize = 1.0;\n\n\taddRelevantSample(coords, weight, sum);\n\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\tkernelSize = 2.0;\n\tfor (int i=0; i<8; i++) {\n\t\taddRelevantSample(coords + kernel[i] * kernelSize, weight, sum);\n\t}\n\n\treturn sum;\n}\n\nvoid main(void) {\n\t// Blending: ONE_MINUS_SRC_ALPHA, SRC_ALPHA\n\n\tvec4 solidColor = texture(src, uv);\n\tfloat reveal = texture(oitWeight, uv).a;\n\tvec4 transparentColor;\n\n\t// Blended order transparency\n\tif (render_mode == 0) {\n\t\ttransparentColor = texture(oitAccum, uv);\n\n\t\tvec4 composite = vec4(transparentColor.rgb / max(transparentColor.a, 1e-5), reveal);\n\t\tfragColor = (1.0-composite.a) * composite +  composite.a * solidColor;\n\t}\n\n\t// Stochastic transparency\n\telse if (render_mode == 1) {\n\t\ttransparentColor = avgColor(oitAccum, uv);\n\t\tfragColor = (1.0 - reveal) * transparentColor + reveal * solidColor;\n\t}\n}\n",
		"shaders/webgl2/OITRender.vert": "#version 300 es\n\n/** Order independent transparency - vertex program */\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/pbr.frag": "#version 300 es\n\nprecision highp float;\n\nuniform mat4 modelview;\nuniform mat4 view;\n\nuniform vec3 cameraPosition;\n\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform vec4 emissive;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform float reflectance;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\n#ifdef EMISSIVE_TEXTURE\nuniform sampler2D emissive0;\n\n#ifdef EMISSIVE_UV_TRANSFORM\nuniform mat3 emissiveUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\nout vec4 fragColor;\n\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n\treturn x * x * x * x * x;\n}\n\nfloat getDistanceAttenuation(float distanceSq, float invRangeSq) {\n\tfloat factor = distanceSq * invRangeSq;\n\tfloat smoothFactor = saturate(1.0 - factor * factor);\n\tfloat attenuation = smoothFactor * smoothFactor;\n\treturn attenuation * 1.0 / max(distanceSq, 1e-4);\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n\tfloat oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n\tfloat a = NdotH * roughness;\n\tfloat k = roughness / (oneMinusNdotHSq + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n\tfloat a2 = roughness * roughness;\n\tfloat lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n\tfloat lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n\tfloat v = 0.5 / (lambdaV + lambdaL);\n\treturn v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n\t// not using mix to keep the vec3 and float versions identical\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n\tfloat f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n\treturn F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n\t\t\tfloat NoH, float LoH, float specularIntensity) {\n\tfloat D = D_GGX(roughness, NoH);\n\tfloat V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n\tvec3 F = fresnel(f0, LoH);\n\n\treturn (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n\tfloat f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n\tfloat lightScatter = F_Schlick(1.0, f90, NoL);\n\tfloat viewScatter = F_Schlick(1.0, f90, NoV);\n\treturn lightScatter * viewScatter * (1.0 / PI);\n}\n\nconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\nvec3 EnvBRDFApprox(vec3 f0, float perceptualRoughness, float NoV) {\n\tvec4 r = perceptualRoughness * c0 + c1;\n\tfloat a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\tvec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n\treturn f0 * AB.x + AB.y;\n}\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n\tfloat clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n\treturn clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nfloat luminance(vec3 v) {\n\treturn dot(v, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 changeLuminance(vec3 cIn, float lOut) {\n\tfloat lIn = luminance(cIn);\n\treturn cIn * (lOut / lIn);\n}\n\nvec3 reinhardLuminance(vec3 color) {\n\tfloat lOld = luminance(color);\n\tfloat lNew = lOld / (1.0f + lOld);\n\treturn changeLuminance(color, lNew);\n}\n\nvec3 reinhardExtendedLuminance(vec3 color, float maxWhiteL) {\n\tfloat lOld = luminance(color);\n\tfloat numerator = lOld * (1.0f + (lOld / (maxWhiteL * maxWhiteL)));\n\tfloat lNew = numerator / (1.0f + lOld);\n\treturn changeLuminance(color, lNew);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n\t//return specular;\n}\n\nvec2 diffuseUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 emissiveUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef EMISSIVE_UV_TRANSFORM\n\tuv = emissiveUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n\tvec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\noutputColor.a = 1.0;\t// We only use this shader with alphaMode == 'OPAQUE'\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n\tfloat metallic = metallic * metallicRoughness.b;\n\tfloat perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n\tvec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n\tvec3 B = cross(N, T) * worldTangent.w;\n\n\tmat3 TBN = mat3(T, -B, N);\n\tN = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n#ifdef EMISSIVE_TEXTURE\n\tvec4 emissive = emissive;\n\temissive.rgb *= texture(emissive0, emissiveUV()).rgb;\n#endif\n\n\tvec3 V = normalize(cameraPosition - worldPosition.xyz);\n\tfloat NdotV = max(dot(N, V), 1e-4);\n\n\tvec3 F0 = 0.16 * reflectance * reflectance * (1.0 - metallic) + outputColor.rgb * metallic;\n\tvec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n\tvec3 R = reflect(-V, N);\n\n\tvec3 diffuseAmbient = EnvBRDFApprox(diffuseColor, 1.0, NdotV);\n\tvec3 specularAmbient = EnvBRDFApprox(F0, perceptualRoughness, NdotV);\n\n\toutputColor.rgb = dirLight(normalize(lightDirection), lightColor * lightIntensity * 10.4, roughness, NdotV, N, V, R, F0, diffuseColor);\n\toutputColor.rgb += (diffuseAmbient + specularAmbient) * ambient.rgb * occlusion;\n\n\toutputColor.rgb = reinhardLuminance(outputColor.rgb);\n\n\toutputColor.rgb += emissive.rgb;\n\n\tfragColor = outputColor;\n}\n",
		"shaders/webgl2/pbr.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n#ifdef VERTEX_TANGENTS\nin vec4 tangent4d;\n#endif\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\n\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\n#ifdef VERTEX_TANGENTS\nout vec4 worldTangent;\n#endif\nout vec4 viewPosition;\nout vec3 viewNormal;\nout vec4 shadowPosition;\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(modelview) * normal;\n#ifdef VERTEX_TANGENTS\n\tworldTangent = vec4(normalize(mat3(model) * tangent4d.xyz), tangent4d.w);\n#endif\n\n\tshadowPosition = lightProjection * lightView * worldPosition;\n\n\tgl_Position = projection * viewPosition;\n}\n",
		"shaders/webgl2/positionbuffer.frag": "//Normal buffer\nprecision highp float;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform mat4 modelview;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvec4 pack(float depth) {\n\tconst vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n\tconst vec4 bitMask = vec4(0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\tvec4 comp = fract(depth * bitShift);\n\tcomp -= comp.xxyz * bitMask;\n\treturn comp;\n}\n\nvoid main() {\n\tfloat linDepth = (-viewPosition.z - zNear) / (zFar - zNear);\n\tgl_FragColor = pack(linDepth);\n}\n",
		"shaders/webgl2/positionbuffer.vert": "//Normal buffer\nattribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec4 worldPosition;\nvarying vec4 viewPosition;\nvarying vec3 worldNormal;\nvarying vec3 viewNormal;\n\nvoid main() {\n    worldPosition = model * vec4(position, 1.0);\n    viewPosition = view * worldPosition;\n    worldNormal = normalize(mat3(model)*normal);\n    viewNormal = mat3(modelview) * normal;\n    \n    gl_Position = projection * viewPosition;\n}",
		"shaders/webgl2/postprocess_blur.frag": "#version 300 es\n\n/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nin highp vec2 blurCoords[5];\nout vec4 fragColor;\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture(src, blurCoords[0]) * 0.204164;\n\tsum += texture(src, blurCoords[1]) * 0.304005;\n\tsum += texture(src, blurCoords[2]) * 0.304005;\n\tsum += texture(src, blurCoords[3]) * 0.093913;\n\tsum += texture(src, blurCoords[4]) * 0.093913;\n\tfragColor = sum;\n}\n",
		"shaders/webgl2/postprocess_blur.vert": "#version 300 es\n\n/**\n * Blur post-process\n * http://www.sunsetlakesoftware.com/2013/10/21/optimizing-gaussian-blurs-mobile-gpu\n */\n\nin vec3 position;\nin vec2 uv0;\n\nuniform vec2 ViewportSize;\nuniform vec2 BlurSize;\n\nout vec2 blurCoords[5];\n\nvoid main() {\n\tvec2 offset = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y) * BlurSize;\n\n\tblurCoords[0] = uv0;\n\tblurCoords[1] = uv0 + offset * 1.407333;\n\tblurCoords[2] = uv0 - offset * 1.407333;\n\tblurCoords[3] = uv0 + offset * 3.294215;\n\tblurCoords[4] = uv0 - offset * 3.294215;\n\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/postprocess_fxaa.frag": "#version 300 es\n\n/**\n * FXAA post-process\n *\n * Based on webgl-meincraft FXAA implementation.\n * https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n */\n\n/*\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Basic FXAA implementation based on the code on geeks3d.com with the\n * modification that the texture2DLod stuff was removed since it's\n * unsupported by WebGL.\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nuniform vec2 ViewportSize;\nuniform float reduce_min;\nuniform float reduce_mul;\nuniform float span_max;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvec4 fxaa(sampler2D tex, vec2 texCoord) {\n\tvec4 color;\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec3 rgbNW = texture(tex, texCoord + vec2(-1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbNE = texture(tex, texCoord + vec2(1.0, -1.0) * inverseVP).xyz;\n\tvec3 rgbSW = texture(tex, texCoord + vec2(-1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbSE = texture(tex, texCoord + vec2(1.0, 1.0) * inverseVP).xyz;\n\tvec3 rgbM = texture(tex, texCoord).xyz;\n\tvec3 luma = vec3(0.299, 0.587, 0.114);\n\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM = dot(rgbM, luma);\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n\tfloat dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * reduce_mul), reduce_min);\n\n\tfloat rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(span_max, span_max), max(vec2(-span_max, -span_max), dir * rcpDirMin)) * inverseVP;\n\n\tvec3 rgbA = 0.5 * (\n\t\ttexture(tex, texCoord + dir * (1.0 / 3.0 - 0.5)).xyz +\n\t\ttexture(tex, texCoord + dir * (2.0 / 3.0 - 0.5)).xyz);\n\tvec3 rgbB = rgbA * 0.5 + 0.25 * (\n\t\ttexture(tex, texCoord + dir * -0.5).xyz +\n\t\ttexture(tex, texCoord + dir * 0.5).xyz);\n\n\tfloat lumaB = dot(rgbB, luma);\n\tif ((lumaB < lumaMin) || (lumaB > lumaMax))\n\t\tcolor = vec4(rgbA, 1.0);\n\telse\n\t\tcolor = vec4(rgbB, 1.0);\n\treturn color;\n}\n\nvoid main () {\n\tfragColor = fxaa(src, uv);\n}\n",
		"shaders/webgl2/postprocess_fxaa.vert": "#version 300 es\n\n/** FXAA post-process effect vertex shader */\n\nin vec3 position;\nin vec2 uv0;\n\nout vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/postprocess_ssao.frag": "#version 300 es\n\n/*\n * Screen space ambient occlusion post process\n *\n * SSAO GLSL shader v1.2\n * assembled by Martins Upitis (martinsh) (devlog-martinsh.blogspot.com)\n * original technique is made by Arkano22 (www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n *\n * Changelog:\n * 1.2 - added fog calculation to mask AO. Minor fixes.\n * 1.1 - added spiral sampling method from here:\n * (http://www.cgafaq.info/wiki/Evenly_distributed_points_on_sphere)\n */\n\nprecision highp float;\n\n#define PI 3.14159265\n\nuniform sampler2D depth0;\nuniform sampler2D oitWeight;\nuniform sampler2D src;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoOnly;\nuniform float gdisplace; // Gauss bell center, default: 0.3\nuniform float radius; // AO radius, default: 2.0\nuniform float brightness; // AO brightness, default: 1.0\nuniform float luminanceInfluence; // how much luminance affects occlusion, default: 0.7\n\nout vec4 fragColor;\n\nconst int samples = 16;\n// const int samples = 8;\n\nfloat aoclamp = 0.25; // depth clamp - reduces haloing at screen edges\nbool noise = true; // use noise instead of pattern for sample dithering\nfloat noiseamount = 0.0002; // dithering amount\nfloat diffarea = 0.4; // self-shadowing reduction\n\nvec2 rand(vec2 coord) {\n\tfloat noiseX = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.25)+(fract(coord.t*(ViewportSize.y/2.0))*0.75))*2.0-1.0;\n\tfloat noiseY = ((fract(1.0-coord.s*(ViewportSize.x/2.0))*0.75)+(fract(coord.t*(ViewportSize.y/2.0))*0.25))*2.0-1.0;\n\tif (noise) {\n\t\tnoiseX = clamp(fract(sin(dot(coord, vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t\tnoiseY = clamp(fract(sin(dot(coord, vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n\t}\n\treturn vec2(noiseX, noiseY) * noiseamount;\n}\n\nfloat readDepth(in vec2 coord) {\n\treturn texture(depth0, coord).r;\n}\n\nfloat compareDepths(in float depth1, in float depth2, inout int far) {\n\tfloat garea = 2.0; // gauss bell width\n\tfloat diff = (depth1 - depth2)*100.0; // depth difference (0-100)\n\t// reduce left bell width to avoid self-shadowing\n\tif (diff<gdisplace) {\n\t\tgarea = diffarea;\n\t}\n\telse {\n\t\tfar = 1;\n\t}\n\n\tfloat gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));\n\treturn gauss;\n}\n\nfloat calAO(vec2 uv, float depth, float dw, float dh) {\n\tfloat dd = (1.0-depth) * radius;\n\n\tfloat temp = 0.0;\n\tfloat temp2 = 0.0;\n\tfloat coordw = uv.x + dw*dd;\n\tfloat coordh = uv.y + dh*dd;\n\tfloat coordw2 = uv.x - dw*dd;\n\tfloat coordh2 = uv.y - dh*dd;\n\n\tvec2 coord = vec2(coordw , coordh);\n\tvec2 coord2 = vec2(coordw2, coordh2);\n\n\tint far = 0;\n\ttemp = compareDepths(depth, readDepth(coord), far);\n\t//DEPTH EXTRAPOLATION:\n\tif (far > 0) {\n\t\ttemp2 = compareDepths(readDepth(coord2), depth, far);\n\t\ttemp += (1.0-temp)*temp2;\n\t}\n\n\treturn temp;\n}\n\nvoid main() {\n\tvec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n\tvec2 texCoord = gl_FragCoord.xy * inverseVP;\n\n\tvec2 noise = rand(texCoord);\n\tfloat depth = readDepth(texCoord);\n\tfloat reveal = texture(oitWeight, texCoord).a;\n\n\tfloat w = inverseVP.x/clamp(depth, aoclamp,1.0)+(noise.x*(1.0-noise.x));\n\tfloat h = inverseVP.y/clamp(depth, aoclamp,1.0)+(noise.y*(1.0-noise.y));\n\n\tfloat pw;\n\tfloat ph;\n\n\tfloat ao;\n\n\tfloat dl = PI*(3.0-sqrt(5.0));\n\tfloat dz = 1.0/float(samples);\n\tfloat l = 0.0;\n\tfloat z = 1.0 - dz/2.0;\n\n\tfor (int i = 0; i <= samples; i++) {\n\t\tfloat r = sqrt(1.0-z);\n\t\tpw = cos(l)*r;\n\t\tph = sin(l)*r;\n\t\tao += calAO(texCoord, depth, pw*w, ph*h);\n\t\tz = z - dz;\n\t\tl = l + dl;\n\t}\n\n\tao /= float(samples) * brightness;\n\tao = 1.0 - ao * reveal;\n\n\tvec3 color = texture(src, texCoord).rgb;\n\tvec3 lumcoeff = vec3(0.299, 0.587, 0.114);\n\tfloat lum = dot(color.rgb, lumcoeff);\n\tvec3 luminance = vec3(lum, lum, lum);\n\tvec3 final = vec3(color*mix(vec3(ao),vec3(1.0), luminance * luminanceInfluence));\n\n\tif (ssaoOnly == 1) {\n\t\tfinal = vec3(mix(vec3(ao),vec3(1.0),luminance * luminanceInfluence));\n\t}\n\n\tfragColor = vec4(final, 1.0);\n}\n",
		"shaders/webgl2/postprocess_ssao.vert": "#version 300 es\n\n/*\n * Screen space ambient occlusion post process\n */\nin vec3 position;\n\nvoid main() {\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/reflective.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/webgl2/reflective.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/reflective_masked.frag": "precision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\nuniform mat4 viewInverse;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\nuniform samplerCube env0;\r\nuniform sampler2D mask;\r\n\r\nuniform float materialBlend;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\nuniform int useLighting;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\nvec4 reflection() {\r\n\tvec3 eyeDirection = normalize(-viewPosition.xyz);\r\n\tvec3 worldEyeDirection = normalize(mat3(viewInverse) * eyeDirection);\r\n\tvec3 lookup = reflect(worldEyeDirection, worldNormal) * vec3(-1.0, 1.0, 1.0);\r\n\tvec4 color = textureCube(env0, lookup);\r\n\treturn color;\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\tvec4 color = ambientColor + (diffuseColor + specularColor) * shadow;\r\n\treturn color;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\r\n\tfloat maskValue = texture2D(mask, uv0).r;\r\n\tvec4 color = reflection();\r\n\r\n\tif (useLighting == 1) {\r\n\t\tcolor = mix(color, lighting(shadow), maskValue * materialBlend);\r\n\t}\r\n\telse {\r\n\t\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\t\tcolor = mix(color, diffuse * textureColor, maskValue * materialBlend);\r\n\t}\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n}\r\n",
		"shaders/webgl2/reflective_masked.vert": "// Diffuse shader\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvoid main() {\r\n\tuv0 = texcoord2d0;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/ScreenQuad.frag": "// Shader for rendering a screen aligned quad for image space effects\n\nprecision highp float;\n\nvarying vec2 uv;\nuniform sampler2D tex0;\n\nvoid main () {\n\tgl_FragColor = texture2D(tex0, uv);\n}\n",
		"shaders/webgl2/ScreenQuad.vert": "// Shader for rendering a screen aligned quad for image space effects\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nvarying vec2 uv;\n\nvoid main() {\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/shadow_blur.frag": "/**\n * Shadow blur\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying highp vec2 blurCoords[14];\n\nvoid main () {\n\tlowp vec4 sum = vec4(0.0);\n\tsum += texture2D(src, blurCoords[ 0])*0.0044299121055113265;\n\tsum += texture2D(src, blurCoords[ 1])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[ 2])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[ 3])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[ 4])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[ 5])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 6])*0.147308056121;\n\tsum += texture2D(src, uv            )*0.159576912161;\n\tsum += texture2D(src, blurCoords[ 7])*0.147308056121;\n\tsum += texture2D(src, blurCoords[ 8])*0.115876621105;\n\tsum += texture2D(src, blurCoords[ 9])*0.0776744219933;\n\tsum += texture2D(src, blurCoords[10])*0.0443683338718;\n\tsum += texture2D(src, blurCoords[11])*0.0215963866053;\n\tsum += texture2D(src, blurCoords[12])*0.00895781211794;\n\tsum += texture2D(src, blurCoords[13])*0.0044299121055113265;\n\tgl_FragColor = sum;\n}\n",
		"shaders/webgl2/shadow_blurh.vert": "/**\n * Shadow blur - horizontal\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(-0.028, 0.0) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(-0.024, 0.0) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(-0.020, 0.0) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(-0.016, 0.0) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(-0.012, 0.0) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(-0.008, 0.0) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(-0.004, 0.0) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2( 0.004, 0.0) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2( 0.008, 0.0) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2( 0.012, 0.0) * blurSize;\n\tblurCoords[10] = uv0 + vec2( 0.016, 0.0) * blurSize;\n\tblurCoords[11] = uv0 + vec2( 0.020, 0.0) * blurSize;\n\tblurCoords[12] = uv0 + vec2( 0.024, 0.0) * blurSize;\n\tblurCoords[13] = uv0 + vec2( 0.028, 0.0) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/shadow_blurv.vert": "/**\n * Shadow blur - vertical\n */\n\nattribute vec3 position;\nattribute vec2 uv0;\n\nuniform sampler2D src;\n\nvarying vec2 uv;\nvarying vec2 blurCoords[14];\n\nvoid main() {\n\tfloat blurSize = 0.2;\n\tblurCoords[ 0] = uv0 + vec2(0.0, -0.028) * blurSize;\n\tblurCoords[ 1] = uv0 + vec2(0.0, -0.024) * blurSize;\n\tblurCoords[ 2] = uv0 + vec2(0.0, -0.020) * blurSize;\n\tblurCoords[ 3] = uv0 + vec2(0.0, -0.016) * blurSize;\n\tblurCoords[ 4] = uv0 + vec2(0.0, -0.012) * blurSize;\n\tblurCoords[ 5] = uv0 + vec2(0.0, -0.008) * blurSize;\n\tblurCoords[ 6] = uv0 + vec2(0.0, -0.004) * blurSize;\n\tblurCoords[ 7] = uv0 + vec2(0.0,  0.004) * blurSize;\n\tblurCoords[ 8] = uv0 + vec2(0.0,  0.008) * blurSize;\n\tblurCoords[ 9] = uv0 + vec2(0.0,  0.012) * blurSize;\n\tblurCoords[10] = uv0 + vec2(0.0,  0.016) * blurSize;\n\tblurCoords[11] = uv0 + vec2(0.0,  0.020) * blurSize;\n\tblurCoords[12] = uv0 + vec2(0.0,  0.024) * blurSize;\n\tblurCoords[13] = uv0 + vec2(0.0,  0.028) * blurSize;\n\tuv = uv0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/webgl2/skybox.frag": "#version 300 es\n\nprecision highp float;\n\nuniform samplerCube skybox0;\n\nin vec3 uv0;\nout vec4 fragColor;\n\nvoid main(void) {\n\tfragColor = texture(skybox0, uv0);\n}\n",
		"shaders/webgl2/skybox.vert": "#version 300 es\n\nin vec3 position;\nin vec3 normal;\nin vec2 texcoord2d0;\n\nuniform mat4 model;\nuniform mat4 view;\nuniform mat4 modelview;\nuniform mat4 projection;\nuniform mat4 lightProjection;\nuniform mat4 lightView;\n\nout vec3 uv0;\n\nvoid main(void) {\n\tuv0 = vec3(position.x, -position.yz);\n\tgl_Position = projection * view * model * vec4(position, 1.0);\n}\n",
		"shaders/webgl2/ssao.frag": "precision highp float;\n\nuniform sampler2D position0;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform float ssaoGDisplace;\nuniform float ssaoRadius;\nuniform float ssaoDivider;\n\n#define DL 2.399963229728653\n#define EULER 2.718281828459045\n\nfloat unpack(vec4 c) {\n    const vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n    return dot(c, bitShifts);\n}\n\nfloat getDepth(vec2 coord) {\n    float d = unpack(texture2D(position0, coord.xy));\n    if (d == 0.0)\n        d = 1.0;\n    return d;\n}\n\nfloat doAmbientOcclusion(vec2 coord, vec2 coord2, float d) {\n    float diff = getDepth(coord + coord2) - d;\n    float gDisplace = -0.0002 - (0.00002 * max(min(ssaoGDisplace, 10.0), 0.0));\n    //float gDisplace = -0.00032;\n    return (diff < gDisplace) ? pow(EULER, -2.0 * (diff - gDisplace) * (diff - gDisplace) * 10000.0 / 0.16) : 0.0;\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    vec2 c = gl_FragCoord.xy * inverseVP;\n    \n    float ao = 0.0;\n\n    float dz = 1.0 / 8.0;\n    float z = 1.0 - dz / 2.0;\n    float l = 0.0;\n\n    float depth = getDepth(c);\n\n    for (int i = 0; i <= 8; i++) {\n        float r = sqrt(1.0 - z);\n\n        vec2 p = vec2(cos(l) * r, sin(l) * r);\n        ao += doAmbientOcclusion(c, p * ssaoRadius * inverseVP.x * (1.0 - depth), depth);\n        z = z - dz;\n        l = l + DL;\n    }\n\n    ao /= 8.0 + max(min(ssaoDivider, 1.0), -1.0);\n    //ao /= 8.5;\n    \n    ao = max(0.0, ao * 2.0 - 1.0);\n    ao = 1.0 - ao;\n    gl_FragColor = vec4(ao, ao, ao, 1.0);\n    //gl_FragColor = vec4(depth, depth, depth, 1.0);\n    //gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}",
		"shaders/webgl2/ssao.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/webgl2/ssaoblur.frag": "precision highp float;\n\nuniform sampler2D ao0;\nuniform sampler2D src;\n\nuniform mat4 projection;\n\nuniform float zNear;\nuniform float zFar;\nuniform vec2 ViewportSize;\n\nuniform int ssaoBlurSize;\nuniform int ssaoOnly;\n\nfloat random(vec2 co) {\n    //co = mod(co, 128.0);\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid main() {\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    \n    const int MAXIMUM_BLUR = 32;\n    float result = 0.0;\n    vec2 hlim = vec2(float(-ssaoBlurSize) * 0.5 + 0.5);\n    for (int i = 0; i < MAXIMUM_BLUR; i++) {\n        if (i >= ssaoBlurSize)\n            break;\n        for (int j = 0; j < MAXIMUM_BLUR; j++) {\n            if (j >= ssaoBlurSize)\n                break;\n            vec2 offset = (hlim + vec2(float(i), float(j))) * inverseVP;\n            result += texture2D(ao0, gl_FragCoord.xy * inverseVP + offset).r;\n        }\n    }\n    result = result / float(ssaoBlurSize * ssaoBlurSize);\n\n    if (ssaoOnly == 1) {\n        gl_FragColor = vec4(vec3(result), 1.0);\n    }\n    else {\n        gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * result, 1.0);\n    }\n    //gl_FragColor = vec4(texture2D(src, gl_FragCoord.xy * inverseVP).xyz * texture2D(ao0, gl_FragCoord.xy * inverseVP/* / 2.0 + 0.5*/).xyz, 1.0);\n}",
		"shaders/webgl2/ssaoblur.vert": "attribute vec3 position;\n\nvoid main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n}",
		"shaders/webgl2/terrain.frag": "// Terrain shader for the forward renderer\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 modelview;\r\nuniform mat4 view;\r\n\r\nuniform vec4 ambient;\r\nuniform vec4 diffuse;\r\nuniform float specularStrength;\r\nuniform int specularPower;\r\n\r\nuniform vec3 lightDirection;\r\nuniform vec4 lightColor;\r\nuniform float lightIntensity;\r\nuniform float shadowBias;\r\n\r\nuniform sampler2D diffuse0;\r\nuniform sampler2D shadow0;\r\n\r\nuniform int hasFloat;\r\nuniform int useVSM;\r\nuniform int useShadows;\r\nuniform int receiveShadows;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat unpack(vec4 c) {\r\n\tconst vec4 bitShifts = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\r\n\treturn dot(c, bitShifts);\r\n}\r\n\r\n/** Computes color and directional lighting */\r\nvec4 lighting(float shadow) {\r\n\tvec4 textureColor = texture2D(diffuse0, uv0);\r\n\tvec3 N = normalize(viewNormal);\r\n\tvec3 L = normalize(mat3(view)*lightDirection);\r\n\tvec3 V = normalize(-viewPosition.xyz);\r\n\tvec3 H = normalize(L + V);\r\n\tfloat diffuseLight = max(dot(N, L), 0.0) * lightIntensity;\r\n\tfloat specularLight = min(max(dot(N, H), 0.0), 1.0);\r\n\tspecularLight = pow(specularLight, float(specularPower));\r\n\r\n\tvec4 ambientColor = ambient * textureColor;\r\n\tvec4 diffuseColor = diffuse * diffuse * textureColor * lightColor * diffuseLight;\r\n\tvec4 specularColor = lightColor * specularLight * specularStrength;\r\n\r\n\treturn ambientColor + (diffuseColor + specularColor) * shadow;\r\n}\r\n\r\nfloat linstep(float low, float high, float v) {\r\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\r\n}\r\n\r\nfloat VSM(vec2 moments, float compare) {\r\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\r\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\r\n\tfloat d = compare - moments.x;\r\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\r\n\treturn clamp(max(p, p_max), 0.0, 1.0);\r\n}\r\n\r\nfloat shadowmap() {\r\n\tvec2 uv = shadowPosition.xy / shadowPosition.w;\r\n\tuv = uv * 0.5 + 0.5;\r\n\tvec4 shadowTexel = texture2D(shadow0, uv);\r\n\r\n\tfloat depth;\r\n\tif (hasFloat == 1)\r\n\t\tdepth = shadowTexel.r;\r\n\telse\r\n\t\tdepth = unpack(shadowTexel);\r\n\r\n\tfloat lightDepth = (shadowPosition.z + 1.0) * 0.5;\r\n\r\n\tif (useVSM == 1)\r\n\t\treturn VSM(shadowTexel.xy, lightDepth);\r\n\r\n\treturn step(lightDepth - shadowBias, depth);\r\n}\r\n\r\nvoid main(void) {\r\n\tfloat shadow = 1.0;\r\n\tif (useShadows > 0 && receiveShadows > 0) {\r\n\t\tshadow = shadowmap();\r\n\t}\r\n\tvec4 color = lighting(shadow);\r\n\tgl_FragColor = clamp(color, 0.0, 1.0);\r\n\r\n\t// gl_FragColor = vec4(bc, 1.0); // for debug\r\n}\r\n",
		"shaders/webgl2/terrain.vert": "// Terrain shader for the forward renderer\r\n\r\nattribute vec3 position;\r\nattribute vec3 normal;\r\nattribute vec2 texcoord2d0;\r\nattribute vec3 barycentric;\r\n\r\nuniform mat4 model;\r\nuniform mat4 view;\r\nuniform mat4 modelview;\r\nuniform mat4 projection;\r\nuniform mat4 lightProjection;\r\nuniform mat4 lightView;\r\n\r\nuniform sampler2D height;\r\n\r\nuniform float verticalScale;\r\nuniform vec2 uvOffset;\r\nuniform vec2 uvScale;\r\n\r\nvarying vec2 uv0;\r\nvarying vec4 worldPosition;\r\nvarying vec3 worldNormal;\r\nvarying vec4 viewPosition;\r\nvarying vec3 viewNormal;\r\nvarying vec4 shadowPosition;\r\n\r\nvarying vec3 bc;\r\n\r\nfloat snap(float f, float step) {\r\n\treturn step * floor(f / step);\r\n}\r\n\r\nvoid main() {\r\n\tbc = barycentric;\r\n\tuv0 = texcoord2d0 * uvScale + uvOffset;\r\n\tworldPosition = model * vec4(position, 1.0);\r\n\r\n\t// worldPosition.x = snap(worldPosition.x, worldPosition.y);\r\n\t// worldPosition.z = snap(worldPosition.z, worldPosition.y);\r\n\r\n\tfloat height = texture2D(height, uv0).r;\r\n\tworldPosition.y = height * verticalScale;\r\n\t// worldPosition.y = 0.0;\r\n\r\n\tworldNormal = normalize(mat3(model) * normal);\r\n\tviewPosition = view * worldPosition;\r\n\tviewNormal = mat3(modelview) * normal;\r\n\r\n\tshadowPosition = lightProjection * lightView * worldPosition;\r\n\r\n\tgl_Position = projection * viewPosition;\r\n}\r\n",
		"shaders/webgl2/test.frag": "// Test fragment shader drawing in blue \n\nprecision mediump float; \n\nvoid main(void) { \n\tgl_FragColor = vec4(0.1, 0.5, 0.8, 1.0); \n}",
		"shaders/webgl2/test.vert": "// Test pass-through shader that doesn't transform vertex\nattribute vec3 position; \nattribute vec3 normal; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\n\nvoid main(void) { \n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=projection*modelview*vec4(position, 1.0);\n\tgl_Position = fragPosition; \n}\n",
		"shaders/webgl2/transparent.frag": "// Unlit transparency shader\nprecision mediump float; \n\nuniform vec4 diffuse;\n\nuniform sampler2D diffuse0;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main(void) {\n\tgl_FragColor = diffuse*texture2D(diffuse0, fragTexcoord2d0);\n}",
		"shaders/webgl2/transparent.vert": "// Unlit transparency shader\nattribute vec3 position; \nattribute vec3 normal; \nattribute vec2 texcoord2d0; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragNormal;\nvarying vec4 fragPosition;\nvarying vec2 fragTexcoord2d0;\n\nvoid main() {\n\tfragNormal=mat3(modelview)*normal;\n\tfragPosition=modelview*vec4(position, 1.0);\n\tfragTexcoord2d0=texcoord2d0;\n\tgl_Position=projection*fragPosition;\n}\n",
		"shaders/webgl2/wireframe.frag": "// Test fragment shader drawing in blue \nprecision mediump float; \n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, \n\t\t\tpow(1.0-fragBarycentric.r, 32.0)+pow(1.0-fragBarycentric.g, 32.0)+pow(1.0-fragBarycentric.b, 32.0));\n}",
		"shaders/webgl2/wireframe.vert": "// Diffuse shader\nattribute vec3 position; \nattribute vec3 barycentric; \n\nuniform mat4 modelview;\nuniform mat4 projection;\n\nvarying vec3 fragBarycentric;\n\nvoid main(void) { \n\tgl_Position=projection*modelview*vec4(position, 1.0); \n\tfragBarycentric = barycentric;\n}"
	}
};
globalThis.BuiltInShaders = BuiltInShaders;