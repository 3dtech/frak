// Generated at 2024-01-17T08:21:32.761Z
var BuiltInShaders = {
	"webgl2": {
		"shaders/color.frag": "#version 300 es\n\nprecision highp float;\n\nuniform vec4 color1;\n#ifdef NUM_TARGETS\n#if NUM_TARGETS > 1\nuniform vec4 color2;\n#endif\n#endif\n\nin vec2 uv;\n\nlayout(location = 0) out vec4 out1;\n#ifdef NUM_TARGETS\n#if NUM_TARGETS > 1\nlayout(location = 1) out vec4 out2;\n#endif\n#endif\n\nvoid main () {\n    out1 = color1;\n#ifdef NUM_TARGETS\n#if NUM_TARGETS > 1\n    out2 = color2;\n#endif\n#endif\n}\n",
		"shaders/direct_directional.frag": "#version 300 es\n\nprecision highp float;\n\n#include \"snippets/camera.glsl\"\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform mat4 lightView;\nuniform mat4 lightProjection;\nuniform float shadowBias;\n\n#ifdef SHADOWS\n#include \"snippets/shadow.glsl\"\n#endif\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\nout vec4 fragColor;\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n    float clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n    return clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n    return x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n    float oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n    float a = NdotH * roughness;\n    float k = roughness / (oneMinusNdotHSq + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n    float a2 = roughness * roughness;\n    float lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    float v = 0.5 / (lambdaV + lambdaL);\n    return v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n    // not using mix to keep the vec3 and float versions identical\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n    float f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n    return F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n              float NoH, float LoH, float specularIntensity) {\n    float D = D_GGX(roughness, NoH);\n    float V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n    vec3 F = fresnel(f0, LoH);\n\n    return (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n    //return specular;\n}\n\nvec3 acesApprox(vec3 v) {\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nfloat oitWeight(float z, vec4 color) {\n    return max(min(1.0, max(max(color.r, color.g), color.b) * color.a), color.a) *\n        clamp(0.03 / (1e-5 + pow(z / 200.0, 4.0)), 1e-2, 3e3);\n}\n\nvoid main(void) {\n    vec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#ifndef MATERIAL_UNLIT\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n    float metallic = metallic * metallicRoughness.b;\n    float perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n    vec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n    vec3 B = cross(N, T) * worldTangent.w;\n\n    mat3 TBN = mat3(T, -B, N);\n    N = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n\tvec3 V = normalize(cameraPosition - worldPosition.xyz);\n    float NdotV = max(dot(N, V), 1e-4);\n\n    vec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n    vec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n    vec3 R = reflect(-V, N);\n\n#ifdef SHADOWS\n\tfloat shadow = shadowmap(vec4(worldPosition.xyz, 1.0));\n#else\n\tfloat shadow = 1.0;\n#endif\n\n    outputColor.rgb = dirLight(normalize(lightDirection), lightColor * lightIntensity * 10.4, roughness, NdotV, N, V, R, F0, diffuseColor);\n\toutputColor.rgb *= shadow;\n    outputColor.rgb = acesApprox(outputColor.rgb);\n#endif\t// UNLIT\n\n\tfragColor = vec4(outputColor.rgb * outputColor.a, outputColor.a) * oitWeight(gl_FragCoord.z, outputColor);\n}\n",
		"shaders/direct_ibl.frag": "#version 300 es\n\nprecision highp float;\n\n#include \"snippets/camera.glsl\"\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\nuniform vec4 emissive;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\n#ifdef EMISSIVE_TEXTURE\nuniform sampler2D emissive0;\n\n#ifdef EMISSIVE_UV_TRANSFORM\nuniform mat3 emissiveUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\nlayout(location = 0) out vec4 fragColor;\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n    float clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n    return clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 emissiveUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef EMISSIVE_UV_TRANSFORM\n\tuv = emissiveUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n    vec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n    float metallic = metallic * metallicRoughness.b;\n    float perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n    vec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n    vec3 B = cross(N, T) * worldTangent.w;\n\n    mat3 TBN = mat3(T, -B, N);\n    N = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n#ifdef EMISSIVE_TEXTURE\n\tvec4 emissive = emissive;\n    emissive.rgb *= texture(emissive0, emissiveUV()).rgb;\n#endif\n\n\tfragColor = outputColor;\n}\n",
		"shaders/lines.frag": "#version 300 es\n\nprecision mediump float;\n\nin vec4 fragColor;\nin vec4 fragPosition;\n\nout vec4 outColor;\n\nvoid main(void) {\n\toutColor = fragColor;\n}\n",
		"shaders/lines.vert": "#version 300 es\n\nin vec3 position;\nin vec3 pointA;\nin vec3 pointB;\nin float width;\nin vec4 color;\n\nuniform vec2 viewport;\nuniform mat4 model;\n\n#include \"snippets/camera.glsl\"\n\nout vec4 fragColor;\nout vec4 fragPosition;\n\nvec4 clipNearPlane(vec4 a, vec4 b) {\n\tif (a.z > a.w && b.z <= b.w) {\n\t\tfloat dA = a.z - a.w;\n\t\tfloat dB = b.z - b.w;\n\t\tfloat t = dA / (dA - dB);\n\t\treturn a + (b - a) * t;\n\t}\n\treturn a;\n}\n\nvoid main() {\n\tvec4 pA = projection * model * view * vec4(pointA, 1.0);\n\tvec4 pB = projection * model * view * vec4(pointB, 1.0);\n\tpA = clipNearPlane(pA, pB);\n\tpB = clipNearPlane(pB, pA);\n\n\tvec2 screenA = viewport * (0.5 * pA.xy / pA.w + 0.5);\n\tvec2 screenB = viewport * (0.5 * pB.xy / pB.w + 0.5);\n\n\tvec2 xBasis = normalize(screenB - screenA);\n\tvec2 yBasis = vec2(-xBasis.y, xBasis.x);\n\n\tvec2 offsetA = screenA.xy + width * (position.x * xBasis + position.y * yBasis);\n\tvec2 offsetB = screenB.xy + width * (position.x * xBasis + position.y * yBasis);\n\n\tvec2 pt = mix(offsetA, offsetB, position.z);\n\tvec4 clip = mix(pA, pB, position.z);\n\n\tfragColor = color;\n\tfragPosition = vec4(clip.w * ((2.0 * pt) / viewport - 1.0), clip.z, clip.w);\n\tgl_Position = fragPosition;\n}\n",
		"shaders/mesh.vert": "#version 300 es\n\nlayout(location = 0) in vec3 position;\nlayout(location = 1) in vec3 normal;\nlayout(location = 2) in vec2 texcoord2d0;\n#ifdef VERTEX_TANGENTS\nlayout(location = 3) in vec4 tangent4d;\n#endif\n\nuniform mat4 model;\n\n#include \"snippets/camera.glsl\"\n\nout vec2 uv0;\nout vec4 worldPosition;\nout vec3 worldNormal;\n#ifdef VERTEX_TANGENTS\nout vec4 worldTangent;\n#endif\nout vec4 viewPosition;\nout vec3 viewNormal;\n#ifdef DEPTH\nout float depth;\n#endif\n\nvoid main() {\n\tuv0 = texcoord2d0;\n\tworldPosition = model * vec4(position, 1.0);\n\tworldNormal = normalize(mat3(model) * normal);\n\tviewPosition = view * worldPosition;\n\tviewNormal = mat3(view) * worldNormal;\n#ifdef VERTEX_TANGENTS\n\tworldTangent = vec4(normalize(mat3(model) * tangent4d.xyz), tangent4d.w);\n#endif\n\tvec4 projectionPosition = projection * viewPosition;\n#ifdef DEPTH\n\tdepth = projectionPosition.z / projectionPosition.w;\n#endif\n\n\tgl_Position = projectionPosition;\n}\n",
		"shaders/oit_reveal.frag": "#version 300 es\n\nprecision highp float;\n\nuniform vec4 diffuse;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\n\nout vec4 fragColor;\n\nvec2 diffuseUV() {\n    vec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n    vec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n    // blend func: GL_ZERO, GL_ONE_MINUS_SRC_ALPHA\n    fragColor = vec4(outputColor.a);\n}\n",
		"shaders/pbr.frag": "#version 300 es\n\nprecision highp float;\n\n#include \"snippets/camera.glsl\"\n\nuniform float alphaCutoff;\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform vec4 emissive;\n\nuniform float metallic;\nuniform float perceptualRoughness;\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\n#ifdef METALLICROUGHNESS_TEXTURE\nuniform sampler2D metallicRoughness0;\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\nuniform mat3 metallicRoughnessUVTransform;\n#endif\n#endif\n\n#ifdef NORMAL_TEXTURE\nuniform sampler2D normal0;\n\n#ifdef NORMAL_UV_TRANSFORM\nuniform mat3 normalUVTransform;\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\nuniform sampler2D occlusion0;\n\n#ifdef OCCLUSION_UV_TRANSFORM\nuniform mat3 occlusionUVTransform;\n#endif\n#endif\n\n#ifdef EMISSIVE_TEXTURE\nuniform sampler2D emissive0;\n\n#ifdef EMISSIVE_UV_TRANSFORM\nuniform mat3 emissiveUVTransform;\n#endif\n#endif\n\nin vec2 uv0;\nin vec4 worldPosition;\nin vec3 worldNormal;\n\n#ifdef VERTEX_TANGENTS\nin vec4 worldTangent;\n#endif\n\nin vec4 viewPosition;\nin vec3 viewNormal;\nin vec4 shadowPosition;\n\n// TODO: Optionally limit number of buffers\nlayout(location = 0) out vec4 fragColorMetallic;\n#ifndef MATERIAL_UNLIT\nlayout(location = 1) out vec4 fragNormalRoughness;\nlayout(location = 2) out vec4 fragPositionOcclusion;\n#ifdef EMISSIVE_OUT\nlayout(location = 3) out vec4 fragEmissive;\n#ifdef AMBIENT_OUT\nlayout(location = 4) out vec4 fragAmbient;\n#endif\n#elif defined(AMBIENT_OUT)\nlayout(location = 3) out vec4 fragAmbient;\n#endif\n#endif\t// UNLIT\n\nfloat perceptualRoughnessToRoughness(float perceptualRoughness) {\n\tfloat clampedPerceptualRoughness = clamp(perceptualRoughness, 0.089, 1.0);\n\treturn clampedPerceptualRoughness * clampedPerceptualRoughness;\n}\n\nvec2 diffuseUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 metallicRoughnessUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef METALLICROUGHNESS_UV_TRANSFORM\n\tuv = metallicRoughnessUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 normalUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef NORMAL_UV_TRANSFORM\n\tuv = normalUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 occlusionUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef OCCLUSION_UV_TRANSFORM\n\tuv = occlusionUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvec2 emissiveUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef EMISSIVE_UV_TRANSFORM\n\tuv = emissiveUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main(void) {\n\tvec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#if ALPHAMODE == ALPHAMODE_OPAQUE\n\toutputColor.a = 1.0;\n#endif\n\n#ifndef MATERIAL_UNLIT\n\n#ifdef METALLICROUGHNESS_TEXTURE\n\tvec4 metallicRoughness = texture(metallicRoughness0, metallicRoughnessUV());\n\tfloat metallic = metallic * metallicRoughness.b;\n\tfloat perceptualRoughness = perceptualRoughness * metallicRoughness.g;\n#endif\n\n\tfloat roughness = perceptualRoughnessToRoughness(perceptualRoughness);\n\n\tvec3 N = normalize(worldNormal);\n#ifdef VERTEX_TANGENTS\n#ifdef NORMAL_TEXTURE\n\tvec3 T = normalize(worldTangent.xyz);\n\tvec3 B = cross(N, T) * worldTangent.w;\n\n\tmat3 TBN = mat3(T, -B, N);\n\tN = TBN * normalize(texture(normal0, normalUV()).xyz * 2.0 - 1.0);\n#endif\n#endif\n\n#ifdef OCCLUSION_TEXTURE\n\tfloat occlusion = texture(occlusion0, occlusionUV()).r;\n#else\n\tfloat occlusion = 1.0;\n#endif\n\n#ifdef EMISSIVE_TEXTURE\n\tvec4 emissive = emissive;\n\temissive.rgb *= texture(emissive0, emissiveUV()).rgb;\n#endif\n\n\tfragColorMetallic = vec4(outputColor.rgb, metallic);\n\tfragNormalRoughness = vec4(N, roughness);\n\tfragPositionOcclusion = vec4(worldPosition.xyz, occlusion);\n\n#ifdef EMISSIVE_OUT\n\tfragEmissive = vec4(emissive.rgb, 1.0);\n#endif\n\n#ifdef AMBIENT_OUT\n\tfragAmbient = ambient;\n#endif\n\n#else\t// UNLIT\n\tfragColorMetallic = outputColor;\n#endif\n\n#if ALPHAMODE == ALPHAMODE_MASK\n\tif (outputColor.a < alphaCutoff) {\n\t\tdiscard;\n\t}\n\toutputColor.a = 1.0;\n#elif ALPHAMODE == ALPHAMODE_BLEND\n\t// Only render opaque parts of transparent geometry\n\tif (outputColor.a < 0.99) {\n\t\tdiscard;\n\t}\n#endif\n}\n",
		"shaders/pbr_ambient.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D colorMetallic;\nuniform sampler2D normalRoughness;\nuniform sampler2D positionOcclusion;\n\n#ifdef AMBIENT_BUFFER\nuniform sampler2D ambientBuffer;\n#endif\n\n#include \"snippets/camera.glsl\"\n\nuniform vec4 lightColor;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float REFLECTANCE = 0.5;\n\nconst vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\nconst vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n\nvec3 EnvBRDFApprox(vec3 f0, float perceptualRoughness, float NoV) {\n    vec4 r = perceptualRoughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return f0 * AB.x + AB.y;\n}\n\nvoid main(void) {\n    vec4 cM = texture(colorMetallic, uv);\n\tvec4 outputColor = vec4(cM.rgb, 1.0);\n\tfloat metallic = cM.w;\n\n    vec4 nM = texture(normalRoughness, uv);\n    vec3 N = nM.xyz;\n    float roughness = nM.w;\n\n    vec4 pR = texture(positionOcclusion, uv);\n    vec3 position = pR.xyz;\n    float occlusion = pR.w;\n\n#ifdef AMBIENT_BUFFER\n\tvec4 ambient = texture(ambientBuffer, uv);\n#else\n\tvec4 ambient = vec4(0.0);\n#endif\n\n    vec3 V = normalize(cameraPosition - position);\n    float NdotV = max(dot(N, V), 1e-4);\n\n    vec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n\n    vec3 diffuseAmbient = outputColor.rgb;\n    vec3 specularAmbient = EnvBRDFApprox(F0, roughness, NdotV);\n\tvec3 lightColor = (diffuseAmbient + specularAmbient) * lightColor.rgb;\n\n    outputColor.rgb = mix(lightColor, ambient.rgb, ambient.a) * occlusion;\n\n    fragColor = outputColor;\n}\n",
		"shaders/pbr_directional.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D colorMetallic;\nuniform sampler2D normalRoughness;\nuniform sampler2D positionOcclusion;\n\n#include \"snippets/camera.glsl\"\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\nuniform mat4 lightView;\nuniform mat4 lightProjection;\nuniform float shadowBias;\n\n#ifdef SHADOWS\n#include \"snippets/shadow.glsl\"\n#endif\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n\treturn x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n\tfloat oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n\tfloat a = NdotH * roughness;\n\tfloat k = roughness / (oneMinusNdotHSq + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n\tfloat a2 = roughness * roughness;\n\tfloat lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n\tfloat lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n\tfloat v = 0.5 / (lambdaV + lambdaL);\n\treturn v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n\t// not using mix to keep the vec3 and float versions identical\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n\tfloat f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n\treturn F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n\t\t\tfloat NoH, float LoH, float specularIntensity) {\n\tfloat D = D_GGX(roughness, NoH);\n\tfloat V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n\tvec3 F = fresnel(f0, LoH);\n\n\treturn (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n\tfloat f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n\tfloat lightScatter = F_Schlick(1.0, f90, NoL);\n\tfloat viewScatter = F_Schlick(1.0, f90, NoV);\n\treturn lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n\t//return specular;\n}\n\nvoid main(void) {\n\tvec4 cM = texture(colorMetallic, uv);\n\tvec4 outputColor = vec4(cM.rgb, 1.0);\n\tfloat metallic = cM.w;\n\n\tvec4 nM = texture(normalRoughness, uv);\n\tvec3 N = nM.xyz;\n\tfloat roughness = nM.w;\n\n\tvec4 pR = texture(positionOcclusion, uv);\n\tvec3 position = pR.xyz;\n\n\tvec3 V = normalize(cameraPosition - position);\n\tfloat NdotV = max(dot(N, V), 1e-4);\n\n\tvec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n\tvec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n\tvec3 R = reflect(-V, N);\n\n#ifdef SHADOWS\n\tfloat shadow = shadowmap(vec4(position, 1.0));\n#else\n\tfloat shadow = 1.0;\n#endif\n\n\toutputColor.rgb = dirLight(normalize(lightDirection), lightColor * lightIntensity * 10.4, roughness, NdotV, N, V, R, F0, diffuseColor);\n\toutputColor.rgb *= shadow;\n\n\tfragColor = outputColor;\n}\n",
		"shaders/pbr_emissive.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D emissive;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main(void) {\n    vec4 eO = texture(emissive, uv);\n\n    fragColor = vec4(eO.rgb, 1.0);\n}\n",
		"shaders/pbr_ibl.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D colorMetallic;\nuniform sampler2D normalRoughness;\nuniform sampler2D positionOcclusion;\n\nuniform samplerCube light0;\n\n#include \"snippets/camera.glsl\"\n\nuniform vec3 lightDirection;\nuniform vec4 lightColor;\nuniform float lightIntensity;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float REFLECTANCE = 0.5;\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat pow5(float x) {\n\treturn x * x * x * x * x;\n}\n\nfloat D_GGX(float roughness, float NdotH) {\n\tfloat oneMinusNdotHSq = 1.0 - NdotH * NdotH;\n\tfloat a = NdotH * roughness;\n\tfloat k = roughness / (oneMinusNdotHSq + a * a);\n\tfloat d = k * k * (1.0 / PI);\n\treturn d;\n}\n\nfloat V_SmithGGXCorrelated(float roughness, float NoV, float NoL) {\n\tfloat a2 = roughness * roughness;\n\tfloat lambdaV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n\tfloat lambdaL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n\tfloat v = 0.5 / (lambdaV + lambdaL);\n\treturn v;\n}\n\nvec3 F_Schlick(const vec3 f0, float f90, float VoH) {\n\t// not using mix to keep the vec3 and float versions identical\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n\treturn f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nvec3 fresnel(vec3 f0, float LoH) {\n\tfloat f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n\treturn F_Schlick(f0, f90, LoH);\n}\n\n\nvec3 specular(vec3 f0, float roughness, const vec3 h, float NoV, float NoL,\n\t\t\tfloat NoH, float LoH, float specularIntensity) {\n\tfloat D = D_GGX(roughness, NoH);\n\tfloat V = V_SmithGGXCorrelated(roughness, NoV, NoL);\n\tvec3 F = fresnel(f0, LoH);\n\n\treturn (specularIntensity * D * V) * F;\n}\n\nfloat Fd_Burley(float roughness, float NoV, float NoL, float LoH) {\n\tfloat f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n\tfloat lightScatter = F_Schlick(1.0, f90, NoL);\n\tfloat viewScatter = F_Schlick(1.0, f90, NoV);\n\treturn lightScatter * viewScatter * (1.0 / PI);\n}\n\nvec3 dirLight(vec3 direction, vec4 color, float roughness, float NdotV, vec3 normal, vec3 view, vec3 R, vec3 F0, vec3 diffuseColor) {\n    vec3 incidentLight = direction.xyz;\n\n    vec3 halfVector = normalize(incidentLight + view);\n    float NoL = saturate(dot(normal, incidentLight));\n    float NoH = saturate(dot(normal, halfVector));\n    float LoH = saturate(dot(incidentLight, halfVector));\n\n    vec3 diffuse = diffuseColor * Fd_Burley(roughness, NdotV, NoL, LoH);\n    float specularIntensity = 1.0;\n    vec3 specular = specular(F0, roughness, halfVector, NdotV, NoL, NoH, LoH, specularIntensity);\n\n    return (specular + diffuse) * color.rgb * NoL;\n\t//return specular;\n}\n\nfloat clampedDot(vec3 x, vec3 y) {\n    return clamp(dot(x, y), 0.0, 1.0);\n}\n\nvec3 getIBLRadianceGGX(vec3 n, vec3 v, float roughness, vec3 F0, float specularWeight) {\n    float NdotV = clampedDot(n, v);\n    vec3 reflection = normalize(reflect(-v, n));\n\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    //vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec2 f_ab = brdfSamplePoint;\n    vec4 specularSample = texture(light0, -reflection);\n\n    vec3 specularLight = specularSample.rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = k_S * f_ab.x + f_ab.y;\n\n    return specularWeight * specularLight * FssEss;\n}\n\nvec3 getIBLRadianceLambertian(vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 F0, float specularWeight) {\n    float NdotV = clampedDot(n, v);\n    vec2 brdfSamplePoint = clamp(vec2(NdotV, roughness), vec2(0.0, 0.0), vec2(1.0, 1.0));\n    //vec2 f_ab = texture(u_GGXLUT, brdfSamplePoint).rg;\n    vec2 f_ab = brdfSamplePoint * 0.1;\n\n    vec3 irradiance = texture(light0, n).rgb;\n\n    // see https://bruop.github.io/ibl/#single_scattering_results at Single Scattering Results\n    // Roughness dependent fresnel, from Fdez-Aguera\n\n    vec3 Fr = max(vec3(1.0 - roughness), F0) - F0;\n    vec3 k_S = F0 + Fr * pow(1.0 - NdotV, 5.0);\n    vec3 FssEss = specularWeight * k_S * f_ab.x + f_ab.y; // <--- GGX / specular light contribution (scale it down if the specularWeight is low)\n\n    // Multiple scattering, from Fdez-Aguera\n    float Ems = (1.0 - (f_ab.x + f_ab.y));\n    vec3 F_avg = specularWeight * (F0 + (1.0 - F0) / 21.0);\n    vec3 FmsEms = Ems * FssEss * F_avg / (1.0 - F_avg * Ems);\n    vec3 k_D = diffuseColor * (1.0 - FssEss + FmsEms); // we use +FmsEms as indicated by the formula in the blog post (might be a typo in the implementation)\n\n    return (FmsEms + k_D) * irradiance;\n}\n\nvec3 ibLight(vec3 normal, vec3 view, float roughness, vec3 diffuseColor, vec3 F0, float specularWeight) {\n    vec3 diffuse = getIBLRadianceLambertian(normal, view, roughness, diffuseColor, F0, specularWeight);\n    vec3 specular = getIBLRadianceGGX(normal, view, roughness, F0, specularWeight);\n\n    return /**diffuse + */specular;\n}\n\nvoid main(void) {\n\tvec4 cM = texture(colorMetallic, uv);\n\tvec4 outputColor = vec4(cM.rgb, 1.0);\n\tfloat metallic = cM.w;\n\n\tvec4 nM = texture(normalRoughness, uv);\n\tvec3 N = nM.xyz;\n\tfloat roughness = nM.w;\n\n\tvec4 pR = texture(positionOcclusion, uv);\n\tvec3 position = pR.xyz;\n\n\tvec3 V = normalize(cameraPosition - position);\n\tfloat NdotV = max(dot(N, V), 1e-4);\n\n\tvec3 F0 = 0.16 * REFLECTANCE * REFLECTANCE * (1.0 - metallic) + outputColor.rgb * metallic;\n\tvec3 diffuseColor = outputColor.rgb * (1.0 - metallic);\n\n\tvec3 R = reflect(-V, N);\n\n    outputColor.rgb = ibLight(N, V, roughness, diffuseColor, F0, 1.0);\n\n\tfragColor = outputColor;\n}\n",
		"shaders/pp_fxaa.frag": "#version 300 es\n\n/**\n * FXAA post-process\n *\n * Based on webgl-meincraft FXAA implementation.\n * https://github.com/mitsuhiko/webgl-meincraft/blob/master/assets/shaders/fxaa.glsl\n */\n\n/*\nCopyright (c) 2011 by Armin Ronacher.\n\nSome rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/**\n * Basic FXAA implementation based on the code on geeks3d.com with the\n * modification that the texture2DLod stuff was removed since it's\n * unsupported by WebGL.\n */\n\nprecision highp float;\n\nuniform sampler2D src;\n\nuniform vec2 ViewportSize;\nuniform float reduce_min;\nuniform float reduce_mul;\nuniform float span_max;\n\nin vec2 uv;\nout vec4 fragColor;\n\nvec4 fxaa(sampler2D tex, vec2 texCoord) {\n    vec4 color = texture(tex, texCoord);\n    vec2 inverseVP = vec2(1.0 / ViewportSize.x, 1.0 / ViewportSize.y);\n    vec3 rgbNW = texture(tex, texCoord + vec2(-1.0, -1.0) * inverseVP).xyz;\n    vec3 rgbNE = texture(tex, texCoord + vec2(1.0, -1.0) * inverseVP).xyz;\n    vec3 rgbSW = texture(tex, texCoord + vec2(-1.0, 1.0) * inverseVP).xyz;\n    vec3 rgbSE = texture(tex, texCoord + vec2(1.0, 1.0) * inverseVP).xyz;\n    vec3 rgbM = color.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM = dot(rgbM, luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * reduce_mul), reduce_min);\n\n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(span_max, span_max), max(vec2(-span_max, -span_max), dir * rcpDirMin)) * inverseVP;\n\n    vec3 rgbA = 0.5 * (\n    texture(tex, texCoord + dir * (1.0 / 3.0 - 0.5)).xyz +\n    texture(tex, texCoord + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture(tex, texCoord + dir * -0.5).xyz +\n    texture(tex, texCoord + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n    color.rgb = rgbA;\n    else\n    color.rgb = rgbB;\n    return color;\n}\n\nvoid main () {\n    fragColor = fxaa(src, uv);\n}\n",
		"shaders/pp_oit.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D oitAccum;\nuniform sampler2D oitReveal;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main(void) {\n    vec4 accum = texture(oitAccum, uv);\n    float reveal = texture(oitReveal, uv).a;\n\n    fragColor = vec4(accum.rgb / max(accum.a, 1e-5), reveal);\n}\n",
		"shaders/quad.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D tex0;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = texture(tex0, uv);\n}\n",
		"shaders/skybox.frag": "#version 300 es\n\nprecision highp float;\n\nuniform samplerCube diffuse0;\n\nin vec3 uvw;\n\nout vec4 fragColor;\n\nvoid main() {\n    fragColor = texture(diffuse0, uvw);\n    //fragColor = vec4(uvw, 1.0);\n}\n",
		"shaders/tonemap.frag": "#version 300 es\n\nprecision highp float;\n\nuniform sampler2D src;\n\nin vec2 uv;\n\nout vec4 fragColor;\n\nfloat luminance(vec3 v) {\n    return dot(v, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 changeLuminance(vec3 cIn, float lOut) {\n    float lIn = luminance(cIn);\n    return cIn * (lOut / lIn);\n}\n\nvec3 reinhardLuminance(vec3 color) {\n    float lOld = luminance(color);\n    float lNew = lOld / (1.0f + lOld);\n    return changeLuminance(color, lNew);\n}\n\nvec3 reinhardExtendedLuminance(vec3 color, float maxWhiteL) {\n    float lOld = luminance(color);\n    float numerator = lOld * (1.0f + (lOld / (maxWhiteL * maxWhiteL)));\n    float lNew = numerator / (1.0f + lOld);\n    return changeLuminance(color, lNew);\n}\n\nvec3 reinhardJodie(vec3 v) {\n    float l = luminance(v);\n    vec3 tv = v / (1.0f + v);\n    return mix(v / (1.0f + l), tv, tv);\n}\n\nvec3 acesApprox(vec3 v) {\n    v *= 0.6f;\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\nvoid main(void) {\n    vec4 outputColor = texture(src, uv);\n\n#if TONEMAP == TONEMAP_ACES\n    fragColor = vec4(acesApprox(outputColor.rgb), 1.0);\n#elif TONEMAP == TONEMAP_NONE\n\tfragColor = outputColor;\n#endif\n}\n",
		"shaders/uv.vert": "#version 300 es\n\n#include \"snippets/camera.glsl\"\n\nlayout(location = 0) in vec3 position;\nlayout(location = 2) in vec2 texcoord2d0;\n\nout vec2 uv;\nout vec3 uvw;\n\nvoid main() {\n    vec3 unprojected = (projectionInverse * vec4(position, 1.0)).xyz;\n\n    uvw = mat3(viewInverse) * unprojected;\n    uvw.xyz *= -1.0;\n\tuv = texcoord2d0;\n\tgl_Position = vec4(position.xy, 0.0, 1.0);\n}\n",
		"shaders/vsm.frag": "#version 300 es\n\n/** Directional light shadow-map */\nprecision highp float;\n\nuniform float alphaCutoff;\nuniform vec4 diffuse;\n\n#ifdef DIFFUSE_TEXTURE\nuniform sampler2D diffuse0;\n\n#ifdef DIFFUSE_UV_TRANSFORM\nuniform mat3 diffuseUVTransform;\n#endif\n#endif\n\nin float depth;\nin vec2 uv0;\nout vec4 fragColor;\n\nvec2 diffuseUV() {\n\tvec3 uv = vec3(uv0, 1.0);\n\n#ifdef DIFFUSE_UV_TRANSFORM\n\tuv = diffuseUVTransform * uv;\n#endif\n\n\treturn uv.xy;\n}\n\nvoid main() {\n\tvec4 outputColor = diffuse;\n#ifdef DIFFUSE_TEXTURE\n\toutputColor *= texture(diffuse0, diffuseUV());\n#endif\n\n#if ALPHAMODE == ALPHAMODE_OPAQUE\n\toutputColor.a = 1.0;\n#endif\n\n\tfloat d = (depth + 1.0) * 0.5;\n\tfloat dx = dFdx(d);\n\tfloat dy = dFdy(d);\n\n\tfragColor = vec4(d, pow(d, 2.0) + 0.25*(dx * dx + dy * dy), 0.0, 1.0);\n\n#if ALPHAMODE == ALPHAMODE_MASK\n\tif (outputColor.a < alphaCutoff) {\n\t\tdiscard;\n\t}\n\toutputColor.a = 1.0;\n#elif ALPHAMODE == ALPHAMODE_BLEND\n\t// Only render opaque parts of transparent geometry\n\tif (outputColor.a < 0.99) {\n\t\tdiscard;\n\t}\n#endif\n}\n"
	},
	"snippets": {
		"shaders/snippets/camera.glsl": "uniform Camera {\n\tmat4 projection;\n\tmat4 projectionInverse;\n\tmat4 view;\n\tmat4 viewInverse;\n\tfloat zNear;\n\tfloat zFar;\n\tvec3 cameraPosition;\n};\n",
		"shaders/snippets/shadow.glsl": "uniform sampler2D shadow0;\n\nfloat linstep(float low, float high, float v) {\n\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n}\n\nfloat VSM(vec2 moments, float compare) {\n\tfloat p = smoothstep(compare - shadowBias, compare, moments.x);\n\tfloat variance = max(moments.y - moments.x*moments.x, -0.001);\n\tfloat d = compare - moments.x;\n\tfloat p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\treturn clamp(max(p, p_max), 0.0, 1.0);\n}\n\nfloat shadowmap(vec4 worldPosition) {\n\tvec4 shadowPosition = lightProjection * lightView * worldPosition;\n\tvec2 shadowUV = shadowPosition.xy / shadowPosition.w;\n\tshadowUV = shadowUV * 0.5 + 0.5;\n\tvec4 shadowTexel = texture(shadow0, shadowUV) * 2.0 - 1.0;\n\n\treturn VSM(shadowTexel.xy, shadowPosition.z);\n}\n"
	}
};
globalThis.BuiltInShaders = BuiltInShaders;
export default BuiltInShaders;